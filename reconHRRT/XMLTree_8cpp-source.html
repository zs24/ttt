<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>reconHRRT: XMLTree.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>XMLTree.cpp</h1><div class="fragment"><pre>00001 
00007 <span class="preprocessor">#include &lt;xercesc/util/PlatformUtils.hpp&gt;</span>
00008 <span class="preprocessor">#include &lt;xercesc/parsers/AbstractDOMParser.hpp&gt;</span>
00009 <span class="preprocessor">#include &lt;xercesc/dom/DOMImplementationRegistry.hpp&gt;</span>
00010 <span class="preprocessor">#include &lt;xercesc/dom/DOMBuilder.hpp&gt;</span>
00011 <span class="preprocessor">#include &lt;xercesc/dom/DOMException.hpp&gt;</span>
00012 <span class="preprocessor">#include &lt;xercesc/dom/DOMDocument.hpp&gt;</span>
00013 <span class="preprocessor">#include &lt;xercesc/dom/DOMElement.hpp&gt;</span>
00014 <span class="preprocessor">#include &lt;xercesc/dom/DOMNodeList.hpp&gt;</span>
00015 <span class="preprocessor">#include &lt;xercesc/dom/DOMError.hpp&gt;</span>
00016 <span class="preprocessor">#include &lt;xercesc/dom/DOMLocator.hpp&gt;</span>
00017 <span class="preprocessor">#include &lt;xercesc/dom/DOMNamedNodeMap.hpp&gt;</span>
00018 <span class="preprocessor">#include &lt;xercesc/dom/DOMAttr.hpp&gt;</span>
00019 <span class="preprocessor">#include &lt;xercesc/dom/DOMTreeWalker.hpp&gt;</span>
00020 <span class="preprocessor">#include &lt;xercesc/dom/DOMNode.hpp&gt;</span>
00021 <span class="preprocessor">#include &lt;xercesc/dom/DOMCharacterData.hpp&gt;</span>
00022 <span class="preprocessor">#include &lt;xercesc/dom/DOMDocumentFragment.hpp&gt;</span>
00023 <span class="preprocessor">#include &lt;xercesc/dom/DOMWriter.hpp&gt;</span>
00024 <span class="preprocessor">#include &lt;xercesc/framework/LocalFileFormatTarget.hpp&gt;</span>
00025 <span class="preprocessor">#include &lt;xercesc/framework/MemBufFormatTarget.hpp&gt;</span>
00026 <span class="preprocessor">#include &lt;xercesc/dom/DOMComment.hpp&gt;</span>
00027 <span class="preprocessor">#include &lt;string&gt;</span>
00028 <span class="preprocessor">#include &lt;fstream&gt;</span>
00029 <span class="preprocessor">#include &lt;sstream&gt;</span>
00030 <span class="preprocessor">#include &lt;vector&gt;</span>
00031 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00032 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00033 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00034 <span class="preprocessor">#include &lt;limits.h&gt;</span>     <span class="comment">// for INT_MAX, INT_MIN</span>
00035 <span class="preprocessor">#include &lt;iostream&gt;</span>
00036 
00037 
00038 <span class="preprocessor">#include "XMLTree.hpp"</span>
00039 <span class="preprocessor">#include "Log.hpp"</span>
00040 <span class="preprocessor">#include "Utilities.hpp"</span>
00041 
00042 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00043 
00044 <span class="keyword">static</span> <span class="keyword">const</span> XMLCh gLS[] = { chLatin_L, chLatin_S, chNull };
00045 
00046 XMLTree::XMLTree(string filename) {
00047 
00048    XMLTree::xmlFile = filename;
00049    XMLTree::multipleTags = <span class="keyword">false</span>;
00050    XMLTree::tagCount = 0;
00051    XMLTree::empty = <span class="keyword">false</span>;
00052    buildDomTree();
00053 }
00054 
00055 XMLTree::~XMLTree() {
00056 
00057    <span class="keywordflow">if</span>(XMLTree::docTree)
00058       XMLTree::docTree-&gt;release();
00059        <span class="comment">//  Delete the parser itself.  Must be done prior to calling Terminate, below.</span>
00060    <span class="keywordflow">if</span>(XMLTree::parser) {
00061           XMLTree::parser-&gt;release();
00062 
00063       <span class="comment">// And call the termination method</span>
00064           XMLPlatformUtils::Terminate();
00065    } <span class="keywordflow">else</span> { <span class="comment">// In case, we cloned the tree thru copy constructor</span>
00066       <span class="keywordflow">if</span>(XMLTree::domDoc)
00067        XMLTree::domDoc-&gt;release();
00068    }
00069    empty = <span class="keyword">true</span>;
00070 }
00071 
00072 <span class="comment">//Copy constructors - called from the Image copy constructor</span>
00073 XMLTree::XMLTree(XMLTree &amp;myTree) {
00074 
00075    initTree();
00076       DOMImplementation *impl = DOMImplementationRegistry::getDOMImplementation(gLS);
00077    XMLTree::domDoc = impl-&gt;createDocument();
00078    XMLTree::docTree = NULL;
00079    XMLTree::parser = NULL;
00080    XMLTree::multipleTags = <span class="keyword">false</span>;
00081    XMLTree::tagCount = 0;
00082    
00083    <span class="keywordflow">if</span> (copyTree(myTree))
00084       XMLTree::empty = <span class="keyword">false</span>;
00085    <span class="keywordflow">else</span> 
00086       XMLTree::empty = <span class="keyword">true</span>;
00087 }
00088 
00089 <span class="comment">// Simple constructor which creates a empty tree</span>
00090 XMLTree::XMLTree() {
00091 
00092    initTree();
00093        DOMImplementation *impl = DOMImplementationRegistry::getDOMImplementation(gLS);
00094    XMLTree::domDoc = impl-&gt;createDocument();
00095    XMLTree::docTree = NULL;
00096    XMLTree::parser = NULL;
00097    XMLTree::multipleTags = <span class="keyword">false</span>;
00098    XMLTree::tagCount = 0;
00099    empty = <span class="keyword">true</span>;
00100 }
00101 
00102 XMLTree&amp; XMLTree::operator=(XMLTree &amp;myTree) {
00103 
00104    initTree();
00105        DOMImplementation *impl = DOMImplementationRegistry::getDOMImplementation(gLS);
00106    XMLTree::domDoc = impl-&gt;createDocument();
00107    XMLTree::docTree = NULL;
00108    XMLTree::parser = NULL;
00109    XMLTree::multipleTags = <span class="keyword">false</span>;
00110    XMLTree::tagCount = 0;
00111       
00112    <span class="keywordflow">if</span> (copyTree(myTree))
00113       empty = <span class="keyword">false</span>;
00114    <span class="keywordflow">else</span> 
00115       empty = <span class="keyword">true</span>;
00116       
00117    <span class="keywordflow">return</span> (*this);
00118 }
00119 
00120 <span class="keywordtype">bool</span> XMLTree::copyTree(XMLTree &amp;myTree) {
00121    <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00122    verbType vt = FRAME;
00123    <span class="keywordflow">if</span>(myTree.domDoc == NULL) {
00124 
00125       log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::copyTree: Empty tree - cannot copy\n"</span>,vt,MEDIUM);
00126       XMLTree::domDoc = NULL;
00127       XMLTree::docTree = NULL;
00128       XMLTree::parser = NULL;
00129       XMLTree::multipleTags = <span class="keyword">false</span>;
00130       XMLTree::tagCount = 0;
00131 
00132       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00133 
00134    }
00135    DOMDocument *newDoc = myTree.domDoc;   
00136 
00137    <span class="keywordflow">if</span>(!newDoc) {
00138       log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::copyTree: Tree to be inserted is empty\n"</span>,vt,LOW);
00139       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00140    }
00141 
00142    DOMDocumentFragment *docFrag = newDoc-&gt;createDocumentFragment();
00143    DOMElement *rootElement = newDoc-&gt;getDocumentElement();
00144 
00145    <span class="keywordflow">if</span>(rootElement == NULL) {
00146       log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::copyTree: Tree is empty -- cannot insert\n"</span>,vt,LOW);
00147       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00148    }
00149    
00150    docFrag-&gt;appendChild(rootElement);
00151 
00152    <span class="comment">//Import docFrag under the ownership of the replaced document</span>
00153    <span class="comment">//DOMNode *replacingNode = XMLTree::domDoc-&gt;importNode(docFrag, true);</span>
00154    DOMNode *replacingNode = XMLTree::domDoc-&gt;importNode(rootElement, <span class="keyword">true</span>);
00155    XMLTree::domDoc-&gt;appendChild(replacingNode);
00156 <span class="preprocessor">   #ifdef DEBUG3</span>
00157 <span class="preprocessor"></span>   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree:copyTree-----creating a new tree\n"</span>,vt,DEBUGL);
00158 <span class="preprocessor">   #endif</span>
00159 <span class="preprocessor"></span>   newDoc-&gt;appendChild(rootElement);
00160    
00161    <span class="keywordflow">return</span> <span class="keyword">true</span>;
00162 
00163 }
00164 
00165 <span class="keywordtype">bool</span> XMLTree::parseFile(string filename) {
00166    XMLTree::xmlFile = filename;
00167    XMLTree::multipleTags = <span class="keyword">false</span>;
00168    XMLTree::tagCount = 0;
00169    buildDomTree();
00170    empty = <span class="keyword">false</span>;
00171    <span class="keywordflow">return</span> <span class="keyword">true</span>;
00172 }
00173 
00174 vector&lt;string&gt; XMLTree::parseSubTree(string subtree) {
00175    <span class="keywordtype">int</span> idx = 0;
00176    vector&lt;string&gt; subTrees(1);
00177    idx = subtree.find(<span class="stringliteral">"/"</span>, 0);   
00178    <span class="keywordflow">if</span>(idx == string::npos) {
00179       subTrees[0] = subtree;
00180       <span class="keywordflow">return</span> subTrees;
00181    }
00182    string str = subtree;
00183    idx = 0;
00184    <span class="keywordtype">int</span> prevIdx=0,i=0;
00185    <span class="keywordflow">while</span>((idx = str.find_first_of(<span class="stringliteral">"/"</span>, idx+1)) != string::npos) {
00186       <span class="keywordflow">if</span>(i &gt;= subTrees.size()) {
00187          subTrees.resize(i+1);
00188       }
00189 
00190       subTrees[i++] = str.substr(prevIdx, (idx-prevIdx));
00191       <span class="comment">//str = str.substr(idx+1);</span>
00192       prevIdx = idx+1;
00193    } 
00194    
00195    <span class="keywordflow">if</span>(i &gt;= subTrees.size()) {
00196       subTrees.resize(i+1);
00197    }
00198    subTrees[i] = str.substr(prevIdx);
00199 
00200    <span class="keywordflow">return</span> subTrees;
00201 }
00202 
00203 <span class="keywordtype">bool</span> XMLTree::setSubTreeByTreeParse(string subtree) {
00204 
00205    <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00206    verbType vt = FRAME;
00207 
00208    <span class="keywordflow">if</span>(XMLTree::domDoc) {
00209       XMLTree::docTree = 
00210          XMLTree::domDoc-&gt;createTreeWalker((DOMNode *)XMLTree::domDoc-&gt;getDocumentElement(),
00211           DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);
00212    } <span class="keywordflow">else</span> {
00213       log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">" XMLTree::setSubTreeByTreeParse: Document Tree not found"</span>,vt,LOW);
00214       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00215    }
00216 
00217    DOMNode *pCurrent;
00218    vector&lt;string&gt; parent = parseSubTree(subtree);
00219 
00220    <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
00221 
00222    <span class="keywordflow">if</span>(XMLTree::docTree == NULL) {
00223       log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">" XMLTree::setSubTreeByTreeParse: Null Tree object\n"</span>),vt,LOW);
00224       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00225    }
00226    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0 ; (i &lt; parent.size() &amp;&amp; parent[i].length() != 0) ; i++) {
00227       found = <span class="keyword">false</span>;
00228       <span class="keywordflow">if</span>( i != 0) {
00229          pCurrent = XMLTree::docTree-&gt;firstChild();
00230       } <span class="keywordflow">else</span> {
00231          pCurrent = XMLTree::docTree-&gt;getCurrentNode();
00232       }
00233       <span class="keywordflow">for</span>(; (!found &amp;&amp; pCurrent != NULL) ;) { 
00234           string curTag = XMLString::transcode(pCurrent-&gt;getNodeName());
00235          <span class="keywordflow">if</span>(curTag == parent[i]) {
00236 <span class="preprocessor">      #ifdef DEBUG3</span>
00237 <span class="preprocessor"></span>            log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">" XMLTree::setSubTreeByTreeParse: Found Subtree"</span>,vt,DEBUGL);
00238 <span class="preprocessor">      #endif</span>
00239 <span class="preprocessor"></span>            found = <span class="keyword">true</span>;
00240          } <span class="keywordflow">else</span> {
00241             pCurrent = XMLTree::docTree-&gt;nextSibling();
00242          }
00243        }
00244       <span class="keywordflow">if</span>(!found) {
00245          log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">" XMLTree::setSubTreeByTreeParse: Sub Tree not Found\n"</span>,vt,LOW);
00246          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00247       }
00248 
00249 <span class="comment">/***************************</span>
00250 <span class="comment">         pCurrent = XMLTree::docTree-&gt;firstChild();</span>
00251 <span class="comment">         if(pCurrent == NULL) {</span>
00252 <span class="comment">            log-&gt;outputMessage(" XMLTree::setSubTreeByTreeParse: Node not found:"+XMLString::transcode(pCurrent-&gt;getNodeName()) + "\n",vt,LOW);</span>
00253 <span class="comment">            return false;</span>
00254 <span class="comment">         }</span>
00255 <span class="comment">         while(pCurrent-&gt;getNodeType() != DOMNode::ELEMENT_NODE) {</span>
00256 <span class="comment">      #ifdef DEBUG3</span>
00257 <span class="comment">            log-&gt;outputMessage(" XMLTree::setSubTreeByTreeParse: Node:"+XMLString::transcode(pCurrent-&gt;getNodeName())+"\n" ,vt,DEBUGL);</span>
00258 <span class="comment">      #endif</span>
00259 <span class="comment">            pCurrent = XMLTree::docTree-&gt;nextNode();</span>
00260 <span class="comment">         } </span>
00261 <span class="comment">***************************/</span>            
00262 
00263          XMLTree::docTree = XMLTree::domDoc-&gt;createTreeWalker(pCurrent, DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);   
00264       }
00265       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00266    }
00267 
00268    <span class="keywordtype">bool</span> XMLTree::setSubTreeByGetEle(string subtree) {
00269 
00270       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00271       verbType vt = FRAME;
00272 
00273       vector&lt;string&gt; parent = parseSubTree(subtree);
00274       <span class="keywordtype">int</span> len = parent[parent.size()-1].length();
00275 
00276       XMLCh tmpStr[len+1];
00277 
00278       XMLString::transcode(parent[parent.size()-1].c_str(), tmpStr, len);      
00279 <span class="preprocessor">      #ifdef DEBUG3</span>
00280 <span class="preprocessor"></span>      log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByGetEle: Check for element:"</span>+ parent[parent.size()-1]+<span class="stringliteral">"\n"</span>, vt,DEBUGL);
00281 <span class="preprocessor">      #endif</span>
00282 <span class="preprocessor"></span>      DOMNodeList *ele = XMLTree::domDoc-&gt;getElementsByTagName(tmpStr);
00283       <span class="keywordflow">if</span>(ele-&gt;getLength() == 0) {
00284          log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByGetEle: "</span>+ parent[parent.size()-1]+ <span class="stringliteral">"---Tag Not found......"</span> + <span class="stringliteral">"\n"</span>,vt,DEBUGL);
00285          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00286       } <span class="keywordflow">else</span> {
00287          <span class="keywordflow">if</span>(ele-&gt;getLength() == 1) {
00288             XMLTree::curSubTree = 
00289       XMLTree::domDoc-&gt;createTreeWalker(ele-&gt;item(0)-&gt;getParentNode(), 
00290                   DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);
00291             XMLTree::docTree = XMLTree::domDoc-&gt;createTreeWalker(ele-&gt;item(0), 
00292                   DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);
00293             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00294          } <span class="keywordflow">else</span> {
00295             <span class="keywordtype">int</span> i, curIdx;
00296             DOMNode *pCur;
00297 
00298             <span class="keywordflow">for</span>(i=0 ; i &lt; ele-&gt;getLength() ; i++) {
00299                curIdx = i;
00300                pCur = ele-&gt;item(i);
00301                <span class="keywordtype">int</span> j;
00302                <span class="keywordflow">for</span>(j=parent.size()-1 ; (j &gt;= 0) ; j--) {
00303                   string curTag = XMLString::transcode(pCur-&gt;getNodeName());
00304                   <span class="keywordflow">if</span>(curTag == parent[j]) {
00305 <span class="preprocessor">      #ifdef DEBUG3</span>
00306 <span class="preprocessor"></span>                     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByGetEle: checking if:"</span>+
00307                curTag+<span class="stringliteral">"="</span>+parent[j]+<span class="stringliteral">"\n"</span>,vt,DEBUGL);;
00308 <span class="preprocessor">      #endif</span>
00309 <span class="preprocessor"></span>                     pCur = pCur-&gt;getParentNode();
00310                      <span class="keywordflow">continue</span>;
00311                   } <span class="keywordflow">else</span> {
00312 <span class="preprocessor">                     #ifdef DEBUG3</span>
00313 <span class="preprocessor"></span>                     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByGetEle: Found a mismatch\n"</span>,vt,DEBUGL);;
00314 <span class="preprocessor">                     #endif</span>
00315 <span class="preprocessor"></span>                     <span class="keywordflow">break</span>;
00316                   }
00317                }
00318                <span class="keywordflow">if</span>(j &lt; 0) {
00319                   <span class="keywordflow">break</span>;
00320                }
00321             }
00322             <span class="keywordflow">if</span>(i &lt; ele-&gt;getLength()) {
00323                XMLTree::curSubTree = 
00324          XMLTree::domDoc-&gt;createTreeWalker(ele-&gt;item(curIdx)-&gt;getParentNode(), 
00325             DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);
00326                XMLTree::docTree = XMLTree::domDoc-&gt;createTreeWalker(ele-&gt;item(curIdx), 
00327             DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);
00328                <span class="keywordflow">return</span> <span class="keyword">true</span>;
00329             } <span class="keywordflow">else</span> {
00330                <span class="keywordflow">return</span> <span class="keyword">false</span>;
00331             }
00332          }
00333       }
00334    }
00335    
00336    <span class="keywordtype">bool</span> XMLTree::setSubTreeByAttr(string subtree) {
00337 
00338       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00339       verbType vt = FRAME;
00340 
00341       vector&lt;string&gt; parent = parseSubTree(subtree);
00342       DOMNode *pCur = (DOMNode *) XMLTree::domDoc-&gt;getDocumentElement();
00343       DOMElement *pEle = (DOMElement *) XMLTree::domDoc-&gt;getDocumentElement();
00344 
00345       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0 ; i &lt; parent.size() ; i++) {
00346          <span class="keywordtype">int</span> idx=0;
00347          string tag, attrvalue;
00348          <span class="keywordflow">if</span>((idx = parent[i].find(<span class="stringliteral">"|"</span>)) != string::npos) {
00349             tag = parent[i].substr(0, idx);
00350             attrvalue = parent[i].substr(idx+1);
00351          } <span class="keywordflow">else</span> {
00352             tag = parent[i];
00353             attrvalue=<span class="stringliteral">""</span>;
00354          }
00355 
00356          XMLCh tmpStr[tag.length()+1];
00357 
00358          XMLString::transcode(tag.c_str(), tmpStr, tag.length());      
00359          string curEle = XMLString::transcode(pEle-&gt;getNodeName());
00360          <span class="keywordflow">if</span>(curEle == tag &amp;&amp; attrvalue == <span class="stringliteral">""</span>) {
00361 <span class="preprocessor">      #ifdef DEBUG3</span>
00362 <span class="preprocessor"></span>            log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByAttr: Current element itself is the tag\n"</span>,vt,DEBUGL);
00363 <span class="preprocessor">      #endif</span>
00364 <span class="preprocessor"></span>            <span class="keywordflow">continue</span>;
00365          }
00366          DOMNodeList *ele = pEle-&gt;getElementsByTagName(tmpStr);
00367 <span class="preprocessor">      #ifdef DEBUG3</span>
00368 <span class="preprocessor"></span>         log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByAttr: The current Element: "</span>+ string(XMLString::transcode(pEle-&gt;getNodeName()))+string(<span class="stringliteral">"\n"</span>),vt,DEBUGL);
00369 <span class="preprocessor">      #endif</span>
00370 <span class="preprocessor"></span>         <span class="keywordflow">if</span>(ele-&gt;getLength() == 0) {
00371             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00372          }<span class="keywordflow">else</span> {
00373             <span class="comment">//search through the ele and get the element </span>
00374             <span class="keywordflow">if</span>(attrvalue == <span class="stringliteral">""</span>) {
00375                <span class="keywordflow">if</span>(ele-&gt;getLength() == 1) {
00376                   pCur = (DOMNode *) ele-&gt;item(0);
00377                   <span class="keywordflow">if</span>(pCur-&gt;getNodeType() == DOMNode::ELEMENT_NODE) {
00378                      pEle = (DOMElement *) pCur;
00379                   } <span class="keywordflow">else</span> {
00380                      log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByAttr: Element:"</span>+tag+<span class="stringliteral">" found is not a valid element"</span>+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
00381                      <span class="keywordflow">return</span> <span class="keyword">false</span>;
00382                   }
00383                } <span class="keywordflow">else</span> {
00384                   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByAttr: Element:"</span>+tag+<span class="stringliteral">" without attribute should be unique"</span>+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
00385                   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00386                }
00387             } <span class="keywordflow">else</span> {
00388                <span class="keywordtype">bool</span> foundEle = <span class="keyword">false</span>;
00389                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0 ; (k &lt; ele-&gt;getLength() &amp;&amp; !foundEle) ; k++) {
00390                
00391                   pCur = (DOMNode *) ele-&gt;item(k);
00392                   <span class="keywordflow">if</span>(!pCur-&gt;hasAttributes()) {
00393                      log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByAttr: Element:"</span>+tag+<span class="stringliteral">" doesnt have attributes, Go to next element\n"</span>,vt,DEBUGL);
00394                      <span class="keywordflow">continue</span>;
00395                   }
00396                        DOMNamedNodeMap *pAttributes = pCur-&gt;getAttributes();
00397                        <span class="keywordtype">int</span> nSize = pAttributes-&gt;getLength();
00398                   <span class="keywordtype">int</span> j;
00399                        <span class="keywordflow">for</span>(j=0 ; j &lt; nSize ; j++) {
00400                                   DOMAttr *pAttributeNode = (DOMAttr*) pAttributes-&gt;item(j);
00401                                   <span class="comment">// get attribute name</span>
00402                                   string aname = XMLString::transcode(pAttributeNode-&gt;getName());
00403 
00404                                   <span class="comment">// get attribute value</span>
00405                                   string avalue = XMLString::transcode(pAttributeNode-&gt;getValue());
00406 
00407                      <span class="keywordflow">if</span>(aname == <span class="stringliteral">"name"</span>) {
00408                         <span class="keywordflow">if</span>(avalue == attrvalue) {
00409                            <span class="keywordflow">if</span>(pCur-&gt;getNodeType() == DOMNode::ELEMENT_NODE) {
00410                               pEle = (DOMElement *) pCur;
00411                               foundEle = <span class="keyword">true</span>;
00412                               <span class="keywordflow">break</span>;
00413                            } <span class="keywordflow">else</span> {
00414                               log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByAttr: Element:"</span>+tag+<span class="stringliteral">" found is not a valid element"</span>+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
00415                               <span class="keywordflow">return</span> <span class="keyword">false</span>;
00416                            }
00417                         }
00418                      }
00419                   }
00420 
00421                }
00422                <span class="keywordflow">if</span>(!foundEle) {
00423                   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTreeByAttr: Element:"</span>+tag+<span class="stringliteral">" with that attribute not found\n"</span>,vt,DEBUGL);
00424                   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00425                }
00426             }
00427          }
00428       }
00429       
00430       XMLTree::docTree = XMLTree::domDoc-&gt;createTreeWalker((DOMNode *)pEle, DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);
00431       
00432 
00433       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00434    }
00435 
00436    <span class="keywordtype">bool</span> XMLTree::setSubTree(string subtree, string tag, <span class="keywordtype">bool</span> flag) {
00437       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00438       verbType vt = FRAME;
00439 
00440 <span class="preprocessor">      #ifdef DEBUG3</span>
00441 <span class="preprocessor"></span>         log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTree: In setSubTree: subtree:"</span>+subtree+<span class="stringliteral">" tag:"</span>+tag+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
00442 <span class="preprocessor">      #endif</span>
00443 <span class="preprocessor"></span>      DOMNode *pCurrent;
00444 
00445       <span class="keywordflow">if</span>(!multipleTags || tagCount == 1) {
00446          <span class="comment">//XMLTree::tagCount = 1;</span>
00447          <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
00448          <span class="keywordflow">if</span>(subtree.find(<span class="stringliteral">"|"</span>) == string::npos) {
00449             result = setSubTreeByGetEle(subtree);
00450          } <span class="keywordflow">else</span> {
00451             result = setSubTreeByAttr(subtree);
00452          }
00453    
00454          <span class="keywordflow">if</span>(!result) {
00455             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00456          }
00457       } <span class="keywordflow">else</span> { <span class="comment">// Mulitple same name tags -- For Image readers</span>
00458          pCurrent = XMLTree::curSubTree-&gt;getCurrentNode();
00459 <span class="preprocessor">      #ifdef DEBUG3</span>
00460 <span class="preprocessor"></span>         log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTree: Parsing same name tags of tag:"</span>+string(XMLString::transcode(pCurrent-&gt;getNodeName()))+string(<span class="stringliteral">"\n"</span>),vt,DEBUGL);
00461 <span class="preprocessor">      #endif</span>
00462 <span class="preprocessor"></span>
00463          DOMNode *pChild;
00464          <span class="keywordtype">int</span> idx = XMLTree::tagCount;
00465          <span class="keywordtype">int</span> i=0;
00466          DOMNodeList *pNodes = pCurrent-&gt;getChildNodes();
00467          <span class="keywordtype">int</span> len = pNodes-&gt;getLength();
00468          <span class="keywordflow">for</span>(i=0 ; i &lt; len ; i++) {
00469             pChild = pNodes-&gt;item(i);
00470 <span class="preprocessor">      #ifdef DEBUG3</span>
00471 <span class="preprocessor"></span>            log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTree: Current node :"</span>+ string(XMLString::transcode(pChild-&gt;getNodeName()))+string(<span class="stringliteral">"\n"</span>),vt,DEBUGL);
00472             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTree: Current tag :"</span>+ tag+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
00473 <span class="preprocessor">      #endif</span>
00474 <span class="preprocessor"></span>            string tagName = XMLString::transcode(pChild-&gt;getNodeName());
00475             <span class="keywordflow">if</span>(tagName == tag &amp;&amp; idx &gt; 1) {
00476                idx--;
00477             } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(idx &lt;= 1 &amp;&amp; tagName == tag) {
00478 <span class="preprocessor">      #ifdef DEBUG3</span>
00479 <span class="preprocessor"></span>               log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTree: next similar tags found\n"</span>,vt,DEBUGL);
00480 <span class="preprocessor">      #endif</span>
00481 <span class="preprocessor"></span>               <span class="keywordflow">break</span>;
00482             }
00483                   
00484          }
00485          <span class="keywordflow">if</span>(i &gt;= len) {
00486             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTree: No multiple tags  for tag:"</span>+tag+<span class="stringliteral">" found\n"</span>,vt,DEBUGL);
00487             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00488          }
00489          pCurrent = pChild;
00490          <span class="keywordflow">if</span>(pCurrent != NULL) {
00491             XMLTree::docTree = XMLTree::domDoc-&gt;createTreeWalker(pCurrent, DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);
00492             <span class="comment">//XMLTree::tagCount++;</span>
00493          } <span class="keywordflow">else</span> {
00494             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::setSubTree: tag:"</span>+tag+<span class="stringliteral">" not found \n"</span>,vt,DEBUGL);
00495             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00496          }
00497       }
00498       <span class="comment">//prevSubTree = subtree;</span>
00499 
00500       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00501    }
00502 
00503    <span class="keywordtype">bool</span> XMLTree::getTagValueStr(string subtree, string tag, string &amp;value) {
00504       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00505       verbType vt = FRAME;
00506 
00507       DOMNode *pCurrent;
00508 
00509       <span class="keywordflow">if</span>(subtree != <span class="stringliteral">""</span>) {
00510          <span class="keywordflow">if</span>(tag != <span class="stringliteral">""</span>) {
00511             <span class="keywordflow">if</span>(subtree.find_last_of(<span class="stringliteral">"/"</span>) != (subtree.length()-1)) {
00512                subtree += <span class="stringliteral">"/"</span>;
00513             }
00514             subtree = subtree+tag;
00515          }
00516       }
00517 
00518       <span class="keywordflow">if</span>(!setSubTree(subtree, tag, multipleTags)) {
00519          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00520       }
00521 
00522       <span class="comment">//prevGetTag = true;</span>
00523 
00524       DOMTreeWalker *walker = XMLTree::docTree;
00525 
00526       DOMNode *rootTree = walker-&gt;getCurrentNode();
00527       pCurrent = walker-&gt;getCurrentNode();
00528 
00529 <span class="preprocessor">      #ifdef DEBUG3</span>
00530 <span class="preprocessor"></span>      log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::getTagValueStr: Tag Node:"</span>+string(XMLString::transcode(pCurrent-&gt;getNodeName()))+string(<span class="stringliteral">"\n"</span>),vt,DEBUGL);
00531 <span class="preprocessor">      #endif</span>
00532 <span class="preprocessor"></span>
00533       <span class="keywordflow">if</span>(pCurrent-&gt;getNodeValue() == NULL &amp;&amp; (pCurrent = walker-&gt;nextNode()) != NULL) {
00534          <span class="keywordflow">while</span>(pCurrent-&gt;getNodeType() != DOMNode::TEXT_NODE &amp;&amp; pCurrent != NULL) {
00535             pCurrent = walker-&gt;nextNode();
00536          } 
00537       }   
00538 
00539 
00540       XMLTree::docTree = XMLTree::domDoc-&gt;createTreeWalker(rootTree, DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);
00541       <span class="keywordflow">if</span>(pCurrent != NULL) {
00542          value = XMLString::transcode(pCurrent-&gt;getNodeValue());
00543          value = <a class="code" href="classUtilities.html#e10">Utilities::trim</a>(value);
00544          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00545       } <span class="keywordflow">else</span> {
00546          log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::getTagValueStr: Tag:"</span>+tag+<span class="stringliteral">"  Value not found\n"</span>,vt,DEBUGL);
00547          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00548       }
00549 
00550    }
00551 
00552    <span class="keywordtype">bool</span> XMLTree::getTagAttributes(string subtree, string tag, string &amp;attributes) {
00553 
00554       <span class="keywordflow">if</span>(subtree != <span class="stringliteral">""</span>) {
00555          <span class="keywordflow">if</span>(tag != <span class="stringliteral">""</span>) {
00556             <span class="keywordflow">if</span>(subtree.find_last_of(<span class="stringliteral">"/"</span>) != (subtree.length()-1)) {
00557                subtree += <span class="stringliteral">"/"</span>;
00558             }
00559             subtree = subtree+tag;
00560          }
00561       }
00562 
00563       <span class="keywordflow">if</span>(!setSubTree(subtree, tag, multipleTags)) {
00564          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00565       }
00566 
00567       <span class="comment">//prevGetTag = true;</span>
00568 
00569       DOMTreeWalker *walker = XMLTree::docTree;
00570 
00571       DOMNode *pCurrent = walker-&gt;getCurrentNode();
00572 
00573       attributes = <span class="stringliteral">""</span>;
00574 
00575       <span class="keywordflow">if</span>(pCurrent-&gt;hasAttributes()) {
00576       
00577          DOMNamedNodeMap *pAttributes = pCurrent-&gt;getAttributes();
00578               <span class="keywordtype">int</span> nSize = pAttributes-&gt;getLength();
00579          <span class="keywordtype">int</span> j;
00580                <span class="keywordflow">for</span>(j=0 ; j &lt; nSize ; j++) {
00581                    DOMAttr *pAttributeNode = (DOMAttr*) pAttributes-&gt;item(j);
00582                    <span class="comment">// get attribute name</span>
00583                    string aname = XMLString::transcode(pAttributeNode-&gt;getName());
00584 
00585                    <span class="comment">// get attribute value</span>
00586                    string avalue = XMLString::transcode(pAttributeNode-&gt;getValue());
00587             attributes += aname+<span class="stringliteral">"=\""</span>+avalue+<span class="stringliteral">"\" "</span>;
00588          }
00589       }
00590 
00591       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00592    }
00593    <span class="keywordtype">bool</span> XMLTree::getTagValue(string subtree, string tag, string &amp;value, string &amp;attributes) {
00594       getTagValue(subtree, tag, value);
00595       <span class="comment">//prevGetTag = false;</span>
00596       <span class="keywordflow">if</span> (getTagAttributes(subtree, tag, attributes)) {
00597          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00598       }
00599       <span class="keywordflow">return</span> <span class="keyword">false</span>;   
00600    }
00601 
00602    <span class="keywordtype">bool</span> XMLTree::getTagValue(string subtree, string tag, <span class="keywordtype">float</span> &amp;value, string &amp;attributes) {
00603       getTagValue(subtree, tag, value);
00604       <span class="comment">//prevGetTag = false;</span>
00605       <span class="keywordflow">if</span> (getTagAttributes(subtree, tag, attributes)) {
00606          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00607       }
00608       <span class="keywordflow">return</span> <span class="keyword">false</span>;   
00609    }
00610 
00611    <span class="keywordtype">bool</span> XMLTree::getTagValue(string subtree, string tag, <span class="keywordtype">int</span> &amp;value, string &amp;attributes) {
00612       getTagValue(subtree, tag, value);
00613       <span class="comment">//prevGetTag = false;</span>
00614       <span class="keywordflow">if</span> (getTagAttributes(subtree, tag, attributes)) {
00615          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00616       }
00617       <span class="keywordflow">return</span> <span class="keyword">false</span>;   
00618    }
00619 
00620    <span class="keywordtype">bool</span> XMLTree::getTagValue(string subtree, string tag, <span class="keywordtype">int</span> &amp;value) {
00621 
00622       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00623       verbType vt = FRAME;
00624 
00625       string tagVal = <span class="stringliteral">""</span>;
00626       <span class="keywordflow">if</span>(getTagValueStr(subtree, tag, tagVal)) {
00627          getRidOfTrailingBlanks(tagVal);
00628          <span class="keywordflow">if</span>(isGoodInt(tagVal)) {
00629              value = atoi(tagVal.c_str());
00630              <span class="keywordflow">return</span> <span class="keyword">true</span>;
00631          } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(isGoodDouble(tagVal)) {
00632             value = (<span class="keywordtype">int</span>) stringToFloat(tagVal);
00633          } <span class="keywordflow">else</span> {
00634             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::getTagValue: Tag:"</span>+tag+<span class="stringliteral">"has value:"</span>+tagVal+<span class="stringliteral">" Not a Integer\n"</span>,vt,DEBUGL);
00635             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00636          }
00637          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00638       } <span class="keywordflow">else</span> {
00639          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00640       }
00641    }
00642 
00643    <span class="keywordtype">bool</span> XMLTree::getTagValue(string subtree, string tag, <span class="keywordtype">short</span> &amp;value) {
00644 
00645       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00646       verbType vt = FRAME;
00647 
00648       string tagVal;
00649       <span class="keywordflow">if</span>(getTagValueStr(subtree, tag, tagVal)) {
00650          getRidOfTrailingBlanks(tagVal);
00651          <span class="keywordflow">if</span>(isGoodInt(tagVal)) {
00652             value = (<span class="keywordtype">short</span>) atoi(tagVal.c_str());
00653             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00654          } <span class="keywordflow">else</span> {
00655             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::getTagValue: Tag:"</span>+tag+<span class="stringliteral">"has value:"</span>+tagVal+<span class="stringliteral">" Not a Short\n"</span>,vt,DEBUGL);
00656             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00657          }
00658         
00659       } <span class="keywordflow">else</span> {
00660          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00661       }
00662    }
00663 
00664    <span class="keywordtype">bool</span> XMLTree::getTagValue(string subtree, string tag, <span class="keywordtype">float</span> &amp;value) {
00665 
00666       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00667       verbType vt = FRAME;
00668 
00669       string tagVal;
00670       <span class="keywordflow">if</span>(getTagValueStr(subtree, tag, tagVal)) {
00671          getRidOfTrailingBlanks(tagVal);
00672          <span class="keywordflow">if</span>(isGoodDouble(tagVal)) {
00673             value = stringToFloat(tagVal);
00674          } <span class="keywordflow">else</span> {
00675             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::getTagValue: Tag:"</span>+tag+<span class="stringliteral">"has value:"</span>+tagVal+<span class="stringliteral">" Not a valid Float Value\n"</span>,vt,DEBUGL);
00676             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00677          }   
00678          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00679       } <span class="keywordflow">else</span> {
00680          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00681       }
00682    }
00683 
00684    <span class="keywordtype">bool</span> XMLTree::getTagValue(string subtree, string tag, string &amp;value) {
00685       <span class="keywordflow">if</span>(getTagValueStr(subtree, tag, value)) {
00686          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00687       } <span class="keywordflow">else</span> {
00688          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00689       }
00690    }
00691 
00692    <span class="keywordtype">bool</span> XMLTree::putTagValueStr(string subtree, string tag, string value) {
00693 
00694       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00695       verbType vt = FRAME;
00696 
00697       DOMNode *pCurrent;
00698           <span class="keywordtype">bool</span> errorOccurred = <span class="keyword">false</span>;
00699       <span class="keywordflow">try</span> {
00700          <span class="keywordflow">if</span>(subtree != <span class="stringliteral">""</span>) {
00701             <span class="keywordflow">if</span>(tag != <span class="stringliteral">""</span>) {
00702                <span class="keywordflow">if</span>(subtree.find_last_of(<span class="stringliteral">"/"</span>) != (subtree.length()-1)) {
00703                   subtree += <span class="stringliteral">"/"</span>;
00704                }
00705                subtree = subtree+tag;
00706             }
00707          }
00708 
00709          <span class="keywordflow">if</span>(!setSubTree(subtree, tag, multipleTags)) {
00710             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00711          }
00712    
00713          <span class="comment">//prevPutTag = true;</span>
00714 
00715          DOMTreeWalker *walker = XMLTree::docTree;
00716    
00717          DOMNode *rootTree = walker-&gt;getCurrentNode();
00718          pCurrent = walker-&gt;getCurrentNode();
00719          
00720          DOMNode *pParent = pCurrent;
00721    
00722          <span class="keywordflow">if</span>((pCurrent = walker-&gt;nextNode()) != NULL) {
00723             <span class="keywordflow">while</span>(pCurrent-&gt;getNodeType() != DOMNode::TEXT_NODE &amp;&amp; pCurrent != NULL) {
00724                pCurrent = walker-&gt;nextNode();
00725             } 
00726          }   
00727          XMLTree::docTree = XMLTree::domDoc-&gt;createTreeWalker(rootTree, DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);
00728          XMLCh tmpStr[256];
00729          <span class="keywordflow">if</span>(pCurrent != NULL) {
00730             pParent = pCurrent-&gt;getParentNode();
00731 
00732             string oldValue = XMLString::transcode(pCurrent-&gt;getNodeValue());
00733             <span class="keywordflow">if</span>(oldValue == value) {
00734                <span class="keywordflow">return</span> <span class="keyword">true</span>;
00735             }
00736    
00737             <span class="keywordflow">if</span>(pParent != NULL) {
00738                XMLString::transcode(value.c_str(), tmpStr, 255);
00739                DOMText *newTxt = XMLTree::domDoc-&gt;createTextNode(tmpStr);
00740                DOMNode *oldTxt = pParent-&gt;replaceChild((DOMNode *)newTxt, pCurrent);
00741             } <span class="keywordflow">else</span> {
00742                <span class="keywordflow">return</span> <span class="keyword">false</span>;
00743             }
00744             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00745          } <span class="keywordflow">else</span> { <span class="comment">//In case adding new tags - need to test.</span>
00746             <span class="keywordflow">if</span>(pParent != NULL) {
00747                          XMLString::transcode(value.c_str(), tmpStr, 255);
00748                          DOMText *newTxt = XMLTree::domDoc-&gt;createTextNode(tmpStr);
00749                          pParent-&gt;appendChild((DOMNode *)newTxt);
00750                  } <span class="keywordflow">else</span> {
00751                          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00752                  }
00753             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00754          }
00755               } <span class="keywordflow">catch</span> (<span class="keyword">const</span> XMLException&amp; toCatch)
00756               {
00757                   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">"XMLTree::putTagValueStr: \nException message is:\n"</span>)+
00758          <a class="code" href="classStrX.html">StrX</a>(toCatch.getMessage()).localForm() + string(<span class="stringliteral">"\n"</span>),vt,LOW);
00759                   errorOccurred = <span class="keyword">true</span>;
00760                   <span class="keywordflow">return</span> <span class="keyword">false</span>; 
00761               }
00762               <span class="keywordflow">catch</span> (<span class="keyword">const</span> DOMException&amp; toCatch)
00763               {
00764                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxChars = 2047;
00765                   XMLCh errText[maxChars + 1];
00766       
00767                   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">"XMLTree::putTagValueStr: \nDOM Error during putTagValue \n"</span>),vt,LOW);
00768    
00769                   <span class="keywordflow">if</span> (DOMImplementation::loadDOMExceptionMsg(toCatch.code, errText, maxChars))
00770                        log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">"XMLTree::putTagValueStr: Message is: "</span>) + string(<a class="code" href="classStrX.html">StrX</a>(errText).localForm()) + string(<span class="stringliteral">"\n"</span>),vt,LOW);
00771    
00772                   errorOccurred = <span class="keyword">true</span>;
00773                   <span class="keywordflow">return</span> <span class="keyword">false</span>; 
00774               }
00775               <span class="keywordflow">catch</span> (...)
00776               {
00777                   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::putTagValueStr: \nUnexpected exception during putTagValue: \n"</span>,vt,LOW);
00778                   errorOccurred = <span class="keyword">true</span>;
00779                   <span class="keywordflow">return</span> <span class="keyword">false</span>; 
00780               }
00781    }
00782 
00783    <span class="keywordtype">bool</span> XMLTree::putTagValue(string subtree, string tag, <span class="keywordtype">int</span> value) {
00784       
00785       stringstream ss;
00786       string tagVal=<span class="stringliteral">""</span>;
00787 
00788       ss &lt;&lt; value;
00789       ss &gt;&gt; tagVal;
00790 
00791       <span class="keywordflow">if</span>(putTagValueStr(subtree, tag, tagVal)) {
00792          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00793       } <span class="keywordflow">else</span> {
00794          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00795       }
00796    }
00797 
00798    <span class="keywordtype">bool</span> XMLTree::putTagValue(string subtree, string tag, <span class="keywordtype">float</span> value) {
00799       stringstream ss;
00800       string tagVal=<span class="stringliteral">""</span>;
00801 
00802       ss &lt;&lt; value;
00803       ss &gt;&gt; tagVal;
00804 
00805       <span class="keywordflow">if</span>(putTagValueStr(subtree, tag, tagVal)) {
00806          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00807       } <span class="keywordflow">else</span> {
00808          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00809       }
00810    }
00811 
00812    <span class="keywordtype">bool</span> XMLTree::putTagValue(string subtree, string tag, string value) {
00813       <span class="keywordflow">if</span>(putTagValueStr(subtree, tag, value)) {
00814          <span class="keywordflow">return</span> <span class="keyword">true</span>;
00815       } <span class="keywordflow">else</span> {
00816          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00817       }
00818    }
00819 
00820    <span class="keywordtype">void</span> XMLTree::splitAttributes(string attributes, map&lt;string, string&gt; &amp;attr) {
00821 
00822       <span class="keywordtype">int</span> idx=0, eIdx = 0;
00823       <span class="keywordflow">while</span>((idx = attributes.find_first_of(<span class="stringliteral">"="</span>)) != string::npos) {
00824          string key = attributes.substr(0, idx);
00825          string value = attributes.substr(idx+1);
00826          attributes = attributes.substr(idx+1); <span class="comment">//remove the key out from attributes</span>
00827          <span class="keywordflow">if</span>((idx = value.find_first_of(<span class="stringliteral">"\""</span>)) != string::npos) {
00828             value = value.substr(idx+1);
00829             eIdx = value.find_first_of(<span class="stringliteral">"\""</span>);
00830             value = value.substr(0, eIdx);
00831             <span class="keywordflow">if</span>((eIdx+3) &gt; attributes.length()) {
00832                attr[key] = value;
00833                <span class="keywordflow">break</span>;
00834             } <span class="keywordflow">else</span> {
00835                eIdx += 3;
00836             }
00837             attributes = attributes.substr(eIdx); <span class="comment">//remove the value out from attributes</span>
00838          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((eIdx = value.find_first_of(<span class="stringliteral">" "</span>)) != string::npos) {
00839             value = value.substr(0, eIdx);
00840             <span class="keywordflow">if</span>((eIdx+2) &gt; attributes.length()) {
00841                attr[key] = value;
00842                <span class="keywordflow">break</span>;
00843             } <span class="keywordflow">else</span> {
00844                eIdx += 2;
00845             }
00846             attributes = attributes.substr(eIdx); <span class="comment">//remove the value out from attributes</span>
00847          }
00848          
00849          attr[key] = value;
00850       }
00851 
00852    }
00853    
00854    <span class="keywordtype">bool</span> XMLTree::setTagAttributes(string subtree, string tag, string attributes) {
00855 
00856       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00857       verbType vt = FRAME;
00858 
00859           <span class="keywordtype">bool</span> errorOccurred = <span class="keyword">false</span>;
00860 
00861       <span class="keywordflow">try</span> {
00862          <span class="keywordflow">if</span>(subtree != <span class="stringliteral">""</span>) {
00863             <span class="keywordflow">if</span>(tag != <span class="stringliteral">""</span>) {
00864                <span class="keywordflow">if</span>(subtree.find_last_of(<span class="stringliteral">"/"</span>) != (subtree.length()-1)) {
00865                   subtree += <span class="stringliteral">"/"</span>;
00866                }
00867                subtree = subtree+tag;
00868             }
00869          }
00870 
00871          <span class="keywordflow">if</span>(!setSubTree(subtree, tag, multipleTags)) {
00872             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00873          }
00874 
00875          <span class="comment">//prevPutTag = true;</span>
00876    
00877          DOMTreeWalker *walker = XMLTree::docTree;
00878    
00879          DOMElement *pCurrent = (DOMElement *) walker-&gt;getCurrentNode();
00880          
00881          map&lt;string, string&gt; attrmap;
00882          splitAttributes(attributes, attrmap);
00883    
00884          map&lt;string,string&gt;::iterator iter = attrmap.begin();
00885          <span class="keywordflow">while</span>(iter != attrmap.end()) {
00886             string attName = iter-&gt;first;
00887             string attValue = iter-&gt;second;
00888 
00889             attName = <a class="code" href="classUtilities.html#e10">Utilities::trim</a>(attName);
00890             attValue = <a class="code" href="classUtilities.html#e10">Utilities::trim</a>(attValue);
00891             XMLCh tmpStr[256];
00892             XMLString::transcode(attName.c_str(), tmpStr, 255);
00893             DOMAttr *pAttr = XMLTree::domDoc-&gt;createAttribute(tmpStr);
00894             XMLString::transcode(attValue.c_str(), tmpStr, 255);
00895             pAttr-&gt;setValue(tmpStr);
00896             
00897             pCurrent-&gt;setAttributeNode(pAttr);
00898             iter++;
00899          }
00900       
00901               } <span class="keywordflow">catch</span> (<span class="keyword">const</span> XMLException&amp; toCatch)
00902               {
00903                   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">" XMLTree::setTagAttributes: \nError during putTagValue: \nException message is:  \n"</span>)
00904                        + string(<a class="code" href="classStrX.html">StrX</a>(toCatch.getMessage()).localForm()) + string(<span class="stringliteral">"\n"</span>),vt,LOW);
00905                   errorOccurred = <span class="keyword">true</span>;
00906               }
00907               <span class="keywordflow">catch</span> (<span class="keyword">const</span> DOMException&amp; toCatch)
00908               {
00909                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxChars = 2047;
00910                   XMLCh errText[maxChars + 1];
00911       
00912                   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">" XMLTree::setTagAttributes: \nDOM Error during putTagValue \n"</span> ,vt,LOW);
00913    
00914                   <span class="keywordflow">if</span> (DOMImplementation::loadDOMExceptionMsg(toCatch.code, errText, maxChars))
00915                        log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">" XMLTree::setTagAttributes: Message is: "</span>) + string(<a class="code" href="classStrX.html">StrX</a>(errText).localForm()) + string(<span class="stringliteral">"\n"</span>),vt,LOW);
00916    
00917                      errorOccurred = <span class="keyword">true</span>;
00918               }
00919               <span class="keywordflow">catch</span> (...)
00920               {
00921                   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">" XMLTree::setTagAttributes: \nUnexpected exception during putTagValue: \n"</span>,vt,LOW);
00922                   errorOccurred = <span class="keyword">true</span>;
00923               }
00924       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00925    }
00926 
00927    <span class="keywordtype">bool</span> XMLTree::putTagValue(string subtree, string tag, string value, string attributes) {
00928       <span class="keywordflow">if</span>(tag != <span class="stringliteral">""</span> &amp;&amp; value != <span class="stringliteral">""</span>) {
00929          <span class="keywordflow">if</span>(!putTagValue(subtree, tag, value) ) {
00930             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00931          }
00932       }
00933       <span class="keywordflow">if</span>((subtree != <span class="stringliteral">""</span> || tag != <span class="stringliteral">""</span>) &amp;&amp; attributes != <span class="stringliteral">""</span>) {
00934          <span class="keywordflow">if</span> (!setTagAttributes(subtree, tag, attributes)) {
00935             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00936          }
00937       }
00938       <span class="keywordflow">return</span> <span class="keyword">true</span>;   
00939    }
00940 
00941    <span class="keywordtype">bool</span> XMLTree::putTagValue(string subtree, string tag, <span class="keywordtype">float</span> value, string attributes) {
00942       <span class="keywordflow">if</span>(tag != <span class="stringliteral">""</span> &amp;&amp; value != 0.0) {
00943          <span class="keywordflow">if</span>(!putTagValue(subtree, tag, value) ) {
00944             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00945          }
00946       }
00947       <span class="keywordflow">if</span>((subtree != <span class="stringliteral">""</span> || tag != <span class="stringliteral">""</span>) &amp;&amp; attributes != <span class="stringliteral">""</span>) {
00948          <span class="keywordflow">if</span> (!setTagAttributes(subtree, tag, attributes)) {
00949             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00950          }
00951       }
00952       <span class="keywordflow">return</span> <span class="keyword">true</span>;   
00953    }
00954 
00955    <span class="keywordtype">bool</span> XMLTree::putTagValue(string subtree, string tag, <span class="keywordtype">int</span> value, string attributes) {
00956       <span class="keywordflow">if</span>(tag != <span class="stringliteral">""</span> &amp;&amp; value != 0) {
00957          <span class="keywordflow">if</span>(!putTagValue(subtree, tag, value) ) {
00958             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00959          }
00960       }
00961       <span class="keywordflow">if</span>((subtree != <span class="stringliteral">""</span> || tag != <span class="stringliteral">""</span>) &amp;&amp; attributes != <span class="stringliteral">""</span>) {
00962          <span class="keywordflow">if</span> (!setTagAttributes(subtree, tag, attributes)) {
00963             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00964          }
00965       }
00966  
00967       <span class="keywordflow">return</span> <span class="keyword">true</span>;   
00968    }
00969 
00970 <span class="keywordtype">bool</span> XMLTree::insertTree(string subtree, XMLTree &amp;newTree, string tag, string value, string attributes) {
00971 
00972    <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00973    verbType vt = FRAME;
00974 
00975    <span class="keywordflow">if</span>(tag!= <span class="stringliteral">""</span> &amp;&amp; (value != <span class="stringliteral">""</span> || attributes != <span class="stringliteral">""</span>)) {
00976       <span class="keywordflow">if</span>(!putTagValue(subtree, tag, value, attributes) ) {
00977          log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::insertTree: putTagValue failed for tag:"</span>+tag+<span class="stringliteral">" \n"</span>,vt,DEBUGL);
00978       }
00979    }
00980    <span class="keywordflow">if</span>(&amp;newTree) {
00981       <span class="keywordflow">if</span>(!insertSubTree(subtree, newTree)) {
00982          <span class="keywordflow">return</span> <span class="keyword">false</span>;
00983       }
00984    }
00985    <span class="keywordflow">return</span> <span class="keyword">true</span>;
00986 }
00987 
00988 <span class="keywordtype">bool</span> XMLTree::insertTree(string subtree, XMLTree &amp;newTree, string tag, <span class="keywordtype">int</span> value, string attributes) {
00989    <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00990    verbType vt = FRAME;
00991 
00992    <span class="keywordflow">if</span>(tag!= <span class="stringliteral">""</span> &amp;&amp; (value != 0 || attributes != <span class="stringliteral">""</span>)) {
00993       <span class="keywordflow">if</span>(!putTagValue(subtree, tag, value, attributes) ) {
00994          log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::insertTree: putTagAttrValue failed for tag:"</span>+tag+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
00995       }
00996    }
00997 
00998    <span class="keywordflow">if</span>(&amp;newTree) {
00999       <span class="keywordflow">if</span>(!insertSubTree(subtree, newTree)) {
01000          <span class="keywordflow">return</span> <span class="keyword">false</span>;
01001       }
01002    }
01003    <span class="keywordflow">return</span> <span class="keyword">true</span>;
01004 }
01005 
01006 <span class="keywordtype">bool</span> XMLTree::insertTree(string subtree, XMLTree &amp;newTree, string tag, <span class="keywordtype">float</span> value, string attributes) {
01007 
01008    <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
01009    verbType vt = FRAME;
01010 
01011    <span class="keywordflow">if</span>(tag!= <span class="stringliteral">""</span> &amp;&amp; (value != 0.0 || attributes != <span class="stringliteral">""</span>)) {
01012       <span class="keywordflow">if</span>(!putTagValue(subtree, tag, value, attributes) ) {
01013          log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::insertTree: putTagAttrValue failed for tag:"</span>+tag+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
01014       }
01015    }
01016 
01017    <span class="keywordflow">if</span>(&amp;newTree) {
01018       <span class="keywordflow">if</span>(!insertSubTree(subtree, newTree)) {
01019          <span class="keywordflow">return</span> <span class="keyword">false</span>;
01020       }
01021    }
01022    <span class="keywordflow">return</span> <span class="keyword">true</span>;
01023 }
01024 
01025 <span class="keywordtype">bool</span> XMLTree::insertSubTree(string subtree, XMLTree &amp;newTree) {
01026    <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
01027    verbType vt = FRAME;
01028 
01029    <span class="comment">// If we are adding as a root node of the tree</span>
01030    <span class="keywordflow">if</span>(subtree == <span class="stringliteral">""</span>) {
01031       <span class="keywordflow">if</span>(copyTree(newTree)) {
01032          <span class="keywordflow">return</span> <span class="keyword">true</span>;
01033       } <span class="keywordflow">else</span> {
01034          <span class="keywordflow">return</span> <span class="keyword">false</span>;
01035       }
01036    }
01037 
01038    <span class="keywordflow">if</span>(!setSubTreeByGetEle(subtree) ) {
01039       log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::insertSubTree: cannot find subtree:"</span>+subtree+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
01040       <span class="keywordflow">return</span> <span class="keyword">false</span>;
01041    }
01042    DOMTreeWalker *pWalker = XMLTree::docTree;
01043    XMLTree::curSubTree = XMLTree::docTree; <span class="comment">// Resetting the curSubTree since this is insertTree</span>
01044    DOMNode *pCurrent = pWalker-&gt;getCurrentNode();
01045    
01046    DOMDocument *newDoc = newTree.domDoc;   
01047 
01048    <span class="keywordflow">if</span>(!newDoc) {
01049       log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::insertSubTree: Tree to be inserted is empty\n"</span>,vt,DEBUGL);
01050       <span class="keywordflow">return</span> <span class="keyword">false</span>;
01051    }
01052 
01053    DOMDocumentFragment *docFrag = newDoc-&gt;createDocumentFragment();
01054    DOMElement *rootElement = newDoc-&gt;getDocumentElement();
01055    
01056    <span class="keywordflow">if</span>(rootElement == NULL) {
01057       log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::insertSubTree: Tree is empty -- cannot insert\n"</span>,vt,DEBUGL);
01058       <span class="keywordflow">return</span> <span class="keyword">false</span>;
01059    }
01060    docFrag-&gt;appendChild(rootElement);
01061 
01062    <span class="comment">//Import docFrag under the ownership of the replaced document</span>
01063    DOMNode *replacingNode = XMLTree::domDoc-&gt;importNode(docFrag, <span class="keyword">true</span>);
01064    pCurrent-&gt;appendChild(replacingNode);
01065    newDoc-&gt;appendChild(rootElement);
01066    
01067    <span class="keywordflow">return</span> <span class="keyword">true</span>;
01068 }
01069    
01070 <span class="keywordtype">bool</span> XMLTree::insertTag(string subtree, string tag) {
01071 
01072    <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
01073    verbType vt = FRAME;
01074 
01075    <span class="keywordflow">if</span>(tag == <span class="stringliteral">""</span>) {
01076       log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::insertTag: Empty tag\n"</span>,vt,DEBUGL);
01077       <span class="keywordflow">return</span> <span class="keyword">false</span>;
01078    }
01079        <span class="keywordtype">bool</span> errorOccurred = <span class="keyword">false</span>;
01080 
01081    <span class="keywordflow">try</span> {
01082       XMLCh tmpStr[tag.length()+1];
01083       XMLString::transcode(tag.c_str(), tmpStr, tag.length());
01084 
01085       <span class="keywordflow">if</span>(subtree == <span class="stringliteral">""</span>) {
01086 <span class="preprocessor">         #ifdef DEBUG3</span>
01087 <span class="preprocessor"></span>         log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::insertTag: Creating a new tree\n"</span>,vt,DEBUGL);
01088 <span class="preprocessor">         #endif</span>
01089 <span class="preprocessor"></span>         <span class="keywordflow">if</span>(XMLTree::domDoc-&gt;getDocumentElement() == NULL) {
01090 
01091             DOMElement *pEle = XMLTree::domDoc-&gt;createElement(tmpStr);
01092             XMLTree::domDoc-&gt;appendChild(pEle);
01093             
01094             <span class="keywordflow">return</span> <span class="keyword">true</span>;
01095 
01096          } <span class="keywordflow">else</span> {
01097             DOMNode *pCurrent = XMLTree::domDoc-&gt;getDocumentElement();
01098 
01099             <span class="keywordflow">if</span>(pCurrent-&gt;getFirstChild() != NULL) {
01100                log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::insertTag: Tree not empty\n"</span>,vt,DEBUGL);
01101                <span class="keywordflow">return</span> <span class="keyword">false</span>;
01102             }
01103          }
01104          <span class="comment">// Creating a new DOMDocument structure</span>
01105          DOMElement *pEle = XMLTree::domDoc-&gt;createElement(tmpStr);
01106    
01107          XMLTree::domDoc-&gt;appendChild(pEle);
01108          
01109       } <span class="keywordflow">else</span> {
01110       <span class="comment">// Insert a child node under the subtree</span>
01111          <span class="keywordflow">if</span>(!setSubTreeByGetEle(subtree) ) {
01112             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::insertTag: In insertTag cannot find subtree:"</span>+subtree+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
01113             <span class="keywordflow">return</span> <span class="keyword">false</span>;
01114          }
01115          DOMTreeWalker *pWalker = XMLTree::docTree;
01116          XMLTree::curSubTree = XMLTree::docTree; <span class="comment">// Resetting the curSubTree since this is insertTag</span>
01117          DOMNode *pCurrent = pWalker-&gt;getCurrentNode();
01118          
01119          DOMElement *pEle = XMLTree::domDoc-&gt;createElement(tmpStr);
01120 
01121          pCurrent-&gt;appendChild(pEle);
01122       }
01123         } <span class="keywordflow">catch</span> (<span class="keyword">const</span> XMLException&amp; toCatch) {
01124             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">"XMLTree::insertTag: \nError during parsing: '"</span>) + XMLTree::xmlFile + string(<span class="stringliteral">"'\nException message is:  \n"</span>)
01125   + string(<a class="code" href="classStrX.html">StrX</a>(toCatch.getMessage()).localForm()) + string(<span class="stringliteral">"\n"</span>),vt,DEBUGL);
01126             errorOccurred = <span class="keyword">true</span>;
01127         } <span class="keywordflow">catch</span> (<span class="keyword">const</span> DOMException&amp; toCatch) {
01128             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxChars = 2047;
01129             XMLCh errText[maxChars + 1];
01130 
01131             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">"XMLTree::insertTag: \nDOM Error during parsing: '"</span>) + XMLTree::xmlFile + string(<span class="stringliteral">"'\n"</span>),vt,DEBUGL);
01132 
01133             <span class="keywordflow">if</span> (DOMImplementation::loadDOMExceptionMsg(toCatch.code, errText, maxChars))
01134   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">"XMLTree::insertTag: Message is: "</span>) + string(<a class="code" href="classStrX.html">StrX</a>(errText).localForm()) + string(<span class="stringliteral">"\n"</span>),vt,DEBUGL);
01135 
01136             errorOccurred = <span class="keyword">true</span>;
01137         } <span class="keywordflow">catch</span> (...) {
01138             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">"XMLTree::insertTag: \nUnexpected exception during parsing: '"</span>) + XMLTree::xmlFile + string(<span class="stringliteral">"'\n"</span>),vt,DEBUGL);
01139             errorOccurred = <span class="keyword">true</span>;
01140         }
01141 
01142    <span class="keywordflow">return</span> <span class="keyword">true</span>;
01143    }
01144 
01145    <span class="keywordtype">bool</span> XMLTree::removeTag(string subtree, string tag) {
01146    
01147       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
01148       verbType vt = FRAME;
01149 
01150       <span class="keywordflow">if</span>(tag == <span class="stringliteral">""</span>) {
01151          log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">" XMLTree::removeTag: Empty tag:"</span>+tag+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
01152          <span class="keywordflow">return</span> <span class="keyword">false</span>;
01153       }
01154 
01155       XMLCh tmpStr[tag.length()+1];
01156 
01157       XMLString::transcode(tag.c_str(), tmpStr, tag.length());
01158 
01159       DOMElement *pEle = XMLTree::domDoc-&gt;createElement(tmpStr);
01160       
01161       <span class="keywordflow">if</span>(subtree == <span class="stringliteral">""</span>) {
01162       <span class="comment">// Removing the whole tree... very risky call ??</span>
01163          XMLTree::domDoc-&gt;removeChild(pEle);
01164          
01165       } <span class="keywordflow">else</span> {
01166       <span class="comment">// remove a child node under the subtree</span>
01167          <span class="keywordflow">if</span>(!setSubTreeByGetEle(subtree) ) {
01168             <span class="keywordflow">return</span> <span class="keyword">false</span>;
01169          }
01170          DOMTreeWalker *pWalker = XMLTree::docTree;
01171          XMLTree::curSubTree = XMLTree::docTree; <span class="comment">// Resetting the curSubTree since this is insertTag</span>
01172          DOMNode *pCurrent = pWalker-&gt;getCurrentNode();
01173          
01174          pCurrent-&gt;removeChild(pEle);
01175       }
01176       <span class="keywordflow">return</span> <span class="keyword">true</span>;
01177    }
01178 
01179    <span class="keywordtype">bool</span> XMLTree::replaceTag(string subtree, string tag) {
01180    
01181       <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
01182       verbType vt = FRAME;
01183 
01184       <span class="keywordflow">if</span>(tag == <span class="stringliteral">""</span>) {
01185          log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTree::replaceTag: Empty tag:"</span>+tag+<span class="stringliteral">"\n"</span>,vt,DEBUGL);
01186          <span class="keywordflow">return</span> <span class="keyword">false</span>;
01187       }
01188 
01189       XMLCh tmpStr[tag.length()+1];
01190 
01191       XMLString::transcode(tag.c_str(), tmpStr, tag.length());
01192 
01193       DOMElement *pEle = XMLTree::domDoc-&gt;createElement(tmpStr);
01194       
01195       <span class="keywordflow">if</span>(subtree == <span class="stringliteral">""</span>) {
01196       <span class="comment">// Replacing the whole tree... very risky call ??</span>
01197          DOMNode *pCurrent = XMLTree::domDoc-&gt;getDocumentElement();
01198          XMLTree::domDoc-&gt;replaceChild(pEle, pCurrent);
01199          
01200       } <span class="keywordflow">else</span> {
01201          <span class="comment">// replace a child node under the subtree</span>
01202          <span class="keywordflow">if</span>(subtree.find_last_of(<span class="stringliteral">"/"</span>) != (subtree.length()-1)) {
01203             subtree += <span class="stringliteral">"/"</span>;
01204          }
01205          subtree = subtree+tag;
01206 
01207          <span class="keywordflow">if</span>(!setSubTreeByGetEle(subtree) ) {
01208             <span class="keywordflow">return</span> <span class="keyword">false</span>;
01209          }
01210          DOMTreeWalker *pWalker = XMLTree::docTree;
01211          XMLTree::curSubTree = XMLTree::docTree; <span class="comment">// Resetting the curSubTree since this is insertTag</span>
01212          DOMNode *pCurrent = pWalker-&gt;getCurrentNode();
01213          DOMNode *pParent = pCurrent-&gt;getParentNode();
01214          
01215          pParent-&gt;replaceChild(pEle, pCurrent);
01216       }
01217       <span class="keywordflow">return</span> <span class="keyword">true</span>;
01218    }
01219 
01220 <span class="keywordtype">void</span> XMLTree::initTree() {
01221     <span class="keywordtype">bool</span>        recognizeNEL = <span class="keyword">false</span>;
01222     <span class="keywordtype">char</span>        localeStr[64];
01223     memset(localeStr, 0, <span class="keyword">sizeof</span> localeStr);
01224    <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
01225    verbType vt = FRAME;
01226 
01227 
01228     <span class="comment">// Initialize the XML4C system</span>
01229     <span class="keywordflow">try</span>
01230     {
01231         <span class="keywordflow">if</span> (strlen(localeStr))
01232         {
01233             XMLPlatformUtils::Initialize(localeStr);
01234         }
01235         <span class="keywordflow">else</span>
01236         {
01237             XMLPlatformUtils::Initialize();
01238         }
01239 
01240         <span class="keywordflow">if</span> (recognizeNEL)
01241         {
01242             XMLPlatformUtils::recognizeNEL(recognizeNEL);
01243         }
01244     }
01245 
01246     <span class="keywordflow">catch</span> (<span class="keyword">const</span> XMLException&amp; toCatch)
01247     {
01248          log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">"XMLTree::initTree: Error during initialization! :\n"</span>)
01249               + string(<a class="code" href="classStrX.html">StrX</a>(toCatch.getMessage()).localForm()) + string(<span class="stringliteral">"\n"</span>),vt,DEBUGL);
01250     }
01251 
01252 }
01253 
01254 <span class="comment">// ---------------------------------------------------------------------------</span>
01255 <span class="comment">//</span>
01256 <span class="comment">//          parse the XML File and build the XML tree</span>
01257 <span class="comment">//</span>
01258 <span class="comment">// ---------------------------------------------------------------------------</span>
01259 <span class="keywordtype">void</span> XMLTree::buildDomTree() {
01260 
01261     AbstractDOMParser::ValSchemes valScheme = AbstractDOMParser::Val_Auto;
01262     <span class="keywordtype">bool</span>        doNamespaces       = <span class="keyword">false</span>;
01263     <span class="keywordtype">bool</span>        doSchema           = <span class="keyword">false</span>;
01264     <span class="keywordtype">bool</span>        schemaFullChecking = <span class="keyword">false</span>;
01265     <span class="keywordtype">bool</span>        errorOccurred = <span class="keyword">false</span>;
01266     <span class="keywordtype">bool</span>        printOutEncounteredEles = <span class="keyword">false</span>;
01267    <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
01268    verbType vt = FRAME;
01269 
01270 
01271 
01272     initTree();
01273     <span class="comment">// Instantiate the DOM parser.</span>
01274 
01275     <span class="comment">//static const XMLCh gLS[] = { chLatin_L, chLatin_S, chNull };</span>
01276     DOMImplementation *impl = DOMImplementationRegistry::getDOMImplementation(gLS);
01277     XMLTree::parser = ((DOMImplementationLS*)impl)-&gt;createDOMBuilder(DOMImplementationLS::MODE_SYNCHRONOUS, 0);
01278 
01279     XMLTree::parser-&gt;setFeature(XMLUni::fgDOMNamespaces, doNamespaces);
01280     XMLTree::parser-&gt;setFeature(XMLUni::fgXercesSchema, doSchema);
01281     XMLTree::parser-&gt;setFeature(XMLUni::fgXercesSchemaFullChecking, schemaFullChecking);
01282 
01283     <span class="keywordflow">if</span> (valScheme == AbstractDOMParser::Val_Auto)
01284     {
01285         XMLTree::parser-&gt;setFeature(XMLUni::fgDOMValidateIfSchema, <span class="keyword">true</span>);
01286     }
01287     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (valScheme == AbstractDOMParser::Val_Never)
01288     {
01289         XMLTree::parser-&gt;setFeature(XMLUni::fgDOMValidation, <span class="keyword">false</span>);
01290     }
01291     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (valScheme == AbstractDOMParser::Val_Always)
01292     {
01293         XMLTree::parser-&gt;setFeature(XMLUni::fgDOMValidation, <span class="keyword">true</span>);
01294     }
01295 
01296     <span class="comment">// enable datatype normalization - default is off</span>
01297     XMLTree::parser-&gt;setFeature(XMLUni::fgDOMDatatypeNormalization, <span class="keyword">true</span>);
01298 
01299     <span class="comment">// And create our error handler and install it</span>
01300     <a class="code" href="classXMLTreeErrorHandler.html">XMLTreeErrorHandler</a> errorHandler;
01301     XMLTree::parser-&gt;setErrorHandler(&amp;errorHandler);
01302 
01303         <span class="comment">//reset error count first</span>
01304         errorHandler.<a class="code" href="classXMLTreeErrorHandler.html#a4">resetErrors</a>();
01305 
01306         <span class="comment">//XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument *doc = 0;</span>
01307 
01308         <span class="keywordflow">try</span>
01309         {
01310             <span class="comment">// reset document pool</span>
01311             XMLTree::parser-&gt;resetDocumentPool();
01312 
01313             XMLTree::domDoc = XMLTree::parser-&gt;parseURI(XMLTree::xmlFile.c_str());
01314         }
01315 
01316         <span class="keywordflow">catch</span> (<span class="keyword">const</span> XMLException&amp; toCatch)
01317         {
01318             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">" XMLTree::buildDomTree: \nError during parsing: '"</span> + XMLTree::xmlFile + <span class="stringliteral">"'\n"</span>
01319   + <span class="stringliteral">"Exception message is:  \n"</span>
01320   + <a class="code" href="classStrX.html">StrX</a>(toCatch.getMessage()).localForm() + <span class="stringliteral">"\n"</span> + <span class="stringliteral">"\n"</span>,vt,MEDIUM);
01321             errorOccurred = <span class="keyword">true</span>;
01322         }
01323         <span class="keywordflow">catch</span> (<span class="keyword">const</span> DOMException&amp; toCatch)
01324         {
01325             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxChars = 2047;
01326             XMLCh errText[maxChars + 1];
01327 
01328             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">" XMLTree::buildDomTree: \nDOM Error during parsing: '"</span>) + XMLTree::xmlFile + string(<span class="stringliteral">"'\n"</span>),vt,MEDIUM);
01329 
01330             <span class="keywordflow">if</span> (DOMImplementation::loadDOMExceptionMsg(toCatch.code, errText, maxChars))
01331   log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">" XMLTree::buildDomTree: Message is: "</span>) + string(<a class="code" href="classStrX.html">StrX</a>(errText).localForm()) + string(<span class="stringliteral">"\n"</span>),vt,MEDIUM);
01332 
01333             errorOccurred = <span class="keyword">true</span>;
01334         }
01335         <span class="keywordflow">catch</span> (...)
01336         {
01337             log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">" XMLTree::buildDomTree: \nUnexpected exception during parsing: '"</span> + XMLTree::xmlFile + <span class="stringliteral">"'\n"</span>,vt,HIGH);
01338             errorOccurred = <span class="keyword">true</span>;
01339         }
01340 
01341         <span class="comment">//</span>
01342         <span class="comment">//  Extract the DOM tree, get the list of all the elements and report the</span>
01343         <span class="comment">//  length as the count of elements.</span>
01344         <span class="comment">//</span>
01345         <span class="keywordflow">if</span> (errorHandler.<a class="code" href="classXMLTreeErrorHandler.html#a2">getSawErrors</a>())
01346         {
01347 <span class="preprocessor">      #ifdef DEBUG3</span>
01348 <span class="preprocessor"></span>            log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"\nErrors occurred, no output available\n"</span>,vt,DEBUGL);
01349 <span class="preprocessor">      #endif</span>
01350 <span class="preprocessor"></span>            errorOccurred = <span class="keyword">true</span>;
01351         } <span class="keywordflow">else</span> {
01352 
01353       <span class="keywordflow">if</span>(XMLTree::domDoc) {
01354       XMLTree::docTree = 
01355          XMLTree::domDoc-&gt;createTreeWalker((DOMNode *)XMLTree::domDoc-&gt;getDocumentElement(),
01356           DOMNodeFilter::SHOW_ALL, NULL, <span class="keyword">true</span>);
01357       }
01358    }
01359     <span class="comment">//</span>
01360     <span class="comment">//  Delete the parser itself.  Must be done prior to calling Terminate, below.</span>
01361     <span class="comment">//</span>
01362     <span class="comment">//parser-&gt;release();</span>
01363 
01364     <span class="comment">// And call the termination method</span>
01365     <span class="comment">//XMLPlatformUtils::Terminate();</span>
01366 
01367 
01368 }
01369 
01370 <span class="keywordtype">bool</span> XMLTree::toString(string &amp;tree) {
01371         DOMImplementation *impl = XMLTree::domDoc-&gt;getImplementation();
01372         DOMWriter *pWriter =((DOMImplementationLS*)impl)-&gt;createDOMWriter();
01373 
01374         MemBufFormatTarget *pTarget = <span class="keyword">new</span> MemBufFormatTarget();
01375 
01376         <span class="comment">// Set user specified end of line sequence and output encoding</span>
01377    XMLCh tmpStr[100];
01378         XMLString::transcode(<span class="stringliteral">"\n"</span>, tmpStr, 99);
01379         pWriter-&gt;setNewLine(tmpStr);
01380 
01381         <span class="comment">// set feature if the serializer supports the feature/mode</span>
01382         <span class="keywordflow">if</span> ( pWriter-&gt;canSetFeature(XMLUni::fgDOMWRTSplitCdataSections, <span class="keyword">false</span>) )
01383  pWriter-&gt;setFeature(XMLUni::fgDOMWRTSplitCdataSections, <span class="keyword">false</span>);
01384 
01385         <span class="keywordflow">if</span> ( pWriter-&gt;canSetFeature(XMLUni::fgDOMWRTDiscardDefaultContent, <span class="keyword">false</span>) )
01386  pWriter-&gt;setFeature(XMLUni::fgDOMWRTDiscardDefaultContent, <span class="keyword">false</span>);
01387 
01388         <span class="keywordflow">if</span> ( pWriter-&gt;canSetFeature(XMLUni::fgDOMWRTFormatPrettyPrint, <span class="keyword">true</span>) )
01389  pWriter-&gt;setFeature(XMLUni::fgDOMWRTFormatPrettyPrint, <span class="keyword">true</span>);
01390 
01391         <span class="keywordflow">if</span> ( pWriter-&gt;canSetFeature(XMLUni::fgDOMWRTBOM, <span class="keyword">false</span>) )
01392  pWriter-&gt;setFeature(XMLUni::fgDOMWRTBOM, <span class="keyword">false</span>);
01393 
01394         pWriter-&gt;writeNode(pTarget, *XMLTree::domDoc);
01395 
01396    tree = string((<span class="keywordtype">char</span> *)pTarget-&gt;getRawBuffer());
01397 
01398    pWriter-&gt;release();
01399    <span class="keyword">delete</span> pTarget;
01400 
01401         <span class="keywordflow">return</span> <span class="keyword">true</span>;
01402 }
01403 
01404 <span class="keywordtype">bool</span> XMLTree::insertComment(string subtree, string comment) {
01405    XMLCh tmpStr[comment.length()+1];
01406 
01407    XMLString::transcode(comment.c_str(), tmpStr, comment.length());
01408 
01409    DOMComment *pComment = XMLTree::domDoc-&gt;createComment(tmpStr);
01410 
01411    <span class="keywordflow">if</span>(!setSubTreeByGetEle(subtree)) {
01412       <span class="keywordflow">return</span> <span class="keyword">false</span>;
01413    }
01414    DOMTreeWalker *curTree = XMLTree::docTree;
01415    DOMNode *pCurrent = curTree-&gt;getCurrentNode();
01416    pCurrent-&gt;appendChild(pComment);  <span class="comment">// Add the comment as a child node</span>
01417 
01418    <span class="keywordflow">return</span> <span class="keyword">true</span>;
01419 }
01420 
01421 <span class="keywordtype">bool</span> XMLTree::writeTreeToFile(string xmlFile) {
01422        DOMImplementation *impl = XMLTree::domDoc-&gt;getImplementation();
01423    DOMWriter *pWriter =((DOMImplementationLS*)impl)-&gt;createDOMWriter();
01424    
01425    XMLCh tmpStr[xmlFile.length()+1];
01426    XMLString::transcode(xmlFile.c_str(), tmpStr, xmlFile.length());
01427    XMLFormatTarget *pTarget = <span class="keyword">new</span> LocalFileFormatTarget(tmpStr);
01428 
01429    <span class="comment">// Set user specified end of line sequence and output encoding</span>
01430    XMLString::transcode(<span class="stringliteral">"\n"</span>, tmpStr, 255);
01431    pWriter-&gt;setNewLine(tmpStr);
01432 
01433      <span class="comment">// set feature if the serializer supports the feature/mode</span>
01434      <span class="keywordflow">if</span> ( pWriter-&gt;canSetFeature(XMLUni::fgDOMWRTSplitCdataSections, <span class="keyword">false</span>) )
01435           pWriter-&gt;setFeature(XMLUni::fgDOMWRTSplitCdataSections, <span class="keyword">false</span>);
01436 
01437      <span class="keywordflow">if</span> ( pWriter-&gt;canSetFeature(XMLUni::fgDOMWRTDiscardDefaultContent, <span class="keyword">false</span>) )
01438           pWriter-&gt;setFeature(XMLUni::fgDOMWRTDiscardDefaultContent, <span class="keyword">false</span>);
01439 
01440    <span class="comment">/***********</span>
01441 <span class="comment">     if ( pWriter-&gt;canSetFeature(XMLUni::fgDOMWhitespaceInElementContent, true) )</span>
01442 <span class="comment">          pWriter-&gt;setFeature(XMLUni::fgDOMWhitespaceInElementContent, true);</span>
01443 <span class="comment">   *************/</span>
01444 
01445      <span class="keywordflow">if</span> ( pWriter-&gt;canSetFeature(XMLUni::fgDOMWRTFormatPrettyPrint, <span class="keyword">true</span>) )
01446           pWriter-&gt;setFeature(XMLUni::fgDOMWRTFormatPrettyPrint, <span class="keyword">true</span>);
01447 
01448      <span class="keywordflow">if</span> ( pWriter-&gt;canSetFeature(XMLUni::fgDOMWRTBOM, <span class="keyword">false</span>) )
01449           pWriter-&gt;setFeature(XMLUni::fgDOMWRTBOM, <span class="keyword">false</span>);
01450 
01451      pWriter-&gt;writeNode(pTarget, *XMLTree::domDoc);
01452 
01453    pTarget-&gt;flush();
01454    pWriter-&gt;release();
01455 
01456    <span class="keyword">delete</span> pTarget;
01457 
01458    <span class="keywordflow">return</span> <span class="keyword">true</span>;
01459    
01460    }
01461 
<a name="l01462"></a><a class="code" href="classXMLTreeErrorHandler.html#a0">01462</a> <a class="code" href="classXMLTreeErrorHandler.html#a0">XMLTreeErrorHandler::XMLTreeErrorHandler</a>() :
01463 
01464     fSawErrors(false)
01465 {
01466 }
01467 
01468 XMLTreeErrorHandler::~XMLTreeErrorHandler()
01469 {
01470 }
01471 
01472 
01473 <span class="comment">// ---------------------------------------------------------------------------</span>
01474 <span class="comment">// XMLTreeErrorHandler : Overrides of the DOM ErrorHandler interface</span>
01475 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l01476"></a><a class="code" href="classXMLTreeErrorHandler.html#a3">01476</a> <span class="keywordtype">bool</span> <a class="code" href="classXMLTreeErrorHandler.html#a3">XMLTreeErrorHandler::handleError</a>(<span class="keyword">const</span> DOMError&amp; domError)
01477 {
01478    <a class="code" href="classLog.html">Log</a> *log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
01479    verbType vt = FRAME;
01480 
01481     fSawErrors = <span class="keyword">true</span>;
01482     <span class="keywordflow">if</span> (domError.getSeverity() == DOMError::DOM_SEVERITY_WARNING)
01483         log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTreeErrorHandler::handleError: \nWarning at file "</span>,vt,LOW);
01484     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (domError.getSeverity() == DOMError::DOM_SEVERITY_ERROR)
01485         log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTreeErrorHandler::handleError: \nError at file "</span>,vt,MEDIUM);
01486     <span class="keywordflow">else</span>
01487         log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(<span class="stringliteral">"XMLTreeErrorHandler::handleError: \nFatal Error at file "</span>,vt,HIGH);
01488 
01489     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(string(<span class="stringliteral">"XMLTreeErrorHandler::handleError:"</span>)+ string(<a class="code" href="classStrX.html">StrX</a>(domError.getLocation()-&gt;getURI()).localForm())
01490          + string(<span class="stringliteral">"\n  Message: "</span>) + string(<a class="code" href="classStrX.html">StrX</a>(domError.getMessage()).localForm()) + string(<span class="stringliteral">"\n"</span>),vt,INFO);
01491 
01492     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01493 }
01494 
01495 <span class="keywordtype">void</span> XMLTreeErrorHandler::resetErrors()
01496 {
01497     fSawErrors = <span class="keyword">false</span>;
01498 }
01499  
01500    
01501 
01502 
01503 <span class="comment">// ***********************************************************************</span>
01504 <span class="comment">// Constants</span>
01505 <span class="comment">// ***********************************************************************</span>
01506 <span class="keyword">const</span> <span class="keywordtype">char</span> BLANK = <span class="charliteral">' '</span>;
01507 <span class="keyword">const</span> <span class="keywordtype">char</span> TERMINATOR = <span class="charliteral">'\0'</span>;
01508 <span class="keyword">const</span> <span class="keywordtype">char</span> DECIMALPOINT = <span class="charliteral">'.'</span>;
01509 <span class="keyword">const</span> <span class="keywordtype">int</span> MAXSTRING = 256;
01510 
01511 <span class="comment">// ***********************************************************************</span>
01512 <span class="comment">// Utility functions.</span>
01513 <span class="comment">// These functions are not available to the clients.</span>
01514 <span class="comment">// ***********************************************************************</span>
01515 
01516 <span class="comment">// Function:   isSign(aChar)</span>
01517 <span class="comment">// Purpose:    Returns true if aChar is either a '+' or a '-';</span>
01518 <span class="comment">//             false, otherwise</span>
01519 <span class="keywordtype">bool</span> XMLTree::isSign(<span class="keywordtype">char</span> aChar)
01520 {
01521    <span class="keywordflow">if</span> ((aChar == <span class="charliteral">'+'</span>) || (aChar == <span class="charliteral">'-'</span>))
01522    {
01523       <span class="keywordflow">return</span> <span class="keyword">true</span>;
01524    }
01525    <span class="keywordflow">else</span>
01526    {
01527       <span class="keywordflow">return</span> <span class="keyword">false</span>;
01528    }
01529 }  <span class="comment">// end isSign</span>
01530 
01531 
01532 <span class="comment">// Function:    getRidOfTrailingBlanks(string&amp; aString)</span>
01533 <span class="comment">// Purpose:     if aString ends with trailing blanks, get rid of them</span>
01534 <span class="keywordtype">void</span> XMLTree::getRidOfTrailingBlanks(string&amp; aString)
01535 {
01536    <span class="comment">// Local data ...</span>
01537    <span class="keywordtype">char</span> *workString;              <span class="comment">// old style string; we'll do work here</span>
01538    <span class="keywordtype">int</span> index;      <span class="comment">// index into string</span>
01539    <span class="keywordtype">bool</span> stillBlank;<span class="comment">// still trailing blanks in scan</span>
01540 
01541    <span class="comment">// Logic ...</span>
01542    <span class="comment">// Copy aString into workString</span>
01543    workString = (<span class="keywordtype">char</span> *) aString.c_str();    <span class="comment">// new dynamic object</span>
01544    index = strlen(workString) - 1;   <span class="comment">// index for last character in the string</span>
01545    stillBlank = <span class="keyword">true</span>;
01546 
01547    <span class="comment">// Shift TERMINATOR left so long as blanks are encountered</span>
01548    <span class="keywordflow">while</span> ((index &gt;= 0) &amp;&amp; (stillBlank == <span class="keyword">true</span>))
01549    {
01550       <span class="keywordflow">if</span> (workString[index] == BLANK)
01551       {
01552          <span class="comment">// shift TERMINATOR left</span>
01553          workString[index] = TERMINATOR;
01554       }
01555       <span class="keywordflow">else</span>
01556       {
01557          <span class="comment">// first non-blank we encountered</span>
01558          stillBlank = <span class="keyword">false</span>;
01559       }
01560       index--;
01561    }  <span class="comment">// while</span>
01562 
01563    <span class="comment">// copy workString back to aString</span>
01564    <span class="comment">// then, delete workString</span>
01565    aString = string(workString);
01566     <span class="comment">//delete [] workString;</span>
01567 }  <span class="comment">// end getRidOfTrailingBlanks</span>
01568 
01569 
01570 <span class="comment">// ***********************************************************************</span>
01571 <span class="comment">// int section</span>
01572 <span class="comment">//        functions for checking the goodness of an int String</span>
01573 <span class="comment">//        functions for reading in an int String and computing its value</span>
01574 <span class="comment">// ***********************************************************************</span>
01575 
01576 <span class="comment">// Function:   isGoodInt(const string&amp;)</span>
01577 <span class="comment">// Purpose:    Returns true if aString represents a valid</span>
01578 <span class="comment">//             integer syntax.  The requirements are</span>
01579 <span class="comment">//             that aString has the form:</span>
01580 <span class="comment">// [_]*[sign]D[D]*'\0'</span>
01581 <span class="comment">//             That is, zero or more blanks, an optional</span>
01582 <span class="comment">//             sign, followed by at least one digit,</span>
01583 <span class="comment">//             followed by the string terminator. Because</span>
01584 <span class="comment">//             of the way the String class is implemented,</span>
01585 <span class="comment">//             the final character will be the string</span>
01586 <span class="comment">//             terminator. </span>
01587 <span class="comment">// Pre:        aString has no trailing blanks</span>
01588 <span class="keywordtype">bool</span> XMLTree::isGoodInt(<span class="keyword">const</span> string&amp; aString)
01589 {
01590    <span class="comment">// Local data ...</span>
01591     <span class="keywordtype">int</span> index;         <span class="comment">// index into string</span>
01592 
01593    <span class="comment">// Logic ...</span>
01594    <span class="comment">// Skip over leading blanks until a sign or</span>
01595    <span class="comment">// a digit is encountered.  If the first non-blank</span>
01596    <span class="comment">// is not a sign or a digit, then return false</span>
01597    index = 0;
01598    <span class="keywordflow">while</span> (aString[index] == BLANK)
01599    {
01600       index++;
01601    } 
01602 
01603    <span class="comment">// We are looking at a non-blank character.   If it</span>
01604    <span class="comment">// is neither a sign nor a digit, return false</span>
01605    <span class="keywordflow">if</span> (!isSign(aString[index])   &amp;&amp; !isdigit(aString[index]))
01606    {
01607       <span class="keywordflow">return</span> <span class="keyword">false</span>;
01608    }
01609 
01610    <span class="comment">// If we are looking at a sign, the next character</span>
01611    <span class="comment">// must be a digit.</span>
01612    <span class="keywordflow">if</span> (isSign(aString[index]))
01613    {
01614       <span class="keywordflow">if</span> (!isdigit(aString[index + 1]))
01615       {
01616          <span class="comment">// illegal string</span>
01617          <span class="keywordflow">return</span> <span class="keyword">false</span>;
01618       }
01619    }
01620 
01621    <span class="comment">// aString[index] is a sign or a digit.  If it is a sign,</span>
01622    <span class="comment">// the next character is a digit.  From this point</span>
01623    <span class="comment">// on, until we reach the string terminator, all of the</span>
01624    <span class="comment">// chars must be digits.</span>
01625    index++;
01626    <span class="keywordflow">while</span> (aString[index] != TERMINATOR)
01627    {
01628       <span class="keywordflow">if</span> (!isdigit(aString[index]))
01629       {
01630          <span class="keywordflow">return</span> <span class="keyword">false</span>;
01631       }
01632       index++;
01633    }
01634 
01635    <span class="comment">// This is a legal int string</span>
01636    <span class="keywordflow">return</span> <span class="keyword">true</span>;
01637 }  <span class="comment">// end isGoodInt</span>
01638 
01639 
01640 <span class="comment">// ***********************************************************************</span>
01641 <span class="comment">// Functions for checking the goodness of a double or float String</span>
01642 <span class="comment">//        isGoodDouble   -- syntax is okay</span>
01643 <span class="comment">//        withinDoubleRange -- value is within range</span>
01644 <span class="comment">// ***********************************************************************</span>
01645 
01646 <span class="comment">// Function:   isGoodDouble(const string&amp;)</span>
01647 <span class="comment">// Purpose:    Returns true if aString represents a valid</span>
01648 <span class="comment">//             double syntax.  The requirements are quite</span>
01649 <span class="comment">//             flexible.  A valid string may or may not begin</span>
01650 <span class="comment">//             with a sign (+ or 1).  Beyond the sign, the</span>
01651 <span class="comment">//             rest of the characters must all be digits, </span>
01652 <span class="comment">//             except for one character that must be a </span>
01653 <span class="comment">//             decimal point.</span>
01654 <span class="comment">//</span>
01655 <span class="comment">//             Note that leading 0's are allowed, but no blanks</span>
01656 <span class="comment">//             may occur between the sign and the first digit.</span>
01657 <span class="comment">//             Furthermore,</span>
01658 <span class="comment">//  .2344   -.2344</span>
01659 <span class="comment">//             are both allowed.</span>
01660 <span class="comment">//</span>
01661 <span class="comment">//             Scientific notation is not supported.</span>
01662 <span class="comment">//</span>
01663 <span class="comment">//             If the proposed double string has no decimal point,</span>
01664 <span class="comment">//             the logic of getFloat dictates that this function</span>
01665 <span class="comment">//             will not get called.  (See the pre-conditions.)</span>
01666 <span class="comment">//</span>
01667 <span class="comment">//             Because of the way the String class is implemented, </span>
01668 <span class="comment">//             the final character will be the string terminator. </span>
01669 <span class="comment">// Pre:        aString has at least one decimal point.</span>
01670 <span class="comment">//             aString has no trailing blanks.</span>
01671 <span class="keywordtype">bool</span> XMLTree::isGoodDouble(<span class="keyword">const</span> string&amp; aString)
01672 {
01673    <span class="comment">// Local data ...</span>
01674     <span class="keywordtype">int</span> index;           <span class="comment">// index into string</span>
01675     <span class="keywordtype">bool</span> encounteredDecimalPt = <span class="keyword">false</span>;  <span class="comment">// decimal point not</span>
01676                         <span class="comment">// encountered yet</span>
01677    <span class="comment">// Logic ...</span>
01678    <span class="comment">// First, let's get past the leading blanks</span>
01679     index = 0;
01680    <span class="keywordflow">while</span> (aString[index] == BLANK)
01681    {
01682       index++;
01683    }
01684 
01685    <span class="comment">// We are at the first non-blank char.  If it</span>
01686    <span class="comment">// a sign, skip over it.</span>
01687    <span class="keywordflow">if</span> (isSign(aString[index]))
01688    {
01689       index++;
01690    }
01691 
01692    <span class="comment">// From this point on all characters until the</span>
01693    <span class="comment">// terminator must be a digit, except one, which</span>
01694    <span class="comment">// must be a decimal point.  By the pre-conditions</span>
01695    <span class="comment">// there are no trailing blanks and there is at </span>
01696    <span class="comment">// least one decimal point.</span>
01697    <span class="keywordflow">while</span> (aString[index] != TERMINATOR)
01698    {
01699       <span class="keywordflow">if</span> (aString[index] == DECIMALPOINT)
01700       {
01701          <span class="keywordflow">if</span> (encounteredDecimalPt == <span class="keyword">true</span>)
01702          {
01703             <span class="comment">// this is the second decimal point,</span>
01704             <span class="comment">// so this is not a legal string</span>
01705             <span class="keywordflow">return</span> <span class="keyword">false</span>;
01706          }
01707          <span class="keywordflow">else</span>
01708          {
01709             <span class="comment">// this is the first decimal point</span>
01710             <span class="comment">// that we have encountered</span>
01711             encounteredDecimalPt = <span class="keyword">true</span>;
01712          }
01713       }
01714       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isdigit(aString[index]) &amp;&amp; aString[index] != <span class="charliteral">'e'</span> &amp;&amp; aString[index] != <span class="charliteral">'E'</span> &amp;&amp; !isSign(aString[index]))
01715       {
01716          <span class="comment">// not a legal string</span>
01717          <span class="keywordflow">return</span> <span class="keyword">false</span>;
01718       }
01719       index++;
01720    }
01721 
01722    <span class="comment">// this is a legal string</span>
01723    <span class="keywordflow">return</span> <span class="keyword">true</span>;
01724 }  <span class="comment">// end isGoodDouble</span>
01725 
01726 
01727 <span class="comment">// Function:    stringToDouble(const string&amp;)</span>
01728 <span class="comment">// Purpose:     Returns the value of aString as a double.  By the</span>
01729 <span class="comment">//              pre-conditions, aString represents a valid double</span>
01730 <span class="comment">//              value.</span>
01731 <span class="comment">//           </span>
01732 <span class="comment">//              Since scientific notation is not currently supported,</span>
01733 <span class="comment">//              and since aString has at most MAXSTRING - 1 == 50</span>
01734 <span class="comment">//              digits, and since the limits for exponent values are</span>
01735 <span class="comment">//    DBL_MAX_10_EXP      +308</span>
01736 <span class="comment">//    DBL_MIN_10_EXP      -308</span>
01737 <span class="comment">//              (in Visual C++), aString must represent a legal </span>
01738 <span class="comment">//              double value.  </span>
01739 <span class="comment">//           </span>
01740 <span class="comment">//              Note that the double type can only handle</span>
01741 <span class="comment">//    DBL_DIG_15  == 15</span>
01742 <span class="comment">//              significant digits (in Visual C++), so if the user</span>
01743 <span class="comment">//              enters a number with more significant digits, they</span>
01744 <span class="comment">//              will be dropped (and the user will not be told about</span>
01745 <span class="comment">//              this).</span>
01746 <span class="comment">//</span>
01747 <span class="comment">//              Note that the largest double value that can be</span>
01748 <span class="comment">//              handled is:</span>
01749 <span class="comment">//   999999999999999 followed by 35 O's</span>
01750 <span class="comment">//              or </span>
01751 <span class="comment">//    0.999999999999999 x pow(10.0, 50.0)</span>
01752 <span class="comment">//              which is still well within range of the permissible</span>
01753 <span class="comment">//              values.  The smallest non-zero number (in absolute</span>
01754 <span class="comment">//              value is</span>
01755 <span class="comment">//    0.00000 .... 0000001</span>
01756 <span class="comment">//              that is, 0.1 x pow(10.0, -49.0)</span>
01757 <span class="comment">//              which is still well within range of the permissible</span>
01758 <span class="comment">//              values.  Consequently, this function does not need</span>
01759 <span class="comment">//              to check that aString represents a value that is within</span>
01760 <span class="comment">//              the permissible range.</span>
01761 <span class="comment">//            </span>
01762 <span class="comment">// Pre:         isGoodDouble(aString) == true</span>
01763 <span class="comment">//              aString has no trailing blanks</span>
01764 <span class="keywordtype">double</span> XMLTree::stringToDouble(<span class="keyword">const</span> string&amp; aString)
01765 {
01766    <span class="comment">// Local data ...</span>
01767    <span class="keywordtype">double</span> valueOfString;           <span class="comment">// the value that will get returned</span>
01768    <span class="keywordtype">char</span>   *valString;              <span class="comment">// old style C-string equal to aString</span>
01769 
01770    <span class="comment">// Logic ...</span>
01771    <span class="comment">// Extract the value of aString as a double</span>
01772    <span class="comment">// and return that value.</span>
01773    valString = (<span class="keywordtype">char</span> *)aString.c_str();           <span class="comment">// new dynamic object</span>
01774    valueOfString = strtod(valString, NULL);
01775     <span class="keywordflow">return</span> valueOfString;
01776 }  <span class="comment">// end withinDoubleRange</span>
01777 
01778 <span class="keywordtype">float</span> XMLTree::stringToFloat(<span class="keyword">const</span> string&amp; aString)
01779 {
01780    <span class="comment">// Local data ...</span>
01781    <span class="keywordtype">float</span> valueOfString;           <span class="comment">// the value that will get returned</span>
01782    <span class="keywordtype">char</span>   *valString;              <span class="comment">// old style C-string equal to aString</span>
01783 
01784    <span class="comment">// Logic ...</span>
01785    <span class="comment">// Extract the value of aString as a double</span>
01786    <span class="comment">// and return that value.</span>
01787    valString = (<span class="keywordtype">char</span> *)aString.c_str();           <span class="comment">// new dynamic object</span>
01788    valueOfString = atof(valString);
01789     <span class="keywordflow">return</span> valueOfString;
01790 }  <span class="comment">// end withinDoubleRange</span>
01791 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Dec 13 14:13:48 2007 for reconHRRT by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
