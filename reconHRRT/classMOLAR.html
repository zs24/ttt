<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>reconHRRT: MOLAR class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>MOLAR Class Reference</h1><code>#include &lt;<a class="el" href="MOLAR_8hpp-source.html">MOLAR.hpp</a>&gt;</code>
<p>
<a href="classMOLAR-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a0">dealerPlayer</a> (bool randomFlag, Params &amp;params, <a class="el" href="classEventList.html">EventList</a> &amp;eventList, Status &amp;status)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a1">player</a> (bool randomFlag, Params &amp;params, <a class="el" href="classEventList.html">EventList</a> &amp;eventList, Status &amp;status)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a2">boundaryCheckingFwdProject</a> (<a class="el" href="classImage.html">Image</a> &amp;mu, <a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;QMask, <a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;lambdaMask, Params &amp;params, <a class="el" href="classEventList.html">EventList</a> &amp;eventList, bool exponentiate, bool discardFlag)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a3">boundaryCheckingFwdProjectEventX</a> (<a class="el" href="classImage.html">Image</a> &amp;mu, <a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;QMask, <a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;lambdaMask, <a class="el" href="classEventPacket.html">EventPacket</a> &amp;event, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, Params &amp;params, bool exponentiate)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a4">boundaryCheckingFwdProjectEventY</a> (<a class="el" href="classImage.html">Image</a> &amp;mu, <a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;QMask, <a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;lambdaMask, <a class="el" href="classEventPacket.html">EventPacket</a> &amp;event, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, Params &amp;params, bool exponentiate)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a5">fwdProject</a> (<a class="el" href="classImage.html">Image</a> &amp;mu, Params &amp;params, <a class="el" href="classEventList.html">EventList</a> &amp;eventList, bool exponentiate)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a6">fwdProjectEventX</a> (<a class="el" href="classImage.html">Image</a> &amp;mu, <a class="el" href="classEventPacket.html">EventPacket</a> &amp;event, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, Params &amp;params, float omega[])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a7">fwdProjectSolidAngle</a> (<a class="el" href="classImage.html">Image</a> &amp;lambda, Params &amp;params, <a class="el" href="classEventList.html">EventList</a> &amp;eventList)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a8">fwdProjectEventY</a> (<a class="el" href="classImage.html">Image</a> &amp;mu, <a class="el" href="classEventPacket.html">EventPacket</a> &amp;event, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, Params &amp;params, float omega[])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a9">fwdProjectSolidAngleEventX</a> (<a class="el" href="classEventPacket.html">EventPacket</a> &amp;event, Params &amp;params, float &amp;d0, float omega[])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a10">fwdProjectSolidAngleEventY</a> (<a class="el" href="classEventPacket.html">EventPacket</a> &amp;event, Params &amp;params, float &amp;d0, float omega[])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a11">backProjectQ</a> (<a class="el" href="classImage.html">Image</a> &amp;Q, Params &amp;params, <a class="el" href="classEventList.html">EventList</a> &amp;eventList)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a12">backProjectQEventX</a> (<a class="el" href="classImage.html">Image</a> &amp;Q, <a class="el" href="classEventPacket.html">EventPacket</a> &amp;event, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, Params &amp;params, float omega[])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a13">backProjectQEventY</a> (<a class="el" href="classImage.html">Image</a> &amp;Q, <a class="el" href="classEventPacket.html">EventPacket</a> &amp;event, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, Params &amp;params, float omega[])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a14" doxytag="MOLAR::fwdBackProjectQ" ></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><b>fwdBackProjectQ</b> (<a class="el" href="classImage.html">Image</a> &amp;mu, <a class="el" href="classImage.html">Image</a> &amp;Q, Params &amp;params, <a class="el" href="classEventList.html">EventList</a> &amp;eventList, bool exponentiate)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a15">fwdBackProjectQEventX</a> (<a class="el" href="classImage.html">Image</a> &amp;mu, <a class="el" href="classImage.html">Image</a> &amp;Q, <a class="el" href="classEventPacket.html">EventPacket</a> &amp;event, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, Params &amp;params, bool exponentiate)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a16">fwdBackProjectQEventY</a> (<a class="el" href="classImage.html">Image</a> &amp;mu, <a class="el" href="classImage.html">Image</a> &amp;Q, <a class="el" href="classEventPacket.html">EventPacket</a> &amp;event, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, <a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, Params &amp;params, bool exponentiate)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a17">generateSinoGram</a> (<a class="el" href="classEventList.html">EventList</a> &amp;eventList, Params &amp;params, Status &amp;status)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a18">computeQ</a> (<a class="el" href="classImage.html">Image</a> &amp;Q, Params &amp;params, <a class="el" href="classEventList.html">EventList</a> &amp;eventList)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a19">smoothQ</a> (<a class="el" href="classImage.html">Image</a> &amp;Q, <a class="el" href="classImage.html">Image</a> &amp;mu)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a20">initializeLambda</a> (<a class="el" href="classImage.html">Image</a> &amp;lambda, <a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;Q, Params &amp;params)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a21">calculateMask</a> (<a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;lambdaMask, <a class="el" href="classImage.html">Image</a> &amp;Q, Params &amp;params)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a22">calculateMaskMu</a> (<a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;QMask, <a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;lambdaMask, <a class="el" href="classImage.html">Image</a> &amp;mu, Params &amp;params)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a23" doxytag="MOLAR::dilateMask" ></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><b>dilateMask</b> (string MaskName, <a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;QMask, <a class="el" href="classImage.html">Image</a> &amp;mu, int backoff, Params &amp;params, int fovr)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>House *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a24">getHouse</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classAlgorithm.html">Algorithm</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#a25">getAlgorithm</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a26" doxytag="MOLAR::getScatterCorrection" ></a>
ScatterCorrection *&nbsp;</td><td class="memItemRight" valign=bottom><b>getScatterCorrection</b> ()</td></tr>

<tr><td colspan=2><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classMOLAR.html">MOLAR</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#e0">getInstance</a> ()</td></tr>

<tr><td colspan=2><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o0" doxytag="MOLAR::timeBoundCheck" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><b>timeBoundCheck</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o1" doxytag="MOLAR::timeBoundCheck1" ></a>
clock_t&nbsp;</td><td class="memItemRight" valign=bottom><b>timeBoundCheck1</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o2" doxytag="MOLAR::timeBoundCheck2" ></a>
clock_t&nbsp;</td><td class="memItemRight" valign=bottom><b>timeBoundCheck2</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o3" doxytag="MOLAR::timeBackProjQ1" ></a>
time_t&nbsp;</td><td class="memItemRight" valign=bottom><b>timeBackProjQ1</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o4" doxytag="MOLAR::timeGlobalSum1" ></a>
time_t&nbsp;</td><td class="memItemRight" valign=bottom><b>timeGlobalSum1</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o5" doxytag="MOLAR::timeReadBuildEventList1" ></a>
time_t&nbsp;</td><td class="memItemRight" valign=bottom><b>timeReadBuildEventList1</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o6" doxytag="MOLAR::timeBackProjQ2" ></a>
time_t&nbsp;</td><td class="memItemRight" valign=bottom><b>timeBackProjQ2</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o7" doxytag="MOLAR::timeGlobalSum2" ></a>
time_t&nbsp;</td><td class="memItemRight" valign=bottom><b>timeGlobalSum2</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o8" doxytag="MOLAR::timeReadBuildEventList2" ></a>
time_t&nbsp;</td><td class="memItemRight" valign=bottom><b>timeReadBuildEventList2</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o9" doxytag="MOLAR::timeBackProjQ" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><b>timeBackProjQ</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o10" doxytag="MOLAR::timeGlobalSum" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><b>timeGlobalSum</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o11" doxytag="MOLAR::timeReadBuildEventList" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><b>timeReadBuildEventList</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o12" doxytag="MOLAR::timeFwdProj1" ></a>
time_t&nbsp;</td><td class="memItemRight" valign=bottom><b>timeFwdProj1</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o13" doxytag="MOLAR::timeFwdProj2" ></a>
time_t&nbsp;</td><td class="memItemRight" valign=bottom><b>timeFwdProj2</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o14" doxytag="MOLAR::timeFwdProj" ></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><b>timeFwdProj</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="o15" doxytag="MOLAR::nonZero" ></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><b>nonZero</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMOLAR.html#o16">QAve</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class defines the functions to implement the reconstruction algorithms 
<p>

<p>
Definition at line <a class="el" href="MOLAR_8hpp-source.html#l00019">19</a> of file <a class="el" href="MOLAR_8hpp-source.html">MOLAR.hpp</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a11" doxytag="MOLAR::backProjectQ" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::backProjectQ </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Q</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventList.html">EventList</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>eventList</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs back projection <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Q</em>&nbsp;</td><td>the Q image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>eventlist</em>&nbsp;</td><td>stores the events </td></tr>
    <tr><td valign=top><em>house</em>&nbsp;</td><td>instance of House class, where the events are read in </td></tr>
    <tr><td valign=top><em>status</em>&nbsp;</td><td>instance of Status class </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l01107">1107</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="MOLAR_8cpp-source.html#l01197">backProjectQEventX()</a>, <a class="el" href="MOLAR_8cpp-source.html#l01312">backProjectQEventY()</a>, <a class="el" href="MOLAR_8cpp-source.html#l00728">fwdProjectSolidAngleEventX()</a>, <a class="el" href="MOLAR_8cpp-source.html#l00751">fwdProjectSolidAngleEventY()</a>, <a class="el" href="EventList_8cpp-source.html#l00331">EventList::getFirst()</a>, <a class="el" href="HRRTScannerParams_8hpp-source.html#l00116">HRRTScannerParams::getInstance()</a>, <a class="el" href="Log_8hpp-source.html#l00079">Log::getLog()</a>, <a class="el" href="EventList_8cpp-source.html#l00352">EventList::getNext()</a>, <a class="el" href="EventList_8hpp-source.html#l00166">EventList::getNumEvents()</a>, <a class="el" href="EventList_8cpp-source.html#l00394">EventList::getSentry()</a>, <a class="el" href="Log_8hpp-source.html#l00052">Log::outputMessage()</a>, <a class="el" href="HRRTScannerParams_8hpp-source.html#l00065">HRRTScannerParams::panelSeparation</a>, <a class="el" href="EventPacket_8hpp-source.html#l00021">EventPacket::resModelCodeR</a>, <a class="el" href="EventPacket_8hpp-source.html#l00023">EventPacket::resModelCodeZ</a>, and <a class="el" href="EventPacket_8hpp-source.html#l00045">EventPacket::sinphi</a>.
<p>
Referenced by <a class="el" href="MOLAR_8cpp-source.html#l01424">computeQ()</a>.
<p>
<div class="fragment"><pre>01109 {
01110   <span class="comment">//update status file</span>
01111   Status *status = Status::getStatus();
01112   
01113   
01114   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> &amp;scannerParams=*<a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
01115   <span class="comment">//paramter for solid angle correction</span>
01116   <span class="keywordtype">float</span> d0 = scannerParams.<a class="code" href="classHRRTScannerParams.html#o6">panelSeparation</a>/2.0;
01117   <span class="keywordtype">float</span> omega[params.geometry.nX];<span class="comment">//solid angle correction coefficient</span>
01118   <span class="keywordtype">float</span> dl; <span class="comment">//paramter for solid angle correction and attenuation</span>
01119   <span class="keywordtype">float</span> sumCij; 
01120   <span class="keywordflow">if</span>(status-&gt;proc==0){
01121     stringstream ss;
01122     ss&lt;&lt;<span class="stringliteral">"================================="</span>&lt;&lt;endl;
01123     ss&lt;&lt;<span class="stringliteral">"Back projection Q"</span>&lt;&lt;endl;
01124     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
01125     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(ss.str(),FRAME, 0);
01126     string comm=ss.str();
01127     Status::StatusCode code=Status::RUNNING;
01128     status-&gt;update(comm,code);
01129   }
01130   <span class="comment">//count time</span>
01131   timeBackProjQ1 = time((time_t *) 0);
01132 
01133   <a class="code" href="structResolutionTable.html">ResolutionTable</a> resFunR, resFunU; <span class="comment">//resolution functions</span>
01134   <span class="keywordtype">int</span> subset; <span class="comment">//sub-list of the event list</span>
01135   <a class="code" href="classEventPacket.html">EventPacket</a> event; <span class="comment">//event attracted from the event lise</span>
01136   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); <span class="comment">//prepare for sentry</span>
01137   <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got   </span>
01138   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> averageStart = 0, averageStop=0;
01139 
01140   <span class="keywordflow">for</span>(subset=0;subset&lt;params.algorithm.numSets;subset++){
01141     event = eventList.<a class="code" href="classEventList.html#a3">getFirst</a>(subset);<span class="comment">//Get first event</span>
01142     <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got</span>
01143     <span class="keywordflow">while</span> (!(event==sentry)) {
01144       <span class="comment">//get resolution functions of the event</span>
01145       resFunR = house-&gt;getResFunR(event.<a class="code" href="classEventPacket.html#o6">resModelCodeR</a>);
01146       resFunU = house-&gt;getResFunZ(event.<a class="code" href="classEventPacket.html#o7">resModelCodeZ</a>);
01147       <span class="comment">//forward project</span>
01148       <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o22">sinphi</a> &gt; Constant::SIN45) {<span class="comment">//x is primary direction</span>
01149         <a class="code" href="classMOLAR.html#a9">fwdProjectSolidAngleEventX</a>(event, params,d0,omega);
01150         <a class="code" href="classMOLAR.html#a12">backProjectQEventX</a>(Q,event,resFunR,resFunU,params, omega);
01151 
01152       }
01153       <span class="keywordflow">else</span> { <span class="comment">//y is primary direction</span>
01154         <a class="code" href="classMOLAR.html#a10">fwdProjectSolidAngleEventY</a>(event, params,d0,omega);
01155         <a class="code" href="classMOLAR.html#a13">backProjectQEventY</a>(Q,event,resFunR,resFunU,params,omega);
01156       }
01157       ++countT; <span class="comment">//increase count</span>
01158       <span class="keywordflow">if</span>(status-&gt;proc ==0){ 
01159         <span class="keywordflow">if</span>(countT%50000==0 &amp;&amp; params.frame.verbosity&gt;=2) 
01160           (cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">" events out of "</span>
01161            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
01162            &lt;&lt;<span class="stringliteral">"  back projected"</span>&lt;&lt;endl).flush();
01163       }
01164       event = eventList.<a class="code" href="classEventList.html#a4">getNext</a>(subset);
01165     }
01166     <span class="keywordflow">if</span>(status-&gt;proc ==0)
01167      cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">" events out of "</span>
01168            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
01169            &lt;&lt;<span class="stringliteral">"  back projected"</span>&lt;&lt;endl;
01170   } 
01171 
01172   MPI::COMM_WORLD.Barrier(); <span class="comment">//prepare processes</span>
01173 
01174   timeBackProjQ2 = time((time_t *) 0);
01175   timeBackProjQ = difftime(timeBackProjQ2,timeBackProjQ1);
01176 
01177   timeGlobalSum1 = time((time_t *) 0);
01178   <span class="comment">//global sum of Q slice by slice</span>
01179   countT =0;
01180   Q.<a class="code" href="classImage.html#a14">globalSum</a>(params);
01181   MPI::COMM_WORLD.Barrier(); <span class="comment">//prepare processes</span>
01182 
01183   timeGlobalSum2 = time((time_t *) 0);
01184   timeGlobalSum = difftime(timeGlobalSum2,timeGlobalSum1);
01185 
01186 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="MOLAR::backProjectQEventX" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::backProjectQEventX </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Q</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventPacket.html">EventPacket</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunR</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunU</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>omega</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function back projects an event when x is primary direction <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Q</em>&nbsp;</td><td>the attenuation image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>event</em>&nbsp;</td><td>event to project </td></tr>
    <tr><td valign=top><em>resFunR</em>&nbsp;</td><td>resolution function at R direction </td></tr>
    <tr><td valign=top><em>resFunU</em>&nbsp;</td><td>resolution function at U direction </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l01197">1197</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventPacket_8hpp-source.html#l00029">EventPacket::atten</a>, <a class="el" href="EventPacket_8hpp-source.html#l00043">EventPacket::CijNorm</a>, <a class="el" href="EventPacket_8hpp-source.html#l00048">EventPacket::costheta</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00018">ResolutionTable::downSpread</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstop</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00012">ResolutionTable::kCentralIndex</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00034">ResolutionTable::kernel</a>, <a class="el" href="EventPacket_8hpp-source.html#l00053">EventPacket::livetime_decay</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00031">ResolutionTable::magnification</a>, <a class="el" href="EventPacket_8hpp-source.html#l00027">EventPacket::norm</a>, <a class="el" href="MOLAR_8hpp-source.html#l00358">MOLAR::Table::secondaryStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::secondaryStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::secondaryStep</a>, <a class="el" href="MOLAR_8hpp-source.html#l00358">MOLAR::Table::secondaryStop</a>, <a class="el" href="EventPacket_8hpp-source.html#l00045">EventPacket::sinphi</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00024">ResolutionTable::upSpread</a>, <a class="el" href="Array3D_8hpp-source.html#l00342">Array3D&lt; float &gt;::z</a>, <a class="el" href="MOLAR_8hpp-source.html#l00359">MOLAR::Table::zStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::zStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::zStep</a>, and <a class="el" href="MOLAR_8hpp-source.html#l00359">MOLAR::Table::zStop</a>.
<p>
Referenced by <a class="el" href="MOLAR_8cpp-source.html#l01107">backProjectQ()</a>.
<p>
<div class="fragment"><pre>01201 {
01202   <span class="comment">//spreads in y and z direction</span>
01203   <span class="keywordtype">int</span> downYSpread, upYSpread, downZSpread, upZSpread;
01204   <span class="comment">//loop ints</span>
01205   <span class="keywordtype">int</span> jx, jy, jz;
01206   <span class="comment">//voxel centers</span>
01207   <span class="keywordtype">int</span> jyCentral, jzCentral;
01208   <span class="comment">//deviation from voxel centers</span>
01209   <span class="keywordtype">float</span> dyCentral, dzCentral;
01210   <span class="comment">//table stuct to determine the size of quadrue</span>
01211   Table table;
01212   <span class="comment">//start points and increasments on R and U direction</span>
01213   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
01214   <span class="comment">//indices of resolution functions</span>
01215   <span class="keywordtype">int</span> kIndexR, kIndexU;
01216   <span class="keywordtype">float</span> kIndexUstart;
01217 
01218   <span class="comment">//intermeidate variable</span>
01219   <span class="comment">//float dl, dmid,omega, cijNorm, length;</span>
01220   <span class="keywordtype">float</span> yhat = 0, sumCij = 0;
01221   <span class="comment">//calculate the spreads of the quadraue</span>
01222   <span class="keywordtype">float</span> resFunRTable[params.geometry.nY], 
01223     resFunUTable[params.geometry.nZ];
01224   <span class="keywordtype">float</span> normFct = event.<a class="code" href="classEventPacket.html#o10">atten</a>*event.<a class="code" href="classEventPacket.html#o9">norm</a>*event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>*event.<a class="code" href="classEventPacket.html#o21">CijNorm</a>;
01225 
01226 
01227   downYSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o22">sinphi</a>);
01228   upYSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o22">sinphi</a>);
01229   downZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01230   upZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01231   <span class="comment">//y and z starting points</span>
01232   <span class="keywordtype">float</span> y = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
01233   <span class="keywordtype">float</span> z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
01234 
01235   <span class="keywordflow">for</span>(jx=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jx&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jx++){
01236     <span class="comment">//solid angle correction</span>
01237     <span class="comment">// omega=POW2((d0/(dmid+dl*fabs(jx-event.jmid))));</span>
01238     <span class="comment">//center of the voxel</span>
01239     jyCentral = (<span class="keywordtype">int</span>)(y); <span class="comment">//we have maken sure that floor(y)&gt;0</span>
01240     jzCentral = (<span class="keywordtype">int</span>)(z); <span class="comment">//we have maken sure that floor(z)&gt;0</span>
01241     <span class="comment">//deviations from the center</span>
01242     dyCentral = jyCentral+0.5-y; <span class="comment">//+0.5 to transfer image index </span>
01243                                  <span class="comment">//to image coordinate system</span>
01244     dzCentral = jzCentral+0.5-z;
01245     <span class="comment">//calculate the size of the quad</span>
01246     table.secondaryStart = jyCentral - downYSpread;
01247     <span class="keywordflow">if</span>(table.secondaryStart&lt;0){
01248       table.secondaryStart=0;
01249     }
01250     table.secondaryStop = jyCentral + upYSpread;
01251     <span class="keywordflow">if</span>(table.secondaryStop&gt;params.geometry.nY-1){
01252       table.secondaryStop=params.geometry.nY-1;
01253       <span class="comment">//       cout&lt;&lt;"table.secondaryStop greater nY "&lt;&lt;endl;</span>
01254     }
01255     table.zStart = jzCentral - downZSpread;
01256     <span class="keywordflow">if</span>(table.zStart&lt;0){
01257       table.zStart=0;
01258       <span class="comment">//       cout&lt;&lt;"table.zStart less than 0 in X"&lt;&lt;endl;</span>
01259     }
01260     table.zStop = jzCentral + upZSpread;
01261     <span class="keywordflow">if</span>(table.zStop &gt; params.geometry.nZ-1){
01262       table.zStop= params.geometry.nZ-1;
01263       <span class="comment">//       cout&lt;&lt;"table.zStop greater than nZ in X"&lt;&lt;endl;</span>
01264     }
01265     <span class="comment">//start points</span>
01266     dRStart = (dyCentral - downYSpread) * event.<a class="code" href="classEventPacket.html#o22">sinphi</a>;
01267     dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
01268     dR=dRStart;
01269     <span class="keywordflow">for</span>(jy=table.secondaryStart; jy&lt;=table.secondaryStop; jy++){
01270       <span class="comment">//get kernel index and value at R direction</span>
01271       kIndexR = resFunR.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01272         (<span class="keywordtype">int</span>)floor(dR*resFunR.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01273       resFunRTable[jy]=resFunR.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexR];
01274       dR += event.<a class="code" href="classEventPacket.html#o22">sinphi</a>;
01275       <span class="comment">//end test</span>
01276     }
01277     dU = dUStart;
01278     <span class="keywordflow">for</span>(jz=table.zStart; jz &lt;=table.zStop; jz++){ 
01279 
01280       <span class="comment">//get kernel index and value at U direction</span>
01281       kIndexU = resFunU.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01282         (<span class="keywordtype">int</span>)floor(dU * resFunU.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01283       resFunUTable[jz]=resFunU.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexU];
01284       <span class="comment">// next value is not strictly costheta if voxels are not cubic</span>
01285       dU += event.<a class="code" href="classEventPacket.html#o24">costheta</a>;                     
01286 
01287     }
01288     <span class="keywordflow">for</span>(jy=table.secondaryStart; jy&lt;=table.secondaryStop; jy++){    
01289       <span class="keywordflow">for</span>(jz=table.zStart; jz &lt;=table.zStop; jz++){ 
01290         <span class="comment">//foward projection</span>
01291         <span class="keywordtype">float</span> kernel = resFunRTable[jy]*resFunUTable[jz];
01292         
01293         Q.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx] += kernel*normFct*omega[jx];
01294 
01295       }
01296     }
01297     y += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>; 
01298     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
01299   }
01300 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="MOLAR::backProjectQEventY" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::backProjectQEventY </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Q</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventPacket.html">EventPacket</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunR</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunU</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>omega</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function directly back projects an event when y is primary direction <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Q</em>&nbsp;</td><td>the Q image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>event</em>&nbsp;</td><td>event to project </td></tr>
    <tr><td valign=top><em>resFunR</em>&nbsp;</td><td>resolution function at R direction </td></tr>
    <tr><td valign=top><em>resFunU</em>&nbsp;</td><td>resolution function at U direction </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l01312">1312</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventPacket_8hpp-source.html#l00029">EventPacket::atten</a>, <a class="el" href="EventPacket_8hpp-source.html#l00043">EventPacket::CijNorm</a>, <a class="el" href="EventPacket_8hpp-source.html#l00045">EventPacket::cosphi</a>, <a class="el" href="EventPacket_8hpp-source.html#l00048">EventPacket::costheta</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00018">ResolutionTable::downSpread</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstop</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00012">ResolutionTable::kCentralIndex</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00034">ResolutionTable::kernel</a>, <a class="el" href="EventPacket_8hpp-source.html#l00053">EventPacket::livetime_decay</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00031">ResolutionTable::magnification</a>, <a class="el" href="EventPacket_8hpp-source.html#l00027">EventPacket::norm</a>, <a class="el" href="MOLAR_8hpp-source.html#l00358">MOLAR::Table::secondaryStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::secondaryStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::secondaryStep</a>, <a class="el" href="MOLAR_8hpp-source.html#l00358">MOLAR::Table::secondaryStop</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00024">ResolutionTable::upSpread</a>, <a class="el" href="MOLAR_8hpp-source.html#l00359">MOLAR::Table::zStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::zStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::zStep</a>, and <a class="el" href="MOLAR_8hpp-source.html#l00359">MOLAR::Table::zStop</a>.
<p>
Referenced by <a class="el" href="MOLAR_8cpp-source.html#l01107">backProjectQ()</a>.
<p>
<div class="fragment"><pre>01316 {
01317   <span class="comment">//spreads in x and z direction</span>
01318   <span class="keywordtype">int</span> downXSpread, upXSpread, downZSpread, upZSpread;
01319   <span class="comment">//intermidiate variables</span>
01320   <span class="comment">//float dl, dmid,omega,cijNorm, length;</span>
01321   <span class="comment">//yhat and CijNomr</span>
01322   <span class="keywordtype">float</span> yhat = 0, sumCij = 0;
01323   <span class="comment">//loop variables</span>
01324   <span class="keywordtype">int</span>  jx, jy, jz;
01325   <span class="comment">//x z coordinates</span>
01326   <span class="keywordtype">float</span> x,z;
01327   <span class="comment">//voxel centers</span>
01328   <span class="keywordtype">int</span> jxCentral, jzCentral;
01329   <span class="comment">//voxel diviations</span>
01330   <span class="keywordtype">float</span>  dxCentral, dzCentral;
01331   Table table;
01332   <span class="comment">//starting points</span>
01333   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
01334   <span class="comment">//index of kernel</span>
01335   <span class="keywordtype">int</span> kIndexR, kIndexU;
01336   <span class="comment">//resolution function kernel table</span>
01337   <span class="keywordtype">float</span> resFunRTable[params.geometry.nX],
01338     resFunUTable[params.geometry.nZ]; 
01339 
01340   <span class="keywordtype">float</span> normFct = event.<a class="code" href="classEventPacket.html#o10">atten</a>*event.<a class="code" href="classEventPacket.html#o9">norm</a>*event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>*event.<a class="code" href="classEventPacket.html#o21">CijNorm</a>;
01341 
01342   downXSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o23">cosphi</a>);
01343   upXSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o23">cosphi</a>);
01344   downZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01345   upZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01346 
01347   x = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
01348   z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
01349   <span class="keywordflow">for</span>(jy=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jy&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jy++){
01350     <span class="comment">//solid angle correction</span>
01351     <span class="comment">// omega=POW2((d0/(dmid+dl*fabs(jy-event.jmid))));</span>
01352 
01353     jxCentral = (<span class="keywordtype">int</span>)(x);<span class="comment">//we have maken sure that floor(x)&gt;=0</span>
01354     jzCentral = (<span class="keywordtype">int</span>)(z);<span class="comment">//we have maken sure that floor(z)&gt;=0</span>
01355     dxCentral = jxCentral+0.5-x; <span class="comment">//+0.5 to transfer image index to </span>
01356     <span class="comment">//image coordinate system</span>
01357     dzCentral = jzCentral+0.5-z;
01358     table.secondaryStart = jxCentral - downXSpread;<span class="comment">//int</span>
01359     <span class="keywordflow">if</span>(table.secondaryStart&lt;0) {
01360       table.secondaryStart=0;
01361       <span class="comment">// cout&lt;&lt;"table.secondaryStart less than 0 in Y"&lt;&lt;endl;</span>
01362     }
01363     table.secondaryStop = jxCentral + upXSpread;
01364     <span class="keywordflow">if</span>(table.secondaryStop&gt;params.geometry.nX-1){
01365       table.secondaryStop=params.geometry.nX-1;
01366     }
01367     table.zStart = jzCentral - downZSpread;
01368     <span class="keywordflow">if</span>(table.zStart&lt;0){
01369       table.zStart=0;
01370       <span class="comment">//       cout&lt;&lt;"table.zStart less than 0 in Y"&lt;&lt;endl;</span>
01371     }
01372     table.zStop = jzCentral + upZSpread;
01373     <span class="keywordflow">if</span>(table.zStop &gt; params.geometry.nZ-1){
01374       table.zStop=params.geometry.nZ-1;
01375       <span class="comment">//       cout&lt;&lt;"talbe.zStop greater than nZ in Y"&lt;&lt;endl;</span>
01376     }
01377     dRStart = (dxCentral - downXSpread) * event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
01378     dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
01379 
01380     <span class="comment">//calculate the kernel of resolution function R</span>
01381     dR=dRStart;
01382     <span class="keywordflow">for</span>(jx=table.secondaryStart; jx&lt;=table.secondaryStop; jx++){
01383       kIndexR = resFunR.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01384         (<span class="keywordtype">int</span>)floor(dR*resFunR.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01385       resFunRTable[jx]=resFunR.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexR];
01386       dR += event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
01387     }
01388     <span class="comment">//calculate the kernel of resolution function U</span>
01389     dU = dUStart;
01390     <span class="keywordflow">for</span>(jz=table.zStart; jz &lt;= table.zStop; jz++) {
01391       kIndexU = resFunU.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01392         (<span class="keywordtype">int</span>)floor(dU * resFunU.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01393       resFunUTable[jz]=resFunU.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexU];
01394       <span class="comment">// next value is not strictly costheta if voxels are not cubic</span>
01395       dU += event.<a class="code" href="classEventPacket.html#o24">costheta</a>;  
01396     }
01397     <span class="keywordflow">for</span>(jx=table.secondaryStart; jx&lt;=table.secondaryStop; jx++){  
01398       <span class="keywordflow">for</span>(jz=table.zStart; jz &lt;= table.zStop; jz++) {    
01399    
01400         <span class="keywordtype">float</span> kernel =  resFunRTable[jx]*resFunUTable[jz];
01401         
01402         Q.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx] +=kernel* normFct*omega[jy];
01403       }
01404     }
01405     <span class="comment">//next </span>
01406     x += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
01407     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
01408   }
01409 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="MOLAR::boundaryCheckingFwdProject" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::boundaryCheckingFwdProject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>QMask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lambdaMask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventList.html">EventList</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>eventList</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>exponentiate</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>discardFlag</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs boundary checking forward-projection <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>mu</em>&nbsp;</td><td>the attenuation image </td></tr>
    <tr><td valign=top><em>QMask</em>&nbsp;</td><td>contols boundaries </td></tr>
    <tr><td valign=top><em>lambdaMask</em>&nbsp;</td><td>contols boundaries </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>eventlist</em>&nbsp;</td><td>stores the events </td></tr>
    <tr><td valign=top><em>house</em>&nbsp;</td><td>instance of House class, where the events are read in </td></tr>
    <tr><td valign=top><em>status</em>&nbsp;</td><td>instance of Status class </td></tr>
    <tr><td valign=top><em>exponentiate</em>&nbsp;</td><td>flag to determine if do exponentiate or not </td></tr>
    <tr><td valign=top><em>discardFlag</em>&nbsp;</td><td>flag to determine if the event to be discarded </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00292">292</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="MOLAR_8cpp-source.html#l00412">boundaryCheckingFwdProjectEventX()</a>, <a class="el" href="MOLAR_8cpp-source.html#l00509">boundaryCheckingFwdProjectEventY()</a>, <a class="el" href="EventList_8cpp-source.html#l00331">EventList::getFirst()</a>, <a class="el" href="Log_8hpp-source.html#l00079">Log::getLog()</a>, <a class="el" href="EventList_8cpp-source.html#l00352">EventList::getNext()</a>, <a class="el" href="EventList_8hpp-source.html#l00166">EventList::getNumEvents()</a>, <a class="el" href="EventList_8cpp-source.html#l00394">EventList::getSentry()</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstop</a>, <a class="el" href="FrameInfo_8hpp-source.html#l00047">FrameInfo::nAcceptObject</a>, <a class="el" href="FrameInfo_8hpp-source.html#l00048">FrameInfo::nRejectObject</a>, <a class="el" href="Log_8hpp-source.html#l00052">Log::outputMessage()</a>, <a class="el" href="EventList_8cpp-source.html#l00278">EventList::remove()</a>, <a class="el" href="EventList_8cpp-source.html#l00320">EventList::replace()</a>, <a class="el" href="EventPacket_8hpp-source.html#l00021">EventPacket::resModelCodeR</a>, <a class="el" href="EventPacket_8hpp-source.html#l00023">EventPacket::resModelCodeZ</a>, <a class="el" href="EventPacket_8hpp-source.html#l00045">EventPacket::sinphi</a>, and <a class="el" href="FrameInfo_8cpp-source.html#l00010">FrameInfo::writeFrameInfo()</a>.
<p>
<div class="fragment"><pre>00298 {
00299   <span class="comment">//update status file</span>
00300   Status *status = Status::getStatus();
00301 
00302   <span class="keywordflow">if</span>(status-&gt;proc==0){
00303     stringstream ss;
00304     ss&lt;&lt;<span class="stringliteral">"================================="</span>&lt;&lt;endl;
00305     ss&lt;&lt;<span class="stringliteral">"BoundaryChecking Forward projection"</span>&lt;&lt;endl;
00306     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00307     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(ss.str(),FRAME, 0);
00308     string comm=ss.str();
00309     Status::StatusCode code=Status::RUNNING;
00310     status-&gt;update(comm,code);
00311   }
00312   <span class="keywordtype">int</span> nAcceptObject =0, nRejectObject = 0;
00313   <span class="keywordtype">double</span> nAcceptObjectD =0., nRejectObjectD = 0.;
00314   <span class="keywordtype">double</span> nAcceptObjectGrandD =0., nRejectObjectGrandD = 0.;
00315    
00316   <a class="code" href="structResolutionTable.html">ResolutionTable</a> resFunR, resFunZ; <span class="comment">//resolution functions</span>
00317   <span class="keywordtype">bool</span> fwdStatus;       
00318   <span class="comment">//fwd status which returns from fwdProjectionEventX or </span>
00319   <span class="comment">// fwdProjectionEventY</span>
00320   <span class="keywordtype">int</span> subset; <span class="comment">//sub-list of the event list</span>
00321   <a class="code" href="classEventPacket.html">EventPacket</a> event; <span class="comment">//event attracted from the event lise</span>
00322   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); <span class="comment">//prepare for sentry</span>
00323   
00324   timeBoundCheck1=clock();
00325   <span class="keywordflow">for</span>(subset=0;subset&lt;params.algorithm.numSets;subset++){
00326     event = eventList.<a class="code" href="classEventList.html#a3">getFirst</a>(subset);<span class="comment">//Get first event</span>
00327     <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got</span>
00328     <span class="keywordflow">while</span> (!(event==sentry)){
00329       <span class="comment">//get resolution functions of the event</span>
00330       resFunR = house-&gt;getResFunR(event.<a class="code" href="classEventPacket.html#o6">resModelCodeR</a>);
00331       resFunZ = house-&gt;getResFunZ(event.<a class="code" href="classEventPacket.html#o7">resModelCodeZ</a>);
00332       <span class="comment">//forward project</span>
00333       <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o22">sinphi</a> &gt; Constant::SIN45) <span class="comment">//x is primary direction</span>
00334         fwdStatus = <a class="code" href="classMOLAR.html#a3">boundaryCheckingFwdProjectEventX</a>(mu,QMask, lambdaMask, event,resFunR,
00335                                                      resFunZ,
00336                                                      params,
00337                                                      exponentiate);
00338       <span class="keywordflow">else</span>  <span class="comment">//y is primary direction</span>
00339         fwdStatus = <a class="code" href="classMOLAR.html#a4">boundaryCheckingFwdProjectEventY</a>(mu,QMask, lambdaMask, event,resFunR,
00340                                                      resFunZ,
00341                                                      params,
00342                                                      exponentiate);
00343       <span class="keywordflow">if</span>(fwdStatus == <span class="keyword">false</span>){
00344         nRejectObject ++;
00345         <span class="keywordflow">if</span>(discardFlag)
00346           eventList.<a class="code" href="classEventList.html#a5">remove</a>(subset);
00347         <span class="keywordflow">else</span>{
00348           event.<a class="code" href="classEventPacket.html#o1">jstop</a> = event.<a class="code" href="classEventPacket.html#o0">jstart</a> - 1 ;
00349           eventList.<a class="code" href="classEventList.html#a7">replace</a>(subset, event);
00350         }
00351       }         
00352       <span class="keywordflow">else</span>{
00353         nAcceptObject++;
00354         eventList.<a class="code" href="classEventList.html#a7">replace</a>(subset,event);
00355       }
00356     
00357       <span class="comment">//get next event</span>
00358       event = eventList.<a class="code" href="classEventList.html#a4">getNext</a>(subset);
00359       ++countT; <span class="comment">//increase count</span>
00360       <span class="keywordflow">if</span>(status-&gt;proc ==0 &amp;&amp; params.frame.verbosity&gt;=2){ 
00361         <span class="keywordflow">if</span>(countT%50000==0) 
00362           (cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">" events out  of "</span> 
00363            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00364            &lt;&lt;<span class="stringliteral">" events (subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">") checked boundary. nAcceptObject="</span>&lt;&lt;nAcceptObject&lt;&lt;
00365            <span class="stringliteral">" nRejectObject="</span>&lt;&lt;nRejectObject&lt;&lt;endl).flush();
00366         <span class="comment">//      if(event==sentry) (cout&lt;&lt;countT&lt;&lt;endl).flush();</span>
00367       } <span class="comment">//end if</span>
00368       
00369       
00370     }<span class="comment">//while loop</span>
00371     <span class="keywordflow">if</span>(status-&gt;proc ==0 &amp;&amp; params.frame.verbosity&gt;=2){ 
00372      cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">" events out of "</span> 
00373            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00374            &lt;&lt;<span class="stringliteral">" events (subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">") checked boundary. nAcceptObject="</span>&lt;&lt;nAcceptObject&lt;&lt;
00375            <span class="stringliteral">" nRejectObject="</span>&lt;&lt;nRejectObject&lt;&lt;endl;
00376     }
00377   } <span class="comment">//for loop-subset</span>
00378   timeBoundCheck2=clock();
00379   timeBoundCheck= (timeBoundCheck2-timeBoundCheck1)/
00380     (CLOCKS_PER_SEC / (<span class="keywordtype">double</span>) 1000.0);
00381 
00382   <span class="comment">// double precision float version</span>
00383   nAcceptObjectD=nAcceptObject;
00384   nRejectObjectD=nRejectObject;
00385   MPI::COMM_WORLD.Allreduce(&amp;nAcceptObjectD, &amp;nAcceptObjectGrandD,1,MPI::DOUBLE,MPI::SUM);
00386 
00387   MPI::COMM_WORLD.Allreduce(&amp;nRejectObjectD, &amp;nRejectObjectGrandD,1,MPI::DOUBLE,MPI::SUM); 
00388   <a class="code" href="classFrameInfo.html">FrameInfo</a> * fi = FrameInfo::getInstance();
00389   fi-&gt;<a class="code" href="classFrameInfo.html#o7">nAcceptObject</a> = nAcceptObjectGrandD;
00390   fi-&gt;<a class="code" href="classFrameInfo.html#o8">nRejectObject</a> = nRejectObjectGrandD;
00391 
00392   <span class="comment">//MPI::COMM_WORLD.Allreduce(&amp;nAcceptObject, &amp;(fi-&gt;nAcceptObject),1,MPI::LONG,MPI::SUM);</span>
00393 
00394   <span class="comment">//MPI::COMM_WORLD.Allreduce(&amp;nRejectObject, &amp;(fi-&gt;nRejectObject),1,MPI::LONG,MPI::SUM); </span>
00395   <span class="keywordflow">if</span>(status-&gt;proc ==0)
00396     fi-&gt;<a class="code" href="classFrameInfo.html#a0">writeFrameInfo</a>();
00397 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="MOLAR::boundaryCheckingFwdProjectEventX" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool MOLAR::boundaryCheckingFwdProjectEventX </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>QMask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lambdaMask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventPacket.html">EventPacket</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunR</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunU</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>exponentiate</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs boundary checking forward project of an event when x is primary direction <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>mu</em>&nbsp;</td><td>the attenuation image </td></tr>
    <tr><td valign=top><em>QMask</em>&nbsp;</td><td>contols boundaries </td></tr>
    <tr><td valign=top><em>lambdaMask</em>&nbsp;</td><td>contols boundaries </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>event</em>&nbsp;</td><td>event to project </td></tr>
    <tr><td valign=top><em>resFunR</em>&nbsp;</td><td>resolution function at R direction </td></tr>
    <tr><td valign=top><em>resFunU</em>&nbsp;</td><td>resolution function at U direction </td></tr>
    <tr><td valign=top><em>exponentiate</em>&nbsp;</td><td>flag to determine if do exponentiate or not </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>false if fwd projection is less than a threshold, true otherwise </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00412">412</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstop</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::secondaryStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::secondaryStep</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::zStart</a>, and <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::zStep</a>.
<p>
Referenced by <a class="el" href="MOLAR_8cpp-source.html#l00292">boundaryCheckingFwdProject()</a>.
<p>
<div class="fragment"><pre>00419 {
00420   <span class="comment">//int boundaryBackOff[0] = params.algorithm.boundaryBackOff[0];</span>
00421   <span class="comment">//intersection with phantom on primary direction</span>
00422   <span class="keywordtype">int</span> jStartOut=event.<a class="code" href="classEventPacket.html#o1">jstop</a>,jStopOut=event.<a class="code" href="classEventPacket.html#o0">jstart</a>;
00423   <span class="comment">//loop ints</span>
00424   <span class="keywordtype">int</span> jx, jy, jz;
00425   <span class="comment">//voxel centers</span>
00426   <span class="keywordtype">int</span> jyCentral, jzCentral;
00427   <span class="comment">//deviation from voxel centers</span>
00428   <span class="keywordtype">float</span> dyCentral, dzCentral;
00429   <span class="comment">//start points and increasments on R and U direction</span>
00430   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
00431   <span class="comment">//indices of resolution functions</span>
00432   <span class="keywordtype">int</span> kIndexR, kIndexU;
00433         
00434   <span class="keywordtype">int</span> jStartSave = event.<a class="code" href="classEventPacket.html#o0">jstart</a>, jStopSave = event.<a class="code" href="classEventPacket.html#o1">jstop</a>;
00435   <span class="comment">//intermeidate variable</span>
00436   <span class="comment">//float partial_yhat=0, yhat =0;</span>
00437   <span class="comment">//y and z starting points</span>
00438   <span class="comment">//float y = event.secondaryStart&lt;0?0:event.secondaryStart;</span>
00439   <span class="comment">//float z = event.zStart&lt;0?0:event.zStart;</span>
00440   <span class="keywordtype">float</span> y = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
00441   <span class="keywordtype">float</span> z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
00442 
00443   <span class="comment">//perform forward projection</span>
00444   <span class="keywordtype">int</span> discardit = 1;
00445   <span class="keywordflow">for</span>(jx=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jx&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jx++){
00446     <span class="comment">//center of the voxel</span>
00447     jyCentral = (<span class="keywordtype">int</span>)floor(y);
00448     jzCentral = (<span class="keywordtype">int</span>) floor(z);
00449 
00450     <span class="comment">//assign jy and jz</span>
00451     jy = jyCentral;
00452     jz = jzCentral;
00453 
00454     <span class="comment">//get kernel indices</span>
00455     <span class="comment">//kIndexR = resFunR.kCentralIndex;</span>
00456     <span class="comment">//kIndexU = resFunU.kCentralIndex;</span>
00457     <span class="comment">//foward projection</span>
00458     <span class="comment">//partial_yhat = resFunR.kernel[kIndexR]*resFunU.kernel[kIndexU]* </span>
00459     <span class="comment">//  mu(jx,jy,jz);</span>
00460     <span class="comment">//partial_yhat = mu(jx,jy,jz);</span>
00461     <span class="comment">// old way - use attenuation image directly - now use QMask image</span>
00462     <span class="comment">//if (partial_yhat &gt; params.attenuation.threshold){</span>
00463     <span class="comment">// Qmask decides whether it is kept, lambdaMask decides the bounds</span>
00464     <span class="keywordflow">if</span> (QMask(jx,jy,jz) &gt; 0){
00465       discardit = 0;
00466     }
00467     <span class="keywordflow">if</span> (lambdaMask(jx,jy,jz) &gt; 0){
00468       jStartOut = min(jStartOut,jx);<span class="comment">//</span>
00469       jStopOut = max( jStopOut,jx);<span class="comment">//</span>
00470     }
00471     y += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>; 
00472     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00473     <span class="comment">//yhat += partial_yhat;</span>
00474   }
00475   <span class="comment">//event.yhat = yhat;</span>
00476  
00477   <span class="keywordflow">if</span>( discardit){
00478     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00479   }
00480   <span class="keywordflow">else</span>{
00481     <span class="comment">// used to expand by 2 boundary BackOff (twice as far as lambda expanded</span>
00482     <span class="comment">//jStartOut = max((jStartOut - 2*boundaryBackOff), jStartSave);</span>
00483     <span class="comment">//jStopOut = min((jStopOut+2*boundaryBackOff), jStopSave);</span>
00484     jStartOut = max(jStartOut , jStartSave);
00485     jStopOut = min(jStopOut, jStopSave);
00486     event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a> +=(jStartOut-event.<a class="code" href="classEventPacket.html#o0">jstart</a>)*
00487       event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
00488     event.<a class="code" href="classEventPacket.html#o3">zStart</a> += (jStartOut-event.<a class="code" href="classEventPacket.html#o0">jstart</a>)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00489     event.<a class="code" href="classEventPacket.html#o0">jstart</a> = jStartOut;
00490     event.<a class="code" href="classEventPacket.html#o1">jstop</a> = jStopOut;
00491     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00492   }
00493 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="MOLAR::boundaryCheckingFwdProjectEventY" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool MOLAR::boundaryCheckingFwdProjectEventY </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>QMask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lambdaMask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventPacket.html">EventPacket</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunR</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunU</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>exponentiate</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs boundary checking forward project of an event when y is primary direction <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>mu</em>&nbsp;</td><td>the attenuation image </td></tr>
    <tr><td valign=top><em>QMask</em>&nbsp;</td><td>contols boundaries </td></tr>
    <tr><td valign=top><em>lambdaMask</em>&nbsp;</td><td>contols boundaries </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>event</em>&nbsp;</td><td>event to project </td></tr>
    <tr><td valign=top><em>resFunR</em>&nbsp;</td><td>resolution function at R direction </td></tr>
    <tr><td valign=top><em>resFunU</em>&nbsp;</td><td>resolution function at U direction </td></tr>
    <tr><td valign=top><em>exponentiate</em>&nbsp;</td><td>flag to determine if do exponentiate or not </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>false if fwd projection is less than a threshold, true otherwise </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00509">509</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstop</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::secondaryStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::secondaryStep</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::zStart</a>, and <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::zStep</a>.
<p>
Referenced by <a class="el" href="MOLAR_8cpp-source.html#l00292">boundaryCheckingFwdProject()</a>.
<p>
<div class="fragment"><pre>00516 {
00517   <span class="comment">//int boundaryBackOff = params.algorithm.boundaryBackOff;</span>
00518 
00519   <span class="comment">//intersection with phantom on primary direction</span>
00520   <span class="keywordtype">int</span> jStartOut=event.<a class="code" href="classEventPacket.html#o1">jstop</a>,jStopOut=event.<a class="code" href="classEventPacket.html#o0">jstart</a>;
00521   <span class="comment">//loop ints</span>
00522   <span class="keywordtype">int</span> jx, jy, jz;
00523   <span class="comment">//voxel centers</span>
00524   <span class="keywordtype">int</span> jxCentral, jzCentral;
00525   <span class="comment">//deviation from voxel centers</span>
00526   <span class="keywordtype">float</span> dxCentral, dzCentral;
00527   <span class="comment">//start points and increasments on R and U direction</span>
00528   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
00529   <span class="comment">//indices of resolution functions</span>
00530   <span class="keywordtype">int</span> kIndexR, kIndexU;
00531   <span class="comment">//x and z coordinates</span>
00532   <span class="keywordtype">float</span> x, z;
00533   <span class="comment">//intermeidate variable</span>
00534   <span class="comment">//float partial_yhat=0, yhat = 0;</span>
00535   <span class="comment">//save the valud of event.jstart and event.jstop</span>
00536   <span class="keywordtype">int</span> jStartSave = event.<a class="code" href="classEventPacket.html#o0">jstart</a>, jStopSave = event.<a class="code" href="classEventPacket.html#o1">jstop</a>;
00537 
00538   <span class="comment">//get x and z</span>
00539   x = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
00540   z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
00541   <span class="keywordtype">int</span> discardit = 1;
00542   <span class="keywordflow">for</span>(jy=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jy&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jy++){
00543     <span class="comment">//center of the voxel</span>
00544     jxCentral = (<span class="keywordtype">int</span>)floor(x);
00545     jzCentral = (<span class="keywordtype">int</span>)floor(z);
00546 
00547     <span class="comment">//assign jx and jz</span>
00548     jx=jxCentral;
00549     jz=jzCentral;
00550 
00551     <span class="comment">//get indices of resolution functions</span>
00552     <span class="comment">//kIndexR = resFunR.kCentralIndex;</span>
00553     <span class="comment">//kIndexU = resFunU.kCentralIndex;</span>
00554 
00555     <span class="comment">//partial_yhat = resFunR.kernel[kIndexR]*resFunU.kernel[kIndexU]* </span>
00556     <span class="comment">//  mu(jx,jy,jz);</span>
00557     <span class="comment">//partial_yhat = mu(jx,jy,jz);</span>
00558     <span class="comment">//boundary checking</span>
00559     <span class="comment">// old way - use attenuation image directly - now use QMask image</span>
00560     <span class="comment">//if (partial_yhat &gt; params.attenuation.threshold)</span>
00561     <span class="comment">// Qmask decides whether it is kept, lambdaMask decides the bounds</span>
00562     <span class="keywordflow">if</span> (QMask(jx,jy,jz) &gt; 0)
00563       {
00564       discardit = 0;
00565       } 
00566     <span class="keywordflow">if</span> (lambdaMask(jx,jy,jz) &gt; 0)
00567       {
00568         jStartOut = min( jStartOut,jy);
00569         jStopOut = max( jStopOut,jy);
00570       } 
00571     x += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
00572     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00573     <span class="comment">//yhat += partial_yhat;</span>
00574       
00575   }
00576   <span class="comment">//event.yhat = yhat;</span>
00577 
00578   <span class="comment">//renew boundary</span>
00579   <span class="keywordflow">if</span>( discardit){
00580     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00581   }
00582   <span class="keywordflow">else</span>
00583     {
00584       <span class="comment">// used to expand by 2 boundary BackOff (twice as far as lambda expanded</span>
00585       <span class="comment">//jStartOut = max((jStartOut - 2*boundaryBackOff), jStartSave);</span>
00586       <span class="comment">//jStopOut = min((jStopOut+2*boundaryBackOff), jStopSave);</span>
00587       jStartOut = max(jStartOut , jStartSave);
00588       jStopOut = min(jStopOut, jStopSave);
00589       event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a> +=(jStartOut-event.<a class="code" href="classEventPacket.html#o0">jstart</a>)*
00590         event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
00591       event.<a class="code" href="classEventPacket.html#o3">zStart</a> += (jStartOut-event.<a class="code" href="classEventPacket.html#o0">jstart</a>)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00592       event.<a class="code" href="classEventPacket.html#o0">jstart</a> = jStartOut;
00593       event.<a class="code" href="classEventPacket.html#o1">jstop</a> = jStopOut;
00594       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00595     }
00596 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="MOLAR::calculateMask" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::calculateMask </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lambdaMask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Q</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function calculate lambdamask image according to Q image It is used in the case of no attenuation image There are two thresholds for the mask One threshold is in a slice, if the value of Q in a slice is less than the threshold, the mask will be set to 0, otherwise 1. The value of the threshold is set to 0.3*Average value of Q of the slice The other threshold is among slices, if the average value of Q in a slice is less than the threshold, the slice of the mask is set 0. The value of this threshold is set to 0.02 of the average value of Q <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>mask</em>&nbsp;</td><td>the mask image </td></tr>
    <tr><td valign=top><em>Q</em>&nbsp;</td><td>the Q image </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l01637">1637</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="MOLAR_8hpp-source.html#l00395">QAve</a>.
<p>
<div class="fragment"><pre>01638 {
01639   <a class="code" href="classMOLAR.html#o16">QAve</a> = Q.<a class="code" href="classArray3D.html#a17">average</a>();
01640   <span class="keywordtype">float</span> thresholdInSlice = (params.algorithm.Qthreshold*10&gt;
01641                           Constant:: PERCENTMASKQSLICE )?
01642     Constant:: PERCENTMASKQSLICE : params.algorithm.Qthreshold;
01643   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0; iz &lt; params.geometry.nZ; iz++){
01644     <span class="keywordtype">float</span> QAveSlice = Q.<a class="code" href="classImage.html#a13">getSliceAverage</a>(iz);
01645     <span class="comment">//the threshold among slices </span>
01646     <span class="keywordflow">if</span>(QAveSlice&lt;=  params.algorithm.Qthreshold*<a class="code" href="classMOLAR.html#o16">QAve</a>){
01647       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; iy&lt;params.geometry.nY; iy++)
01648         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0; ix&lt; params.geometry.nX; ix++){
01649           lambdaMask(ix,iy,iz) = 0;
01650         }
01651     }
01652     <span class="keywordflow">else</span>{
01653       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; iy&lt;params.geometry.nY; iy++)
01654         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0; ix&lt; params.geometry.nX; ix++){
01655           <span class="comment">//the threshold in a slice</span>
01656           <span class="keywordflow">if</span>(Q(ix,iy,iz)&lt;=thresholdInSlice*QAveSlice)
01657             lambdaMask(ix,iy,iz) = 0;
01658           <span class="keywordflow">else</span>
01659             lambdaMask(ix,iy,iz) = 1;
01660         }
01661     }
01662   }
01663 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="MOLAR::calculateMaskMu" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::calculateMaskMu </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>QMask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lambdaMask</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function calculates mask image according to mu image 2004-09-28 rc now do true 3D dilate - saw some funny things with the old 3 1-D dilates. Only do true dilate for voxels with at least one null neighbor 2004-09-23 rc now creates a lambdaMask (dilate mu by boundary BackOff[0]) and a Q <a class="el" href="classMask.html">Mask</a> (dilate mu by boundary BackOff[1]). If no mu image is present, The Q mask is created first based on the FOV parameters and the lambdaMask is created by eroding it 2004-07-26 rc dilate the mu image to define the mask 
<p>
old way int boundaryBackOff2 = params.algorithm.boundaryBackOff[1]; Assume lambdaMask and Qmask has been pre-initialized to 0 build lambdaMask by dilating mu This logic could possibly produce interesting inconsistencies on the edge slices for(int iz = boundaryBackOff; iz &lt; params.geometry.nZ-boundaryBackOff; iz++) for(int iy = boundaryBackOff; iy &lt; params.geometry.nY-boundaryBackOff; iy++) for(int ix =boundaryBackOff; ix &lt; params.geometry.nX-boundaryBackOff; ix++) if(mu(ix,iy,iz)&gt;params.attenuation.threshold) { set all pixels within boundaryBackOff[0] of this voxel to 1 moving just in x, y, and z directions for(int ii = iz-boundaryBackOff;ii &lt;= iz+boundaryBackOff; ii++) lambdaMask(ix,iy,ii) = 1; for(int ii = iy-boundaryBackOff;ii &lt;= iy+boundaryBackOff; ii++) lambdaMask(ix,ii,iz) = 1; for(int ii = ix-boundaryBackOff;ii &lt;= ix+boundaryBackOff; ii++) lambdaMask(ii,iy,iz) = 1; } build QMask by dilating lambdaMask for(int iz = boundaryBackOff2; iz &lt; params.geometry.nZ-boundaryBackOff2; iz++) for(int iy = boundaryBackOff2; iy &lt; params.geometry.nY-boundaryBackOff2; iy++) for(int ix =boundaryBackOff2; ix &lt; params.geometry.nX-boundaryBackOff2; ix++) if(mu(ix,iy,iz)) { set all pixels within boundaryBackOff[1] of this voxel to 1 moving just in x, y, and z directions for(int ii = iz-boundaryBackOff2;ii &lt;= iz+boundaryBackOff2; ii++) QMask(ix,iy,ii) = 1; for(int ii = iy-boundaryBackOff2;ii &lt;= iy+boundaryBackOff2; ii++) QMask(ix,ii,iz) = 1; for(int ii = ix-boundaryBackOff2;ii &lt;= ix+boundaryBackOff2; ii++) QMask(ii,iy,iz) = 1; } add diagnostics if (params.frame.verbosity &gt;= 2) { int numlambdaMask=0; int zminlambda=params.geometry.nZ; int zmaxlambda=0; int zminQ=params.geometry.nZ; int zmaxQ=0; int numQMask=0; for(int iz = 0; iz &lt; params.geometry.nZ; iz++) for(int iy = 0; iy &lt; params.geometry.nY; iy++) for(int ix =0; ix &lt; params.geometry.nX; ix++) { if (QMask(ix,iy,iz)) { numQMask++; if (iz &lt; zminQ) zminQ=iz; if (iz &gt; zmaxQ) zmaxQ=iz; } if (lambdaMask(ix,iy,iz)) { numlambdaMask++; if (iz &lt; zminlambda) zminlambda=iz; if (iz &gt; zmaxlambda) zmaxlambda=iz; } } cout&lt;&lt;"Number of nonzero lambda voxels = "&lt;&lt;numlambdaMask &lt;&lt;" from slice "&lt;&lt;zminlambda&lt;&lt;" to "&lt;&lt;zmaxlambda&lt;&lt;endl; cout&lt;&lt;"Number of nonzero Q voxels = "&lt;&lt;numQMask &lt;&lt;" from slice "&lt;&lt;zminQ&lt;&lt;" to "&lt;&lt;zmaxQ&lt;&lt;endl; } 
<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l01675">1675</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
<div class="fragment"><pre>01677 {
01678   Status *status = Status::getStatus();
01679   <span class="keywordtype">int</span> boundaryBackOff = params.algorithm.boundaryBackOff[0];
01680   <span class="keywordflow">if</span> (params.frame.verbosity &gt;= 2 &amp;&amp; status-&gt;proc == 0) {
01681    cout&lt;&lt;<span class="stringliteral">"Creating lambdaMask with backOff "</span>&lt;&lt;boundaryBackOff&lt;&lt;endl;
01682   }
01683   lambdaMask = 0.0;
01684   <span class="comment">// be sure the mask for lambda is trimmed to be the FOV_r</span>
01685   <span class="comment">// grown for the difference in dilate sizes of the 2 masks</span>
01686   <span class="keywordtype">int</span> fovr = params.geometry.FOV_r + 
01687    2*(params.algorithm.boundaryBackOff[0]-params.algorithm.boundaryBackOff[1]);
01688   dilateMask(<span class="stringliteral">"lambda"</span>,lambdaMask,mu,boundaryBackOff,params,fovr);
01689   
01690   boundaryBackOff = params.algorithm.boundaryBackOff[1];
01691   <span class="keywordflow">if</span> (params.frame.verbosity &gt;= 2 &amp;&amp; status-&gt;proc == 0) {
01692    cout&lt;&lt;<span class="stringliteral">"Creating QMask with backOff "</span>&lt;&lt;boundaryBackOff&lt;&lt;endl;
01693   }
01694   QMask = 0.0;
01695    fovr = params.geometry.FOV_r;
01696   dilateMask(<span class="stringliteral">"Q"</span>,QMask,mu,boundaryBackOff,params,fovr);
01766 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="MOLAR::computeQ" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::computeQ </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Q</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventList.html">EventList</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>eventList</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function calls forward back projection Q to compute Q image and does post processing arithmetic on Q by ultiplied by the total number of possible events in the system (i.e. square the number of crystals) divided by the total number of events in the randomized list <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Q</em>&nbsp;</td><td>the Q image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>eventlist</em>&nbsp;</td><td>stores the events </td></tr>
    <tr><td valign=top><em>house</em>&nbsp;</td><td>instance of House class, where the events are read in </td></tr>
    <tr><td valign=top><em>status</em>&nbsp;</td><td>instance of Status class </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l01424">1424</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="MOLAR_8cpp-source.html#l01107">backProjectQ()</a>.
<p>
<div class="fragment"><pre>01426 {
01427  
01428   <span class="comment">//back projection Q</span>
01429   <a class="code" href="classMOLAR.html#a11">backProjectQ</a>(Q, params, eventList);
01430   <span class="keywordtype">float</span> totalEvents;
01431   Status *status = Status::getStatus();
01432   <span class="keywordflow">if</span>(status-&gt;proc == 0)
01433     totalEvents = house-&gt;getAcceptedEvents() +house-&gt;getRejectedEvents();
01434   MPI::COMM_WORLD.Barrier();
01435   MPI::COMM_WORLD.Bcast(&amp;totalEvents, 1, MPI::FLOAT, 0);
01436 
01437   <span class="comment">//post process of Q</span>
01438   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; iy &lt; params.geometry.nY; iy++)
01439     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0; iz &lt; params.geometry.nZ; iz++)
01440       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix = 0; ix&lt; params.geometry.nX; ix++)
01441         Q(ix,iy,iz) *= ((<span class="keywordtype">float</span>)house-&gt;getTotalPossibleEvents()
01442                         /(totalEvents*params.algorithm.numSets));
01443 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="MOLAR::dealerPlayer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::dealerPlayer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname" nowrap> <em>randomFlag</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventList.html">EventList</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>eventList</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Status &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Function to poll events from house and distribute to each processor Logical processor 0 will poll the house for events and will send that event to the next processor. All processors, including logical processor 0, will have instances of the player listening for events. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>randomFlag</em>&nbsp;</td><td>flag for use randomized event list mode file or true list mode file </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>eventlist</em>&nbsp;</td><td>the eventlist to be appended </td></tr>
    <tr><td valign=top><em>house</em>&nbsp;</td><td>instance of House class, where the events are read in </td></tr>
    <tr><td valign=top><em>status</em>&nbsp;</td><td>instance of Status class </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00076">76</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventList_8cpp-source.html#l00233">EventList::append()</a>, <a class="el" href="EventBuffer_8hpp-source.html#l00078">EventBuffer::appendFixed()</a>, <a class="el" href="EventPacket_8hpp-source.html#l00048">EventPacket::costheta</a>, <a class="el" href="HRRTScannerParams_8hpp-source.html#l00116">HRRTScannerParams::getInstance()</a>, <a class="el" href="EventList_8cpp-source.html#l00394">EventList::getSentry()</a>, <a class="el" href="EventBuffer_8hpp-source.html#l00122">EventBuffer::sendAndClear()</a>, <a class="el" href="HRRTScannerParams_8cpp-source.html#l00146">HRRTScannerParams::write()</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::z1</a>, and <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::z2</a>.
<p>
<div class="fragment"><pre>00079 {
00080   <span class="comment">// The first two declarations are NEW - CAJ</span>
00081   <span class="keyword">const</span> <span class="keywordtype">int</span> EVENT_CYCLE_SIZE=100;  <span class="comment">// Number of processor events between</span>
00082                                    <span class="comment">// load-balancing cycles</span>
00083   <span class="keywordtype">int</span> eventCycleCounter=0;     <span class="comment">// The current counter in the</span>
00084                                <span class="comment">// event-processor cycle.  THe value of</span>
00085                                <span class="comment">// this variable is always between 0</span>
00086                                <span class="comment">// and EVENT_CYCLE_SIZE.</span>
00087   <span class="keywordtype">int</span> proc; <span class="comment">//process number</span>
00088   <span class="keywordtype">int</span> subset;   <span class="comment">//sub-list number </span>
00089   <span class="keywordtype">int</span> numProcs=status.numProcs; <span class="comment">//total number of processes</span>
00090   <a class="code" href="classEventBuffer.html">EventBuffer</a> eventBuffer(numProcs); <span class="comment">//init eventBuffer</span>
00091   <span class="comment">//debug variables </span>
00092   <span class="keywordtype">float</span> z0Min=1e3, z0Max=-1e3, thetaMax=-1e3, thetaMin=1e3;
00093   <span class="keywordtype">int</span> count = 0;
00094   <span class="keywordtype">int</span> countSend = 0;
00095   <span class="keywordflow">if</span>(params.frame.verbosity&gt;=4){
00096     <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> &amp;scanner = *<a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00097     scanner.<a class="code" href="classHRRTScannerParams.html#a2">write</a>(cout);
00098   }
00099     
00100   
00101   <span class="keywordflow">if</span>(randomFlag){ <span class="comment">//using randomized list mode data</span>
00102     cout&lt;&lt;<span class="stringliteral">"Start building randomized event list"</span>&lt;&lt;endl;
00103     house-&gt;prepareRandomizedListData();
00104   }
00105   <span class="keywordflow">else</span>{   <span class="comment">//using true list mode data</span>
00106     cout&lt;&lt;<span class="stringliteral">"Start building true event list"</span>&lt;&lt;endl;
00107     
00108     house-&gt;prepareListData();
00109   }
00110   <span class="comment">//update status file</span>
00111   string comm=<span class="stringliteral">"Starting reading list mode file and building "</span>;
00112   <span class="keywordflow">if</span> (randomFlag) {
00113    comm +=<span class="stringliteral">"randomized"</span>;
00114   } <span class="keywordflow">else</span> {
00115    comm += <span class="stringliteral">"true"</span>;
00116   }
00117   comm+=<span class="stringliteral">" event list"</span>;
00118   Status::StatusCode code = Status::StatusCode(101); 
00119   status.update(comm, code);
00120   
00121   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>();  
00122   <span class="comment">// prepare termination sentry</span>
00123   
00124   <a class="code" href="classEventPacket.html">EventPacket</a> event=house-&gt;getNextEvent();              <span class="comment">//read a event</span>
00125   proc=0;
00126   subset = 0;
00127   <span class="keywordflow">while</span>(!(event==sentry)){
00128     <span class="keywordflow">if</span>(proc==0) {<span class="comment">//process 0</span>
00129       eventList.<a class="code" href="classEventList.html#a2">append</a>(subset,event);
00130       subset++;
00131       subset %= params.algorithm.numSets;
00132     }
00133     <span class="keywordflow">else</span>{
00134       <span class="comment">// The append method appends the next event to the buffer for</span>
00135       <span class="comment">// that node but also sends the buffer when it reaches the max size</span>
00136       <span class="keywordflow">if</span>(eventBuffer.<a class="code" href="classEventBuffer.html#a2">appendFixed</a>(proc,event)){
00137         eventBuffer.<a class="code" href="classEventBuffer.html#a4">sendAndClear</a>(proc);
00138         <span class="keywordflow">if</span>(params.frame.verbosity&gt;=5) {
00139           countSend++;
00140           cout&lt;&lt;countSend&lt;&lt;<span class="stringliteral">" Event buffers Sent to proc "</span>&lt;&lt;proc&lt;&lt;endl;
00141         }
00142       }
00143     }
00144     <span class="comment">// Now we have to find a processor that can accept the next event</span>
00145     <span class="comment">// This is done by incrementing the processor number until a</span>
00146     <span class="comment">// processor is found that has an event load that is at least</span>
00147     <span class="comment">// equal to the event cycle counter</span>
00148     <span class="keywordflow">do</span>{
00149       proc++;
00150       <span class="keywordflow">if</span>(proc == numProcs){
00151         eventCycleCounter++;
00152         eventCycleCounter = eventCycleCounter%EVENT_CYCLE_SIZE;
00153       }
00154       proc = proc%numProcs;
00155     }<span class="keywordflow">while</span>(status.getEventLoad(proc,(<span class="keywordtype">float</span>)EVENT_CYCLE_SIZE) &lt;
00156            (<span class="keywordtype">float</span>)eventCycleCounter);
00157                   
00158     event = house-&gt;getNextEvent();
00159       
00160       
00161     <span class="keywordflow">if</span>(params.frame.verbosity&gt;=5) {
00162       <span class="keywordtype">float</span> z0 = (event.<a class="code" href="classEventPacket.html#o14">z1</a> + event.<a class="code" href="classEventPacket.html#o17">z2</a>)/2;
00163       <span class="keywordtype">float</span> theta = acos(event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
00164       <span class="keywordflow">if</span>(theta&gt;thetaMax) thetaMax=theta;
00165       <span class="keywordflow">if</span>(theta&lt;thetaMin) thetaMin=theta;
00166       <span class="keywordflow">if</span>(z0&gt;z0Max) z0Max=z0;
00167       <span class="keywordflow">if</span>(z0&lt;z0Min) z0Min=z0;
00168       count++ ;
00169       <span class="comment">//   cout&lt;&lt;"Sent event "&lt;&lt;count&lt;&lt;" to process "&lt;&lt;proc&lt;&lt;endl;</span>
00170     }
00171       
00172   }
00173   <span class="comment">// send termination sentry to all nodes</span>
00174   <span class="keywordflow">if</span>(params.frame.verbosity&gt;=5) {
00175     cout&lt;&lt;<span class="stringliteral">"Totally "</span>&lt;&lt;count&lt;&lt;<span class="stringliteral">" Events Got..."</span>&lt;&lt;endl;
00176     cout&lt;&lt;<span class="stringliteral">"z0 max is "</span>&lt;&lt; z0Max &lt;&lt;<span class="stringliteral">" And z0 min is "</span>&lt;&lt;z0Min&lt;&lt;endl;
00177     cout&lt;&lt;<span class="stringliteral">"theta max is "</span>&lt;&lt; thetaMax &lt;&lt;<span class="stringliteral">" And theta min is "</span>
00178         &lt;&lt;thetaMin&lt;&lt;endl;
00179   }
00180   
00181   <span class="keywordflow">if</span>(params.frame.verbosity&gt;=3) {
00182     cout&lt;&lt;<span class="stringliteral">"Sending sentries"</span>&lt;&lt;endl;
00183   }
00184 
00185   <span class="comment">//send a sentry to all proc other than root</span>
00186   <span class="keywordflow">for</span>(proc=1;proc&lt;numProcs;proc++){
00187     eventBuffer.<a class="code" href="classEventBuffer.html#a2">appendFixed</a>(proc,sentry);
00188     eventBuffer.<a class="code" href="classEventBuffer.html#a4">sendAndClear</a>(proc);
00189   }
00190   <span class="comment">//update status file</span>
00191   comm = <span class="stringliteral">"List mode file read and Event list built"</span>;
00192   code = Status::StatusCode(101); 
00193   status.update( comm, code);
00194   cout&lt;&lt;<span class="stringliteral">"=============================================="</span>&lt;&lt;endl;
00195   cout&lt;&lt;<span class="stringliteral">"List mode file read and Event list built"</span>&lt;&lt;endl;
00196   house-&gt;getFrameInfo().init();
00197   house-&gt;getFrameInfo().writeFrameInfo();
00198   <span class="comment">//</span>
00199   
00200 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="MOLAR::fwdBackProjectQEventX" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::fwdBackProjectQEventX </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Q</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventPacket.html">EventPacket</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunR</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunU</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>exponentiate</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs forward-back projection when x is primary direction <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>mu</em>&nbsp;</td><td>the attenuation image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>event</em>&nbsp;</td><td>event to project </td></tr>
    <tr><td valign=top><em>resFunR</em>&nbsp;</td><td>resolution function at R direction </td></tr>
    <tr><td valign=top><em>resFunU</em>&nbsp;</td><td>resolution function at U direction </td></tr>
    <tr><td valign=top><em>exponentiate</em>&nbsp;</td><td>flag to determine if do exponentiate or not </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="MOLAR::fwdBackProjectQEventY" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::fwdBackProjectQEventY </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Q</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventPacket.html">EventPacket</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunR</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunU</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>exponentiate</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs forward-back projection when x is primary direction <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>mu</em>&nbsp;</td><td>the attenuation image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>event</em>&nbsp;</td><td>event to project </td></tr>
    <tr><td valign=top><em>resFunR</em>&nbsp;</td><td>resolution function at R direction </td></tr>
    <tr><td valign=top><em>resFunU</em>&nbsp;</td><td>resolution function at U direction </td></tr>
    <tr><td valign=top><em>exponentiate</em>&nbsp;</td><td>flag to determine if do exponentiate or not </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="MOLAR::fwdProject" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::fwdProject </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventList.html">EventList</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>eventList</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>exponentiate</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs direct forward-projection without attenuation <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>mu</em>&nbsp;</td><td>the attenuation image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>eventlist</em>&nbsp;</td><td>stores the events </td></tr>
    <tr><td valign=top><em>house</em>&nbsp;</td><td>instance of House class, where the events are read in </td></tr>
    <tr><td valign=top><em>status</em>&nbsp;</td><td>instance of Status class </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00612">612</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventPacket_8hpp-source.html#l00029">EventPacket::atten</a>, <a class="el" href="EventPacket_8hpp-source.html#l00043">EventPacket::CijNorm</a>, <a class="el" href="MOLAR_8cpp-source.html#l00874">fwdProjectEventX()</a>, <a class="el" href="MOLAR_8cpp-source.html#l00992">fwdProjectEventY()</a>, <a class="el" href="EventList_8cpp-source.html#l00331">EventList::getFirst()</a>, <a class="el" href="HRRTScannerParams_8hpp-source.html#l00116">HRRTScannerParams::getInstance()</a>, <a class="el" href="Log_8hpp-source.html#l00079">Log::getLog()</a>, <a class="el" href="EventList_8cpp-source.html#l00352">EventList::getNext()</a>, <a class="el" href="EventList_8hpp-source.html#l00166">EventList::getNumEvents()</a>, <a class="el" href="EventList_8cpp-source.html#l00394">EventList::getSentry()</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstop</a>, <a class="el" href="EventPacket_8hpp-source.html#l00053">EventPacket::livetime_decay</a>, <a class="el" href="EventPacket_8hpp-source.html#l00027">EventPacket::norm</a>, <a class="el" href="Log_8hpp-source.html#l00052">Log::outputMessage()</a>, <a class="el" href="HRRTScannerParams_8hpp-source.html#l00065">HRRTScannerParams::panelSeparation</a>, <a class="el" href="EventPacket_8hpp-source.html#l00025">EventPacket::rand</a>, <a class="el" href="EventList_8cpp-source.html#l00320">EventList::replace()</a>, <a class="el" href="EventPacket_8hpp-source.html#l00021">EventPacket::resModelCodeR</a>, <a class="el" href="EventPacket_8hpp-source.html#l00023">EventPacket::resModelCodeZ</a>, <a class="el" href="EventPacket_8hpp-source.html#l00031">EventPacket::scatter</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::secondaryStep</a>, <a class="el" href="EventPacket_8hpp-source.html#l00045">EventPacket::sinphi</a>, <a class="el" href="EventPacket_8hpp-source.html#l00036">EventPacket::yhat</a>, and <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::zStep</a>.
<p>
<div class="fragment"><pre>00614 {
00615   <span class="comment">//update status file</span>
00616   timeFwdProj1 = time((time_t *) 0);
00617 
00618   Status *status = Status::getStatus();
00619   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> &amp;scannerParams=*<a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00620   <span class="comment">//paramter for solid angle correction</span>
00621   <span class="keywordtype">float</span> d0 = scannerParams.<a class="code" href="classHRRTScannerParams.html#o6">panelSeparation</a>/2.0;
00622   <span class="keywordtype">float</span> omega[params.geometry.nX];<span class="comment">//dummy solid angle correction coefficient</span>
00623   <span class="keywordtype">float</span> dl; <span class="comment">//paramter for attenuation</span>
00624   <span class="keywordtype">float</span> sumCij; 
00625 
00626   <span class="keywordflow">if</span>(status-&gt;proc==0){
00627     stringstream ss;
00628     ss&lt;&lt;<span class="stringliteral">"================================="</span>&lt;&lt;endl;
00629     ss&lt;&lt;<span class="stringliteral">"Forward projection"</span>&lt;&lt;endl;
00630     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00631     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(ss.str(),FRAME, 0);
00632     string comm=ss.str();
00633     Status::StatusCode code=Status::RUNNING;
00634     status-&gt;update(comm,code);
00635   }
00636 
00637   <a class="code" href="structResolutionTable.html">ResolutionTable</a> resFunR, resFunU; <span class="comment">//resolution functions</span>
00638   <span class="keywordtype">int</span> subset; <span class="comment">//sub-list of the event list</span>
00639   <a class="code" href="classEventPacket.html">EventPacket</a> event; <span class="comment">//event attracted from the event lise</span>
00640   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); <span class="comment">//prepare for sentry</span>
00641   <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got   </span>
00642   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> averageStart = 0, averageStop=0;
00643   <span class="comment">// create dummy omega vector so no correction is applied</span>
00644   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jx=0; jx&lt;=params.geometry.nX; jx++){
00645     omega[jx]=1.0;
00646   }
00647 
00648   <span class="keywordflow">for</span>(subset=0;subset&lt;params.algorithm.numSets;subset++){
00649     event = eventList.<a class="code" href="classEventList.html#a3">getFirst</a>(subset);<span class="comment">//Get first event</span>
00650     <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got</span>
00651     <span class="keywordflow">while</span> (!(event==sentry)) {
00652       <span class="comment">//get resolution functions of the event</span>
00653       resFunR = house-&gt;getResFunR(event.<a class="code" href="classEventPacket.html#o6">resModelCodeR</a>);
00654       resFunU = house-&gt;getResFunZ(event.<a class="code" href="classEventPacket.html#o7">resModelCodeZ</a>);
00655       <span class="comment">//forward project</span>
00656       <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o22">sinphi</a> &gt; Constant::SIN45) {<span class="comment">//x is primary direction</span>
00657         <span class="comment">// not correct here - dl = fwdProjectSolidAngleEventX(event, params,d0,omega);</span>
00658         dl =sqrt(POW2((params.geometry.dX))+
00659                   POW2((params.geometry.dY*event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>))+
00660                   POW2((params.geometry.dZ)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>));
00661         sumCij = <a class="code" href="classMOLAR.html#a6">fwdProjectEventX</a>(mu,event,resFunR,resFunU,params,omega);
00662 
00663       }
00664       <span class="keywordflow">else</span> { <span class="comment">//y is primary direction</span>
00665         dl =sqrt(POW2((params.geometry.dY))+
00666                   POW2((params.geometry.dX*event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>))+
00667                   POW2((params.geometry.dZ)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>));
00668         <span class="comment">// not correct here - dl = fwdProjectSolidAngleEventY(event, params, d0, omega);</span>
00669         sumCij = <a class="code" href="classMOLAR.html#a8">fwdProjectEventY</a>(mu,event,resFunR,resFunU,params,omega);
00670       }
00671       <span class="keywordflow">if</span>(exponentiate) {
00672         <span class="comment">// Exponentiate the integral of mu*dl</span>
00673         <span class="comment">//  Convert dl to units of mm so that mu will be in units of 1/mm</span>
00674         <span class="keywordtype">float</span> length = dl*(event.<a class="code" href="classEventPacket.html#o1">jstop</a>-event.<a class="code" href="classEventPacket.html#o0">jstart</a>+1);
00675         <span class="keywordflow">if</span>(sumCij != 0)
00676           event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> = length/sumCij;
00677         <span class="keywordflow">else</span>
00678           event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> = 0;
00679         event.<a class="code" href="classEventPacket.html#o10">atten</a> = exp(-event.<a class="code" href="classEventPacket.html#o18">yhat</a>*event.<a class="code" href="classEventPacket.html#o21">CijNorm</a>);
00680       }
00681       <span class="keywordflow">else</span>{
00682         <span class="comment">// case of no attenuation - simply calculate cijNorm    </span>
00683         <span class="keywordtype">float</span> length = dl*(event.<a class="code" href="classEventPacket.html#o1">jstop</a>-event.<a class="code" href="classEventPacket.html#o0">jstart</a>+1);
00684         <span class="keywordflow">if</span>(sumCij != 0)
00685           event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> = length/sumCij;
00686         <span class="keywordflow">else</span>
00687           event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> = 0;
00688           <span class="comment">// What is the purpose of the next statement - </span>
00689         event.<a class="code" href="classEventPacket.html#o18">yhat</a> = event.<a class="code" href="classEventPacket.html#o18">yhat</a> * event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> * event.<a class="code" href="classEventPacket.html#o9">norm</a>*
00690           event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a> * event.<a class="code" href="classEventPacket.html#o10">atten</a> +event.<a class="code" href="classEventPacket.html#o8">rand</a> + event.<a class="code" href="classEventPacket.html#o11">scatter</a>;
00691       }
00692 
00693       eventList.<a class="code" href="classEventList.html#a7">replace</a>(subset,event);
00694       <span class="comment">//get next event</span>
00695       event = eventList.<a class="code" href="classEventList.html#a4">getNext</a>(subset);
00696       ++countT; <span class="comment">//increase count</span>
00697       <span class="keywordflow">if</span>(status-&gt;proc ==0){ 
00698         <span class="keywordflow">if</span>(countT%50000==0 &amp;&amp; params.frame.verbosity&gt;=2) 
00699           (cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">"  events out of "</span>
00700            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00701            &lt;&lt;<span class="stringliteral">" events forward projected"</span>&lt;&lt;endl).flush();
00702         <span class="comment">//if(event==sentry) (cout&lt;&lt;countT&lt;&lt;endl).flush();</span>
00703       } <span class="comment">//end if</span>
00704 
00705     }<span class="comment">//while loop</span>
00706     <span class="comment">//     averageStart=averageStart/countT;</span>
00707     <span class="comment">//     averageStop = averageStop/countT;</span>
00708    <span class="keywordflow">if</span>(status-&gt;proc ==0)
00709     cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">"  events out of "</span>
00710            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00711            &lt;&lt;<span class="stringliteral">" events forward projected"</span>&lt;&lt;endl;
00712   } <span class="comment">//for loop - subset</span>
00713   timeFwdProj2 = time((time_t *) 0);
00714   timeFwdProj = difftime(timeFwdProj2, timeFwdProj1);
00715   <span class="keywordflow">if</span>(status-&gt;proc == 0){
00716     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00717     stringstream msg;
00718     msg &lt;&lt; <span class="stringliteral">"Forward projection takes "</span>&lt;&lt; timeFwdProj&lt;&lt; <span class="stringliteral">" s"</span>&lt;&lt;endl;
00719     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(msg.str(),ATTENUATION, 2);
00720   }
00721  
00722 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="MOLAR::fwdProjectEventX" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float MOLAR::fwdProjectEventX </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventPacket.html">EventPacket</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunR</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunU</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>omega</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function directly forward projects an event when x is primary direction <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>mu</em>&nbsp;</td><td>the attenuation image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>event</em>&nbsp;</td><td>event to project </td></tr>
    <tr><td valign=top><em>resFunR</em>&nbsp;</td><td>resolution function at R direction </td></tr>
    <tr><td valign=top><em>resFunU</em>&nbsp;</td><td>resolution function at U direction </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00874">874</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventPacket_8hpp-source.html#l00048">EventPacket::costheta</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00018">ResolutionTable::downSpread</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstop</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00012">ResolutionTable::kCentralIndex</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00034">ResolutionTable::kernel</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00031">ResolutionTable::magnification</a>, <a class="el" href="MOLAR_8hpp-source.html#l00358">MOLAR::Table::secondaryStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::secondaryStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::secondaryStep</a>, <a class="el" href="MOLAR_8hpp-source.html#l00358">MOLAR::Table::secondaryStop</a>, <a class="el" href="EventPacket_8hpp-source.html#l00045">EventPacket::sinphi</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00024">ResolutionTable::upSpread</a>, <a class="el" href="EventPacket_8hpp-source.html#l00036">EventPacket::yhat</a>, <a class="el" href="Array3D_8hpp-source.html#l00342">Array3D&lt; float &gt;::z</a>, <a class="el" href="MOLAR_8hpp-source.html#l00359">MOLAR::Table::zStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::zStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::zStep</a>, and <a class="el" href="MOLAR_8hpp-source.html#l00359">MOLAR::Table::zStop</a>.
<p>
Referenced by <a class="el" href="MOLAR_8cpp-source.html#l00612">fwdProject()</a>, and <a class="el" href="MOLAR_8cpp-source.html#l00771">fwdProjectSolidAngle()</a>.
<p>
<div class="fragment"><pre>00878 {
00879   <span class="comment">//spreads in y and z direction</span>
00880   <span class="keywordtype">int</span> downYSpread, upYSpread, downZSpread, upZSpread;
00881   <span class="comment">//loop ints</span>
00882   <span class="keywordtype">int</span> jx, jy, jz;
00883   <span class="comment">//voxel centers</span>
00884   <span class="keywordtype">int</span> jyCentral, jzCentral;
00885   <span class="comment">//deviation from voxel centers</span>
00886   <span class="keywordtype">float</span> dyCentral, dzCentral;
00887   <span class="comment">//table stuct to determine the size of quadrue</span>
00888   Table table;
00889   <span class="comment">//start points and increasments on R and U direction</span>
00890   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
00891   <span class="comment">//indices of resolution functions</span>
00892   <span class="keywordtype">int</span> kIndexR, kIndexU;
00893   <span class="keywordtype">float</span> kIndexUstart;
00894 
00895   <span class="comment">//intermeidate variable</span>
00896   <span class="comment">//float dl, dmid,omega, cijNorm, length;</span>
00897   <span class="keywordtype">float</span> yhat = 0, sumCij = 0;
00898   <span class="comment">//calculate the spreads of the quad</span>
00899   <span class="keywordtype">float</span> resFunRTable[params.geometry.nY], 
00900     resFunUTable[params.geometry.nZ];
00901   downYSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o22">sinphi</a>);
00902   upYSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o22">sinphi</a>);
00903   downZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
00904   upZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
00905   <span class="comment">//y and z starting points</span>
00906   <span class="keywordtype">float</span> y = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
00907   <span class="keywordtype">float</span> z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
00908 
00909   <span class="keywordflow">for</span>(jx=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jx&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jx++){
00910     <span class="comment">//solid angle correction</span>
00911     <span class="comment">// omega=POW2((d0/(dmid+dl*fabs(jx-event.jmid))));</span>
00912     <span class="comment">//center of the voxel</span>
00913     jyCentral = (<span class="keywordtype">int</span>)(y); <span class="comment">//we have maken sure that floor(y)&gt;0</span>
00914     jzCentral = (<span class="keywordtype">int</span>)(z); <span class="comment">//we have maken sure that floor(z)&gt;0</span>
00915     <span class="comment">//deviations from the center</span>
00916     dyCentral = jyCentral+0.5-y; <span class="comment">//+0.5 to transfer image index to </span>
00917                                  <span class="comment">//image coordinate system</span>
00918     dzCentral = jzCentral+0.5-z;
00919     <span class="comment">//calculate the size of the quad</span>
00920     table.secondaryStart = jyCentral - downYSpread;
00921     <span class="keywordflow">if</span>(table.secondaryStart&lt;0){
00922       table.secondaryStart=0;
00923     }
00924     table.secondaryStop = jyCentral + upYSpread;
00925     <span class="keywordflow">if</span>(table.secondaryStop&gt;params.geometry.nY-1){
00926       table.secondaryStop=params.geometry.nY-1;
00927       <span class="comment">//       cout&lt;&lt;"table.secondaryStop greater nY "&lt;&lt;endl;</span>
00928     }
00929     table.zStart = jzCentral - downZSpread;
00930     <span class="keywordflow">if</span>(table.zStart&lt;0){
00931       table.zStart=0;
00932       <span class="comment">//       cout&lt;&lt;"table.zStart less than 0 in X"&lt;&lt;endl;</span>
00933     }
00934     table.zStop = jzCentral + upZSpread;
00935     <span class="keywordflow">if</span>(table.zStop &gt; params.geometry.nZ-1){
00936       table.zStop= params.geometry.nZ-1;
00937       <span class="comment">//       cout&lt;&lt;"table.zStop greater than nZ in X"&lt;&lt;endl;</span>
00938     }
00939     <span class="comment">//start points</span>
00940     dRStart = (dyCentral - downYSpread) * event.<a class="code" href="classEventPacket.html#o22">sinphi</a>;
00941     dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
00942     dR=dRStart;
00943     <span class="keywordflow">for</span>(jy=table.secondaryStart; jy&lt;=table.secondaryStop; jy++){
00944       <span class="comment">//get kernel index and value at R direction</span>
00945       kIndexR = resFunR.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
00946         (<span class="keywordtype">int</span>)floor(dR*resFunR.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
00947       resFunRTable[jy]=resFunR.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexR];
00948       dR += event.<a class="code" href="classEventPacket.html#o22">sinphi</a>;
00949       <span class="comment">//end test</span>
00950     }
00951     dU = dUStart;
00952     <span class="keywordflow">for</span>(jz=table.zStart; jz &lt;=table.zStop; jz++){ 
00953 
00954       <span class="comment">//get kernel index and value at U direction</span>
00955       kIndexU = resFunU.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
00956         (<span class="keywordtype">int</span>)floor(dU * resFunU.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
00957       resFunUTable[jz]=resFunU.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexU];
00958       <span class="comment">// next value is not strictly costheta if voxels are not cubic</span>
00959       dU += event.<a class="code" href="classEventPacket.html#o24">costheta</a>;                     
00960 
00961     }
00962     <span class="keywordflow">for</span>(jy=table.secondaryStart; jy&lt;=table.secondaryStop; jy++){    
00963       <span class="keywordflow">for</span>(jz=table.zStart; jz &lt;=table.zStop; jz++){ 
00964         <span class="comment">//foward projection</span>
00965         <span class="keywordtype">float</span> kernel = resFunRTable[jy]*resFunUTable[jz];
00966         
00967         <span class="comment">//float kernelU = resFunUTable[jz];</span>
00968         <span class="keywordtype">float</span> muValue = mu.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx];
00969         yhat += kernel*muValue*omega[jx];
00970         sumCij += kernel;
00971 
00972       }
00973     }
00974     y += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>; 
00975     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00976   }
00977   event.<a class="code" href="classEventPacket.html#o18">yhat</a> = yhat;
00978   <span class="keywordflow">return</span> sumCij;
00979 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="MOLAR::fwdProjectEventY" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float MOLAR::fwdProjectEventY </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mu</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventPacket.html">EventPacket</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunR</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structResolutionTable.html">ResolutionTable</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>resFunU</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>omega</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function directly forward projects an event when y is primary direction <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>mu</em>&nbsp;</td><td>the attenuation image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>event</em>&nbsp;</td><td>event to project </td></tr>
    <tr><td valign=top><em>resFunR</em>&nbsp;</td><td>resolution function at R direction </td></tr>
    <tr><td valign=top><em>resFunU</em>&nbsp;</td><td>resolution function at U direction </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00992">992</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventPacket_8hpp-source.html#l00045">EventPacket::cosphi</a>, <a class="el" href="EventPacket_8hpp-source.html#l00048">EventPacket::costheta</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00018">ResolutionTable::downSpread</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstop</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00012">ResolutionTable::kCentralIndex</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00034">ResolutionTable::kernel</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00031">ResolutionTable::magnification</a>, <a class="el" href="MOLAR_8hpp-source.html#l00358">MOLAR::Table::secondaryStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::secondaryStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::secondaryStep</a>, <a class="el" href="MOLAR_8hpp-source.html#l00358">MOLAR::Table::secondaryStop</a>, <a class="el" href="ResolutionTable_8hpp-source.html#l00024">ResolutionTable::upSpread</a>, <a class="el" href="EventPacket_8hpp-source.html#l00036">EventPacket::yhat</a>, <a class="el" href="MOLAR_8hpp-source.html#l00359">MOLAR::Table::zStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00016">EventPacket::zStart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::zStep</a>, and <a class="el" href="MOLAR_8hpp-source.html#l00359">MOLAR::Table::zStop</a>.
<p>
Referenced by <a class="el" href="MOLAR_8cpp-source.html#l00612">fwdProject()</a>, and <a class="el" href="MOLAR_8cpp-source.html#l00771">fwdProjectSolidAngle()</a>.
<p>
<div class="fragment"><pre>00996 {
00997   <span class="comment">//spreads in x and z direction</span>
00998   <span class="keywordtype">int</span> downXSpread, upXSpread, downZSpread, upZSpread;
00999   <span class="comment">//intermidiate variables</span>
01000   <span class="comment">//float dl, dmid,omega,cijNorm, length;</span>
01001   <span class="comment">//yhat and CijNomr</span>
01002   <span class="keywordtype">float</span> yhat = 0, sumCij = 0;
01003   <span class="comment">//loop variables</span>
01004   <span class="keywordtype">int</span>  jx, jy, jz;
01005   <span class="comment">//x z coordinates</span>
01006   <span class="keywordtype">float</span> x,z;
01007   <span class="comment">//voxel centers</span>
01008   <span class="keywordtype">int</span> jxCentral, jzCentral;
01009   <span class="comment">//voxel diviations</span>
01010   <span class="keywordtype">float</span>  dxCentral, dzCentral;
01011   Table table;
01012   <span class="comment">//starting points</span>
01013   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
01014   <span class="comment">//index of kernel</span>
01015   <span class="keywordtype">int</span> kIndexR, kIndexU;
01016   <span class="comment">//resolution function kernel table</span>
01017   <span class="keywordtype">float</span> resFunRTable[params.geometry.nX],
01018     resFunUTable[params.geometry.nZ]; 
01019   downXSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o23">cosphi</a>);
01020   upXSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o23">cosphi</a>);
01021   downZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01022   upZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01023 
01024   x = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
01025   z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
01026   <span class="keywordflow">for</span>(jy=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jy&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jy++){
01027     <span class="comment">//solid angle correction</span>
01028     <span class="comment">// omega=POW2((d0/(dmid+dl*fabs(jy-event.jmid))));</span>
01029 
01030     jxCentral = (<span class="keywordtype">int</span>)(x);<span class="comment">//we have maken sure that floor(x)&gt;=0</span>
01031     jzCentral = (<span class="keywordtype">int</span>)(z);<span class="comment">//we have maken sure that floor(z)&gt;=0</span>
01032     dxCentral = jxCentral+0.5-x; <span class="comment">//+0.5 to transfer image index </span>
01033                                  <span class="comment">//to image coordinate system</span>
01034     dzCentral = jzCentral+0.5-z;
01035     table.secondaryStart = jxCentral - downXSpread;<span class="comment">//int</span>
01036     <span class="keywordflow">if</span>(table.secondaryStart&lt;0) {
01037       table.secondaryStart=0;
01038       <span class="comment">// cout&lt;&lt;"table.secondaryStart less than 0 in Y"&lt;&lt;endl;</span>
01039     }
01040     table.secondaryStop = jxCentral + upXSpread;
01041     <span class="keywordflow">if</span>(table.secondaryStop&gt;params.geometry.nX-1){
01042       table.secondaryStop=params.geometry.nX-1;
01043     }
01044     table.zStart = jzCentral - downZSpread;
01045     <span class="keywordflow">if</span>(table.zStart&lt;0){
01046       table.zStart=0;
01047       <span class="comment">//       cout&lt;&lt;"table.zStart less than 0 in Y"&lt;&lt;endl;</span>
01048     }
01049     table.zStop = jzCentral + upZSpread;
01050     <span class="keywordflow">if</span>(table.zStop &gt; params.geometry.nZ-1){
01051       table.zStop=params.geometry.nZ-1;
01052       <span class="comment">//       cout&lt;&lt;"talbe.zStop greater than nZ in Y"&lt;&lt;endl;</span>
01053     }
01054     dRStart = (dxCentral - downXSpread) * event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
01055     dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
01056 
01057     <span class="comment">//calculate the kernel of resolution function R</span>
01058     dR=dRStart;
01059     <span class="keywordflow">for</span>(jx=table.secondaryStart; jx&lt;=table.secondaryStop; jx++){
01060       kIndexR = resFunR.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01061         (<span class="keywordtype">int</span>)floor(dR*resFunR.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01062       resFunRTable[jx]=resFunR.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexR];
01063       dR += event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
01064     }
01065     <span class="comment">//calculate the kernel of resolution function U</span>
01066     dU = dUStart;
01067     <span class="keywordflow">for</span>(jz=table.zStart; jz &lt;= table.zStop; jz++) {
01068       kIndexU = resFunU.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01069         (<span class="keywordtype">int</span>)floor(dU * resFunU.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01070       resFunUTable[jz]=resFunU.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexU];
01071       <span class="comment">// next value is not strictly costheta if voxels are not cubic</span>
01072       dU += event.<a class="code" href="classEventPacket.html#o24">costheta</a>;  
01073     }
01074     <span class="keywordflow">for</span>(jx=table.secondaryStart; jx&lt;=table.secondaryStop; jx++){  
01075       <span class="keywordflow">for</span>(jz=table.zStart; jz &lt;= table.zStop; jz++) {    
01076    
01077         <span class="keywordtype">float</span> kernel =  resFunRTable[jx]*resFunUTable[jz];
01078         <span class="keywordtype">float</span> muValue= mu.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx];
01079        
01080         yhat +=kernel* muValue*omega[jy];
01081         sumCij +=  kernel;
01082       }
01083     }
01084     <span class="comment">//next </span>
01085     x += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
01086     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
01087   }
01088   event.<a class="code" href="classEventPacket.html#o18">yhat</a> = yhat;
01089   <span class="comment">//temp set for simulation</span>
01090 
01091   <span class="keywordflow">return</span> sumCij;
01092 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="MOLAR::fwdProjectSolidAngle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::fwdProjectSolidAngle </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventList.html">EventList</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>eventList</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This functions performs a direct forward projection of the lambda image without attenuation. It calls the fwdProjectSolidAngleEventX(Y) to correct for the solid angle. This function is created to calculated the expected value of each simulated LOR <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>lambda</em>&nbsp;</td><td>the lambda image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>eventlist</em>&nbsp;</td><td>stores the events </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00771">771</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventPacket_8hpp-source.html#l00029">EventPacket::atten</a>, <a class="el" href="EventPacket_8hpp-source.html#l00043">EventPacket::CijNorm</a>, <a class="el" href="MOLAR_8cpp-source.html#l00874">fwdProjectEventX()</a>, <a class="el" href="MOLAR_8cpp-source.html#l00992">fwdProjectEventY()</a>, <a class="el" href="MOLAR_8cpp-source.html#l00728">fwdProjectSolidAngleEventX()</a>, <a class="el" href="MOLAR_8cpp-source.html#l00751">fwdProjectSolidAngleEventY()</a>, <a class="el" href="EventList_8cpp-source.html#l00331">EventList::getFirst()</a>, <a class="el" href="FourDReconstruction_8hpp-source.html#l00061">FourDReconstruction::getFourD()</a>, <a class="el" href="HRRTScannerParams_8hpp-source.html#l00116">HRRTScannerParams::getInstance()</a>, <a class="el" href="Log_8hpp-source.html#l00079">Log::getLog()</a>, <a class="el" href="EventList_8cpp-source.html#l00352">EventList::getNext()</a>, <a class="el" href="EventList_8hpp-source.html#l00166">EventList::getNumEvents()</a>, <a class="el" href="EventList_8cpp-source.html#l00394">EventList::getSentry()</a>, <a class="el" href="EventPacket_8hpp-source.html#l00053">EventPacket::livetime_decay</a>, <a class="el" href="EventPacket_8hpp-source.html#l00027">EventPacket::norm</a>, <a class="el" href="Log_8hpp-source.html#l00052">Log::outputMessage()</a>, <a class="el" href="HRRTScannerParams_8hpp-source.html#l00065">HRRTScannerParams::panelSeparation</a>, <a class="el" href="EventPacket_8hpp-source.html#l00025">EventPacket::rand</a>, <a class="el" href="EventList_8cpp-source.html#l00320">EventList::replace()</a>, <a class="el" href="EventPacket_8hpp-source.html#l00021">EventPacket::resModelCodeR</a>, <a class="el" href="EventPacket_8hpp-source.html#l00023">EventPacket::resModelCodeZ</a>, <a class="el" href="EventPacket_8hpp-source.html#l00031">EventPacket::scatter</a>, <a class="el" href="EventPacket_8hpp-source.html#l00045">EventPacket::sinphi</a>, <a class="el" href="FourDReconstruction_8cpp-source.html#l00195">FourDReconstruction::updatelambda()</a>, and <a class="el" href="EventPacket_8hpp-source.html#l00036">EventPacket::yhat</a>.
<p>
Referenced by <a class="el" href="AlgorithmSimulation_8cpp-source.html#l00068">AlgorithmSimulation::reconstruct()</a>.
<p>
<div class="fragment"><pre>00773 {
00774   <span class="comment">//update status file</span>
00775   Status *status = Status::getStatus();
00776   
00777   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> &amp;scannerParams=*<a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00778   <a class="code" href="classFourDReconstruction.html">FourDReconstruction</a> *fourd= <a class="code" href="classFourDReconstruction.html#e0">FourDReconstruction::getFourD</a>();;
00779   <span class="comment">// DO not know how to do this only for 4D simulation</span>
00780   <span class="comment">//if (params.algorithm.name == "simulation" &amp;&amp; params.algorithm.algorithmKeys=="4D") {</span>
00781   <span class="comment">//  *fourd = FourDReconstruction::getFourD();</span>
00782   <span class="comment">//}</span>
00783   <span class="comment">//paramter for solid angle correction</span>
00784   <span class="keywordtype">float</span> d0 = scannerParams.<a class="code" href="classHRRTScannerParams.html#o6">panelSeparation</a>/2.0;
00785   <span class="keywordtype">float</span> omega[params.geometry.nX];<span class="comment">//dummy solid angle correction coefficient</span>
00786 
00787   <span class="keywordflow">if</span>(status-&gt;proc==0){
00788     stringstream ss;
00789     ss&lt;&lt;<span class="stringliteral">"================================="</span>&lt;&lt;endl;
00790     ss&lt;&lt;<span class="stringliteral">"Forward projection"</span>&lt;&lt;endl;
00791     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00792     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(ss.str(),FRAME, 0);
00793     string comm=ss.str();
00794     Status::StatusCode code=Status::RUNNING;
00795     status-&gt;update(comm,code);
00796   }
00797 
00798   <a class="code" href="structResolutionTable.html">ResolutionTable</a> resFunR, resFunU; <span class="comment">//resolution functions</span>
00799   <span class="keywordtype">int</span> subset; <span class="comment">//sub-list of the event list</span>
00800   <a class="code" href="classEventPacket.html">EventPacket</a> event; <span class="comment">//event attracted from the event lise</span>
00801   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); <span class="comment">//prepare for sentry</span>
00802   <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got   </span>
00803   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> averageStart = 0, averageStop=0;
00804 
00805   <span class="keywordflow">for</span>(subset=0;subset&lt;params.algorithm.numSets;subset++){
00806     event = eventList.<a class="code" href="classEventList.html#a3">getFirst</a>(subset);<span class="comment">//Get first event</span>
00807     <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got</span>
00808     <span class="keywordflow">while</span> (!(event==sentry)) {
00809     
00810       <span class="comment">// update lambda if doing 4D simulation (whl- 04/15/07)</span>
00811        
00812       <span class="keywordflow">if</span> (params.algorithm.name == <span class="stringliteral">"simulation"</span> &amp;&amp; params.algorithm.algorithmKeys==<span class="stringliteral">"4D"</span>) {
00813         fourd-&gt;<a class="code" href="classFourDReconstruction.html#a3">updatelambda</a>(lambda,event,params);       
00814       }
00815  
00816       <span class="comment">//get resolution functions of the event</span>
00817       resFunR = house-&gt;getResFunR(event.<a class="code" href="classEventPacket.html#o6">resModelCodeR</a>);
00818       resFunU = house-&gt;getResFunZ(event.<a class="code" href="classEventPacket.html#o7">resModelCodeZ</a>);
00819       <span class="comment">//forward project</span>
00820       <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o22">sinphi</a> &gt; Constant::SIN45) {<span class="comment">//x is primary direction</span>
00821         <a class="code" href="classMOLAR.html#a9">fwdProjectSolidAngleEventX</a>(event, params,d0,omega);
00822         <a class="code" href="classMOLAR.html#a6">fwdProjectEventX</a>(lambda,event,resFunR,resFunU,params,omega);
00823 
00824       }
00825       <span class="keywordflow">else</span> { <span class="comment">//y is primary direction</span>
00826         <a class="code" href="classMOLAR.html#a10">fwdProjectSolidAngleEventY</a>(event, params, d0, omega);
00827         <a class="code" href="classMOLAR.html#a8">fwdProjectEventY</a>(lambda,event,resFunR,resFunU,params,omega);
00828       }
00829       event.<a class="code" href="classEventPacket.html#o18">yhat</a> = event.<a class="code" href="classEventPacket.html#o18">yhat</a> * event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> * event.<a class="code" href="classEventPacket.html#o9">norm</a>*
00830           event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a> * event.<a class="code" href="classEventPacket.html#o10">atten</a> +event.<a class="code" href="classEventPacket.html#o8">rand</a> + event.<a class="code" href="classEventPacket.html#o11">scatter</a>;
00831 
00832       eventList.<a class="code" href="classEventList.html#a7">replace</a>(subset,event);
00833       <span class="comment">//get next event</span>
00834       event = eventList.<a class="code" href="classEventList.html#a4">getNext</a>(subset);
00835 
00836       ++countT; <span class="comment">//increase count</span>
00837       <span class="keywordflow">if</span>(status-&gt;proc ==0){ 
00838         <span class="keywordflow">if</span>(countT%50000==0 &amp;&amp; params.frame.verbosity&gt;=2) 
00839           (cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">"  events out of "</span>
00840            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00841            &lt;&lt;<span class="stringliteral">" events forward projected"</span>&lt;&lt;endl).flush();
00842         <span class="comment">//if(event==sentry) (cout&lt;&lt;countT&lt;&lt;endl).flush();</span>
00843       } <span class="comment">//end if</span>
00844 
00845     }<span class="comment">//while loop</span>
00846     <span class="comment">//     averageStart=averageStart/countT;</span>
00847     <span class="comment">//     averageStop = averageStop/countT;</span>
00848     <span class="keywordflow">if</span>(status-&gt;proc ==0)
00849      cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">"  events out of "</span>
00850            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00851            &lt;&lt;<span class="stringliteral">" events forward projected"</span>&lt;&lt;endl;
00852   } <span class="comment">//for loop - subset</span>
00853   <span class="keywordflow">if</span>(status-&gt;proc == 0){
00854     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00855     stringstream msg;
00856     msg &lt;&lt; <span class="stringliteral">"Forward projection takes "</span>&lt;&lt; timeFwdProj&lt;&lt; <span class="stringliteral">" s"</span>&lt;&lt;endl;
00857     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(msg.str(),ATTENUATION, 2);
00858   }
00859  
00860 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="MOLAR::fwdProjectSolidAngleEventX" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float MOLAR::fwdProjectSolidAngleEventX </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classEventPacket.html">EventPacket</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>d0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>omega</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs solid angle correction when X is primary direction 
<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00728">728</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventPacket_8hpp-source.html#l00057">EventPacket::jmid</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstop</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::secondaryStep</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::x1</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::x2</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::y1</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::y2</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::z1</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::z2</a>, and <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::zStep</a>.
<p>
Referenced by <a class="el" href="MOLAR_8cpp-source.html#l01107">backProjectQ()</a>, <a class="el" href="MOLAR_8cpp-source.html#l00771">fwdProjectSolidAngle()</a>, and <a class="el" href="AlgorithmOSEM_8cpp-source.html#l00166">AlgorithmOSEM::oneIteration()</a>.
<p>
<div class="fragment"><pre>00731 {
00732   <span class="keywordtype">float</span>  dl =sqrt(POW2((params.geometry.dX))+
00733                   POW2((params.geometry.dY*event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>))+
00734                   POW2((params.geometry.dZ)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>));
00735   <span class="keywordtype">float</span> dmid = sqrt(POW2((event.<a class="code" href="classEventPacket.html#o15">x2</a>-event.<a class="code" href="classEventPacket.html#o12">x1</a>))+POW2((event.<a class="code" href="classEventPacket.html#o16">y2</a>-event.<a class="code" href="classEventPacket.html#o13">y1</a>))+
00736                     POW2((event.<a class="code" href="classEventPacket.html#o17">z2</a>-event.<a class="code" href="classEventPacket.html#o14">z1</a>)))/2.0;
00737   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jx=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jx&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jx++){
00738     <span class="comment">//solid angle correction</span>
00739     <span class="comment">//omega[jx]=POW2((d0/(dmid+dl*fabs(jx-event.jmid))));</span>
00740     omega[jx]=2.*POW2(d0)/(POW2(dmid+dl*(jx-event.<a class="code" href="classEventPacket.html#o28">jmid</a>))+POW2(dmid-dl*(jx-event.<a class="code" href="classEventPacket.html#o28">jmid</a>)));
00741     <span class="comment">//omega[jx]=1;</span>
00742   }
00743   <span class="keywordflow">return</span> dl;
00744 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="MOLAR::fwdProjectSolidAngleEventY" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float MOLAR::fwdProjectSolidAngleEventY </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classEventPacket.html">EventPacket</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>event</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>d0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float&nbsp;</td>
          <td class="mdname" nowrap> <em>omega</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs solid angle correction when Y is primary direction 
<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00751">751</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventPacket_8hpp-source.html#l00057">EventPacket::jmid</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstart</a>, <a class="el" href="EventPacket_8hpp-source.html#l00013">EventPacket::jstop</a>, <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::secondaryStep</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::x1</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::x2</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::y1</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::y2</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::z1</a>, <a class="el" href="EventPacket_8hpp-source.html#l00033">EventPacket::z2</a>, and <a class="el" href="EventPacket_8hpp-source.html#l00018">EventPacket::zStep</a>.
<p>
Referenced by <a class="el" href="MOLAR_8cpp-source.html#l01107">backProjectQ()</a>, <a class="el" href="MOLAR_8cpp-source.html#l00771">fwdProjectSolidAngle()</a>, and <a class="el" href="AlgorithmOSEM_8cpp-source.html#l00166">AlgorithmOSEM::oneIteration()</a>.
<p>
<div class="fragment"><pre>00754 {
00755   <span class="keywordtype">float</span>  dl =sqrt(POW2((params.geometry.dY))+
00756                   POW2((params.geometry.dX*event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>))+
00757                   POW2((params.geometry.dZ)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>));
00758   <span class="keywordtype">float</span> dmid = sqrt(POW2((event.<a class="code" href="classEventPacket.html#o15">x2</a>-event.<a class="code" href="classEventPacket.html#o12">x1</a>))+
00759                     POW2((event.<a class="code" href="classEventPacket.html#o16">y2</a>-event.<a class="code" href="classEventPacket.html#o13">y1</a>))+
00760                     POW2((event.<a class="code" href="classEventPacket.html#o17">z2</a>-event.<a class="code" href="classEventPacket.html#o14">z1</a>)))/2.0;
00761   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jy=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jy&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jy++){
00762     <span class="comment">//solid angle correction</span>
00763     <span class="comment">//omega[jy]=POW2((d0/(dmid+dl*fabs(jy-event.jmid))));</span>
00764     omega[jy]=2.*POW2(d0)/(POW2(dmid+dl*(jy-event.<a class="code" href="classEventPacket.html#o28">jmid</a>))+POW2(dmid-dl*(jy-event.<a class="code" href="classEventPacket.html#o28">jmid</a>)));
00765     <span class="comment">//omega[jy]=1;</span>
00766   }
00767   <span class="keywordflow">return</span> dl;
00768 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="MOLAR::generateSinoGram" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::generateSinoGram </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classEventList.html">EventList</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>eventList</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Status &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs calcualtion of sino gram <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>eventlist</em>&nbsp;</td><td>the list to store events </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>the instance of Params class, inited from xml file, stores the parameters sinogram such as type and geometry </td></tr>
    <tr><td valign=top><em>status</em>&nbsp;</td><td>instance of the Status class </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00267">267</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
Referenced by <a class="el" href="AlgorithmSimulation_8cpp-source.html#l00068">AlgorithmSimulation::reconstruct()</a>, and <a class="el" href="AlgorithmOSEM_8cpp-source.html#l00024">AlgorithmOSEM::reconstruct()</a>.
<p>
<div class="fragment"><pre>00269 {
00270   <span class="comment">//init sinogram</span>
00271   Sinogram sinoGram(params);
00272   <span class="comment">//sinogram calculation and output</span>
00273   sinoGram.generateSino(eventList, status);
00274 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="MOLAR::getAlgorithm" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classAlgorithm.html">Algorithm</a>* MOLAR::getAlgorithm </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the <a class="el" href="classAlgorithm.html">Algorithm</a> pointer in the class <dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="classAlgorithm.html">Algorithm</a> pointer </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8hpp-source.html#l00422">422</a> of file <a class="el" href="MOLAR_8hpp-source.html">MOLAR.hpp</a>.
<p>
References <a class="el" href="Utilities_8hpp-source.html#l00106">Utilities::cleanUp()</a>.
<p>
<div class="fragment"><pre>00423   {    
00424     <span class="keywordflow">if</span>(!checkValid()){
00425       Status *status= Status::getStatus();
00426       <span class="keywordflow">if</span>(status-&gt;proc==0){
00427         cout&lt;&lt;<span class="stringliteral">"Error in use of MOLAR class"</span>
00428             &lt;&lt;<span class="stringliteral">"Programmer make sure call the getInstance"</span>
00429           &lt;&lt;<span class="stringliteral">"Program aborted"</span>&lt;&lt;endl;
00430         cout.flush();
00431       }
00432       <a class="code" href="classUtilities.html#e8">Utilities::cleanUp</a>(Constant::POINTERERROR);
00433     }
00434     <span class="keywordflow">return</span> algorithm;
00435   }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="MOLAR::getHouse" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> House* MOLAR::getHouse </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the house pointer in the class <dl compact><dt><b>Returns:</b></dt><dd>House pointer </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8hpp-source.html#l00404">404</a> of file <a class="el" href="MOLAR_8hpp-source.html">MOLAR.hpp</a>.
<p>
References <a class="el" href="Utilities_8hpp-source.html#l00106">Utilities::cleanUp()</a>.
<p>
<div class="fragment"><pre>00405   {
00406     <span class="keywordflow">if</span>(!checkValid()){
00407       Status *status= Status::getStatus();
00408       <span class="keywordflow">if</span>(status-&gt;proc==0){
00409       cout&lt;&lt;<span class="stringliteral">"Error in use of MOLAR class"</span>
00410           &lt;&lt;<span class="stringliteral">"Programmer make sure call the getInstance"</span>
00411           &lt;&lt;<span class="stringliteral">"Program aborted"</span>&lt;&lt;endl;
00412       cout.flush();
00413       }
00414       <a class="code" href="classUtilities.html#e8">Utilities::cleanUp</a>(Constant::POINTERERROR);
00415     }
00416 
00417     <span class="keywordflow">return</span> house;
00418   }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="e0" doxytag="MOLAR::getInstance" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classMOLAR.html">MOLAR</a> * MOLAR::getInstance </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns the singleton instance <dl compact><dt><b>Returns:</b></dt><dd>MOLAR pointer to the singleton instance </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00049">49</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
Referenced by <a class="el" href="AlgorithmOSEM_8cpp-source.html#l00166">AlgorithmOSEM::oneIteration()</a>, <a class="el" href="AlgorithmSimulation_8cpp-source.html#l00068">AlgorithmSimulation::reconstruct()</a>, and <a class="el" href="AlgorithmOSEM_8cpp-source.html#l00024">AlgorithmOSEM::reconstruct()</a>.
<p>
<div class="fragment"><pre>00050 {
00051   <span class="keyword">static</span> <a class="code" href="classMOLAR.html">MOLAR</a> singleton;
00052   <span class="keyword">static</span> <span class="keywordtype">int</span> numInstance = 0;
00053   numInstance ++;
00054   <span class="keywordflow">return</span> &amp;singleton;
00055 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="MOLAR::initializeLambda" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::initializeLambda </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classArray3D.html">Array3D</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Q</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function initializes the lambda image <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>lambda</em>&nbsp;</td><td>the lambda image </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l01596">1596</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
<div class="fragment"><pre>01598 {
01599   <span class="keywordtype">float</span> initLambda;
01600   <span class="keywordflow">if</span>(params.algorithm.initialValue&gt;0)
01601     initLambda = params.algorithm.initialValue;
01602   <span class="keywordflow">else</span>
01603     initLambda = Constant::INITLAMBDA;
01604   
01605   <span class="keywordflow">if</span>(params.algorithm.enableInitLambdaMasking)
01606     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; iy&lt;params.geometry.nY; iy++)
01607       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0; iz &lt; params.geometry.nZ; iz++)
01608         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0; ix&lt; params.geometry.nX; ix++){
01609           lambda(ix,iy,iz) = initLambda*lambdaMask(ix,iy,iz);
01610         }
01611   <span class="keywordflow">else</span>
01612     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; iy&lt;params.geometry.nY; iy++)
01613       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0; iz &lt; params.geometry.nZ; iz++)
01614         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0; ix&lt; params.geometry.nX; ix++){
01615           lambda(ix,iy,iz) = initLambda;
01616         }
01617 
01618 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="MOLAR::player" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::player </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname" nowrap> <em>randomFlag</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Params &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>params</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classEventList.html">EventList</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>eventList</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Status &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The player function assigns the events to the next subset-list by appending the received event to the end of that list. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>randomFlag</em>&nbsp;</td><td>flag for use randomized event list mode file or true list mode file </td></tr>
    <tr><td valign=top><em>params</em>&nbsp;</td><td>Instance of Params class, inited from the xml file </td></tr>
    <tr><td valign=top><em>eventlist</em>&nbsp;</td><td>the eventlist to be appended </td></tr>
    <tr><td valign=top><em>house</em>&nbsp;</td><td>instance of House class, where the events are read in </td></tr>
    <tr><td valign=top><em>status</em>&nbsp;</td><td>instance of Status class </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l00214">214</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
References <a class="el" href="EventList_8cpp-source.html#l00233">EventList::append()</a>, <a class="el" href="FourDReconstruction_8hpp-source.html#l00061">FourDReconstruction::getFourD()</a>, <a class="el" href="EventBuffer_8hpp-source.html#l00162">EventBuffer::getNext()</a>, <a class="el" href="EventBuffer_8hpp-source.html#l00215">EventBuffer::getNumEvents()</a>, <a class="el" href="EventList_8cpp-source.html#l00394">EventList::getSentry()</a>, <a class="el" href="FourDReconstruction_8cpp-source.html#l00152">FourDReconstruction::initplayer()</a>, and <a class="el" href="EventBuffer_8hpp-source.html#l00137">EventBuffer::receive()</a>.
<p>
<div class="fragment"><pre>00215 {
00216   <a class="code" href="classEventBuffer.html">EventBuffer</a> eventBuffer(1); <span class="comment">//        init event buffer</span>
00217   <span class="keywordtype">int</span> proc;     <span class="comment">//process number</span>
00218   <span class="keywordtype">int</span> numProcs=status.numProcs; <span class="comment">//total number of processes</span>
00219   <a class="code" href="classEventPacket.html">EventPacket</a> event;    <span class="comment">//event </span>
00220   <span class="keywordtype">int</span> subset = 0;       <span class="comment">//sub-list of the eventlist</span>
00221   <span class="keywordtype">bool</span> sentryReached = <span class="keyword">false</span>;   <span class="comment">//if sentry is reached, init as false</span>
00222   
00223   <span class="keywordflow">if</span> (randomFlag) {
00224    <span class="comment">// on the random pass, if we are doing 4D simulation, we must pick up the</span>
00225    <span class="comment">// kinetics information from processor 0</span>
00226    <span class="keywordflow">if</span>(params.algorithm.name == <span class="stringliteral">"simulation"</span> &amp;&amp; params.algorithm.algorithmKeys == <span class="stringliteral">"4D"</span>) {
00227     <span class="comment">//cout&lt;&lt;"Processor "&lt;&lt;status.proc&lt;&lt;" receiving 4D structure"&lt;&lt;endl;</span>
00228     <a class="code" href="classFourDReconstruction.html">FourDReconstruction</a> *fourd = <a class="code" href="classFourDReconstruction.html#e0">FourDReconstruction::getFourD</a>();
00229     fourd-&gt;<a class="code" href="classFourDReconstruction.html#a2">initplayer</a>(status);
00230     <span class="comment">//cout&lt;&lt;"Processor "&lt;&lt;status.proc&lt;&lt;" received 4D structure"&lt;&lt;endl;</span>
00231    }
00232   }
00233   
00234   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); 
00235   <span class="comment">// prepare termination sentry</span>
00236   <span class="comment">//debug variable</span>
00237   <span class="keywordtype">int</span> countRec = 0;
00238 
00239   eventBuffer.<a class="code" href="classEventBuffer.html#a5">receive</a>(0); <span class="comment">//receive an event to event buffer</span>
00240   <span class="keywordflow">while</span>(!sentryReached){ <span class="comment">//receive a sentry?{</span>
00241     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ie=0;ie&lt;eventBuffer.<a class="code" href="classEventBuffer.html#a11">getNumEvents</a>();ie++){
00242       event = eventBuffer.<a class="code" href="classEventBuffer.html#a7">getNext</a>(0);
00243       <span class="keywordflow">if</span>(event == sentry)
00244         sentryReached = <span class="keyword">true</span>;
00245       <span class="keywordflow">if</span> (sentryReached) <span class="keywordflow">break</span>;
00246 
00247       eventList.<a class="code" href="classEventList.html#a2">append</a>(subset,event);
00248       subset++;
00249       subset %= params.algorithm.numSets;
00250     }
00251     <span class="comment">// We can assume that as long as the sentry hasnt been reached,</span>
00252     <span class="comment">// more data will be received.</span>
00253     <span class="keywordflow">if</span>(!sentryReached) eventBuffer.<a class="code" href="classEventBuffer.html#a5">receive</a>(0);
00254     <span class="keywordflow">if</span>(params.frame.verbosity&gt;=5) {
00255       countRec++;
00256       cout&lt;&lt;countRec&lt;&lt;<span class="stringliteral">" Event buffers Received..."</span>&lt;&lt;endl;
00257     }
00258   }
00259   <span class="keywordflow">if</span>(params.frame.verbosity&gt;=5) {
00260     cout&lt;&lt;countRec&lt;&lt;<span class="stringliteral">" Event buffers Received..."</span>&lt;&lt;endl;
00261   }
00262   
00263 }
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="MOLAR::smoothQ" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MOLAR::smoothQ </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Q</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classImage.html">Image</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mu</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs a Gaussian smoothing (up to 3 dimensions) of the Q image The smoothing parameter for each dimension is read from the .xml file as params.algorithm.Q_fwhmx params.algorithm.Q_fwhmy params.algorithm.Q_fwhmz Set the smoothing parameters to 0 if no smoothing is desired Note that the smoothing is performed separately for each dimension, in order to be able to choose any desired combination among the smoothing parameters Since we want to minimize the problem of hot edges, this function needs the mu image for the decision of smoothing only those voxels inside the object. Voxels outside the object keep the original Q value <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Q</em>&nbsp;</td><td>the Q image </td></tr>
    <tr><td valign=top><em>mu</em>&nbsp;</td><td>the mu image </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>
Definition at line <a class="el" href="MOLAR_8cpp-source.html#l01456">1456</a> of file <a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a>.
<p>
<div class="fragment"><pre>01457 { 
01458   Params &amp;params= *Params::getInstance();
01459   <span class="keywordflow">if</span> (params.algorithm.Q_fwhmx != 0) {
01460     <span class="keywordtype">int</span> midx,widthx;
01461     midx= int(1.5* params.algorithm.Q_fwhmx+0.99);
01462     widthx=2*midx+1;
01463     <span class="keywordtype">double</span> total=0;
01464     <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> kernelx(widthx);
01465     <a class="code" href="classImage.html">Image</a> Qsmoothx(params.geometry.nX,params.geometry.nY,params.geometry.nZ);
01466     for (<span class="keywordtype">int</span> i=0;i&lt;widthx;i++){
01467       <span class="comment">//smoothing kernel in x</span>
01468       kernelx(i) = (1/(sqrt(2*Constant::PI)* params.algorithm.Q_fwhmx/2.35))*exp(-0.5*(POW2(i-midx)/POW2(params.algorithm.Q_fwhmx/2.35)));
01469       total+=kernelx(i);
01470     }
01471     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;widthx;i++){
01472       <span class="comment">//normalizing the smoothing kernel in x</span>
01473       kernelx(i) /= total;
01474     }
01475     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0;k&lt;params.geometry.nZ;k++){
01476       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;params.geometry.nY;j++){
01477         for (<span class="keywordtype">int</span> i=0;i&lt;params.geometry.nX;i++){
01478           Qsmoothx(i,j,k)=0;
01479           <span class="comment">// control bounts of kernel so as not to run over the edge of the image   </span>
01480           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii=max(0,midx-i);ii&lt;min(params.geometry.nX+midx-i,widthx);ii++){
01481             <span class="comment">// calculate the smoothed Q value for each voxel along x</span>
01482             Qsmoothx(i,j,k)+=Q(i-midx+ii,j,k)*kernelx(ii);
01483           }
01484         }
01485       }
01486     }
01487     <span class="comment">// smoothing of Q produces large biases IF Q is changing "rapidly"</span>
01488     <span class="comment">// Remember that errors in Q get multiplied MANY  times in lambda.</span>
01489     <span class="comment">//  This only seems to happen on the edge of the mu mask if we have</span>
01490     <span class="comment">// included/excluded LORs (i.e. enabled bounds check)</span>
01491     <span class="comment">//</span>
01492     <span class="comment">// Therefore, only use the smoothed Qs inside the object</span>
01493     <span class="comment">//</span>
01494     <span class="comment">// It is likely that there will still be hot edges on the edge of the FOV</span>
01495     <span class="comment">// if there is no attenuation or bounds check is off</span>
01496     <span class="keywordflow">if</span> (params.attenuation.enable &amp;&amp; params.frame.enableBoundsCheck) {
01497      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0;iz &lt; params.geometry.nZ; iz++)
01498       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0;iy &lt; params.geometry.nY; iy++)
01499        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0;ix &lt; params.geometry.nX; ix++)
01500         <span class="keywordflow">if</span>(mu(ix,iy,iz)&gt;params.attenuation.threshold) {
01501          Q(ix,iy,iz)=Qsmoothx(ix,iy,iz);
01502         }
01503     }  <span class="keywordflow">else</span> Q=Qsmoothx;
01504   }
01505   
01506   <span class="keywordflow">if</span> (params.algorithm.Q_fwhmy != 0) {
01507     <span class="keywordtype">int</span> midy,widthy;
01508     midy=<span class="keywordtype">int</span>(1.5* params.algorithm.Q_fwhmy+0.99);
01509     widthy=2*midy+1;
01510     <span class="keywordtype">double</span> total=0;
01511     <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> kernely(widthy);
01512     Image Qsmoothy(params.geometry.nX,params.geometry.nY,params.geometry.nZ);
01513     for (<span class="keywordtype">int</span> j=0;j&lt;widthy;j++){
01514       <span class="comment">//smoothing kernel in y</span>
01515       kernely(j) = (1/(sqrt(2*Constant::PI)* params.algorithm.Q_fwhmy/2.35))*exp(-0.5*(POW2(j-midy)/POW2(params.algorithm.Q_fwhmy/2.35)));
01516       total+=kernely(j);
01517     }
01518     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;widthy;j++){
01519       <span class="comment">//normalizing the smoothing kernel in y</span>
01520       kernely(j) /= total;
01521     }    
01522     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0;k&lt;params.geometry.nZ;k++){
01523       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;params.geometry.nX;i++){
01524         for (<span class="keywordtype">int</span> j=0;j&lt;params.geometry.nY;j++){
01525           Qsmoothy(i,j,k)=0;
01526           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj=max(0,midy-j);jj&lt;min(params.geometry.nY+midy-j,widthy);jj++){
01527             <span class="comment">// calculate the smoothed Q value for each voxel along y</span>
01528             Qsmoothy(i,j,k)+=Q(i,j-midy+jj,k)*kernely(jj);
01529           }
01530         }
01531       }
01532     }
01533     <span class="keywordflow">if</span> (params.attenuation.enable &amp;&amp; params.frame.enableBoundsCheck) {
01534      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0;iz &lt; params.geometry.nZ; iz++)
01535       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0;iy &lt; params.geometry.nY; iy++)
01536        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0;ix &lt; params.geometry.nX; ix++)
01537         <span class="keywordflow">if</span>(mu(ix,iy,iz)&gt;params.attenuation.threshold) {
01538          Q(ix,iy,iz)=Qsmoothy(ix,iy,iz);
01539         }
01540     } <span class="keywordflow">else</span> Q=Qsmoothy;
01541     
01542   }
01543   
01544   <span class="keywordflow">if</span> (params.algorithm.Q_fwhmz!= 0) {
01545     <span class="comment">// special code for Z smooth to handle the edge slices</span>
01546     <span class="comment">// taper the kernel down toward the edge slice - this avoids averaging with 0's outside the FOV</span>
01547     <span class="keywordtype">int</span> midz,widthz,midz1,widthz1;
01548     <span class="keywordtype">double</span> total=0;
01549     midz=<span class="keywordtype">int</span>(1.5* params.algorithm.Q_fwhmz+0.99);
01550     widthz=2*midz+1;
01551     <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> kernelz(widthz);
01552     Image Qsmoothz(params.geometry.nX,params.geometry.nY,params.geometry.nZ);
01553     <span class="comment">//  </span>
01554     for (<span class="keywordtype">int</span> k=0;k&lt;params.geometry.nZ;k++){
01555      <span class="comment">// Build the kernel for this slice. Be sure it fits in remaining slices</span>
01556       midz1=min(midz,min(k,params.geometry.nZ-1-k));
01557       widthz1=2*midz1+1;
01558       total=0.;
01559       for (<span class="keywordtype">int</span> kk=0;kk&lt;widthz1;kk++){
01560         <span class="comment">//smoothing kernel in z</span>
01561         kernelz(kk) = (1/(sqrt(2*Constant::PI)* params.algorithm.Q_fwhmz/2.35))*exp(-0.5*(POW2(kk-midz1)/POW2(params.algorithm.Q_fwhmz/2.35)));
01562         total+=kernelz(kk);
01563       }
01564       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kk=0;kk&lt;widthz1;kk++){
01565         <span class="comment">//normalizing the smoothing kernel in z</span>
01566         kernelz(kk) /= total;
01567       }
01568      
01569       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;params.geometry.nY;j++){
01570         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;params.geometry.nX;i++){
01571           Qsmoothz(i,j,k)=0;
01572           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kk=0;kk&lt;widthz1;kk++){
01573             <span class="comment">// calculate the smoothed Q value for each voxel along z</span>
01574             Qsmoothz(i,j,k)+=Q(i,j,k-midz1+kk)*kernelz(kk);
01575           }
01576         }
01577       }
01578     }
01579     <span class="keywordflow">if</span> (params.attenuation.enable &amp;&amp; params.frame.enableBoundsCheck) {
01580      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0;iz &lt; params.geometry.nZ; iz++)
01581       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0;iy &lt; params.geometry.nY; iy++)
01582        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0;ix &lt; params.geometry.nX; ix++)
01583         <span class="keywordflow">if</span>(mu(ix,iy,iz)&gt;params.attenuation.threshold) {
01584          Q(ix,iy,iz)=Qsmoothz(ix,iy,iz);
01585         }
01586     }  <span class="keywordflow">else</span> Q=Qsmoothz; 
01587 
01588   }
01589 }
</pre></div>    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="o16" doxytag="MOLAR::QAve" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float <a class="el" href="classMOLAR.html#o16">MOLAR::QAve</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Average value of Q 
<p>
Definition at line <a class="el" href="MOLAR_8hpp-source.html#l00395">395</a> of file <a class="el" href="MOLAR_8hpp-source.html">MOLAR.hpp</a>.
<p>
Referenced by <a class="el" href="MOLAR_8cpp-source.html#l01637">calculateMask()</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="MOLAR_8hpp-source.html">MOLAR.hpp</a><li><a class="el" href="MOLAR_8cpp-source.html">MOLAR.cpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Dec 13 14:13:49 2007 for reconHRRT by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
