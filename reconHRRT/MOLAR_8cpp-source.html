<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>reconHRRT: MOLAR.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>MOLAR.cpp</h1><div class="fragment"><pre>00001 <span class="preprocessor">#include "MOLAR.hpp"</span>
00002 <span class="preprocessor">#include "HRRTScannerParams.hpp"</span>
00003 <span class="preprocessor">#include "House.hpp"</span>
00004 <span class="preprocessor">#include "HRRTHouse.hpp"</span>
00005 <span class="preprocessor">#include "Algorithm.hpp"</span>
00006 <span class="preprocessor">#include "AlgorithmOSEM.hpp"</span>
00007 <span class="preprocessor">#include "AlgorithmSimulation.hpp"</span>
00008 <span class="preprocessor">#include "FrameInfo.hpp"</span>
00009 <span class="preprocessor">#include "ScatterCorrection.hpp"</span>
00010 <span class="preprocessor">#include "ModelBasedScatterCorrection.hpp"</span>
00011 <span class="preprocessor">#include "FourDReconstruction.hpp"</span>
00012 
00017 MOLAR::MOLAR()
00018 {
00019   <span class="comment">//init house pointer</span>
00020   house = <span class="keyword">new</span> <a class="code" href="classHRRTHouse.html">HRRTHouse</a>;
00021   house-&gt;init();
00022   <span class="comment">//init algorithm pointer</span>
00023   Params * params = Params::getInstance();
00024   <span class="keywordflow">if</span>(params-&gt;algorithm.name ==<span class="stringliteral">"osem"</span>)
00025     algorithm = <span class="keyword">new</span> <a class="code" href="classAlgorithmOSEM.html">AlgorithmOSEM</a>;
00026   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(params-&gt;algorithm.name ==<span class="stringliteral">"simulation"</span>)
00027     algorithm = <span class="keyword">new</span> <a class="code" href="classAlgorithmSimulation.html">AlgorithmSimulation</a>;
00028   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(params-&gt;algorithm.name!=<span class="stringliteral">"sinogram"</span> &amp;&amp; 
00029           params-&gt;algorithm.name!=<span class="stringliteral">"computq"</span>){
00030     string msg = <span class="stringliteral">"Unknown algorithm name "</span>;
00031     <a class="code" href="classUtilities.html#e7">Utilities::logError</a>(msg);
00032     <a class="code" href="classUtilities.html#e8">Utilities::cleanUp</a>(Constant::UNKNOWN);
00033   }
00034   <span class="keywordflow">else</span>
00035     algorithm = 0;
00036   <span class="comment">//init scatter correction pointer</span>
00037   <span class="keywordflow">if</span>(params-&gt;randoms.enable || params-&gt;modelBasedScatter.enable)
00038     scatterCorrection = <span class="keyword">new</span> ModelBasedScatterCorrection;
00039   <span class="keywordflow">else</span>
00040     scatterCorrection = 0;
00041   <span class="comment">//scatterCorrection =0;</span>
00042   checkSum = <span class="keyword">sizeof</span>(<a class="code" href="classMOLAR.html">MOLAR</a>);
00043 }
00044 
<a name="l00049"></a><a class="code" href="classMOLAR.html#e0">00049</a> <a class="code" href="classMOLAR.html">MOLAR</a> * <a class="code" href="classMOLAR.html#e0">MOLAR::getInstance</a>()
00050 {
00051   <span class="keyword">static</span> <a class="code" href="classMOLAR.html">MOLAR</a> singleton;
00052   <span class="keyword">static</span> <span class="keywordtype">int</span> numInstance = 0;
00053   numInstance ++;
00054   <span class="keywordflow">return</span> &amp;singleton;
00055 }
00056  
00057   
00058 
00059 
00060 
00061 
<a name="l00076"></a><a class="code" href="classMOLAR.html#a0">00076</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a0">MOLAR::dealerPlayer</a>(<span class="keywordtype">bool</span> randomFlag, Params &amp;params, 
00077                         <a class="code" href="classEventList.html">EventList</a> &amp;eventList, 
00078                          Status &amp;status)
00079 {
00080   <span class="comment">// The first two declarations are NEW - CAJ</span>
00081   <span class="keyword">const</span> <span class="keywordtype">int</span> EVENT_CYCLE_SIZE=100;  <span class="comment">// Number of processor events between</span>
00082                                    <span class="comment">// load-balancing cycles</span>
00083   <span class="keywordtype">int</span> eventCycleCounter=0;     <span class="comment">// The current counter in the</span>
00084                                <span class="comment">// event-processor cycle.  THe value of</span>
00085                                <span class="comment">// this variable is always between 0</span>
00086                                <span class="comment">// and EVENT_CYCLE_SIZE.</span>
00087   <span class="keywordtype">int</span> proc; <span class="comment">//process number</span>
00088   <span class="keywordtype">int</span> subset;   <span class="comment">//sub-list number </span>
00089   <span class="keywordtype">int</span> numProcs=status.numProcs; <span class="comment">//total number of processes</span>
00090   <a class="code" href="classEventBuffer.html">EventBuffer</a> eventBuffer(numProcs); <span class="comment">//init eventBuffer</span>
00091   <span class="comment">//debug variables </span>
00092   <span class="keywordtype">float</span> z0Min=1e3, z0Max=-1e3, thetaMax=-1e3, thetaMin=1e3;
00093   <span class="keywordtype">int</span> count = 0;
00094   <span class="keywordtype">int</span> countSend = 0;
00095   <span class="keywordflow">if</span>(params.frame.verbosity&gt;=4){
00096     <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> &amp;scanner = *<a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00097     scanner.<a class="code" href="classHRRTScannerParams.html#a2">write</a>(cout);
00098   }
00099     
00100   
00101   <span class="keywordflow">if</span>(randomFlag){ <span class="comment">//using randomized list mode data</span>
00102     cout&lt;&lt;<span class="stringliteral">"Start building randomized event list"</span>&lt;&lt;endl;
00103     house-&gt;prepareRandomizedListData();
00104   }
00105   <span class="keywordflow">else</span>{   <span class="comment">//using true list mode data</span>
00106     cout&lt;&lt;<span class="stringliteral">"Start building true event list"</span>&lt;&lt;endl;
00107     
00108     house-&gt;prepareListData();
00109   }
00110   <span class="comment">//update status file</span>
00111   string comm=<span class="stringliteral">"Starting reading list mode file and building "</span>;
00112   <span class="keywordflow">if</span> (randomFlag) {
00113    comm +=<span class="stringliteral">"randomized"</span>;
00114   } <span class="keywordflow">else</span> {
00115    comm += <span class="stringliteral">"true"</span>;
00116   }
00117   comm+=<span class="stringliteral">" event list"</span>;
00118   Status::StatusCode code = Status::StatusCode(101); 
00119   status.update(comm, code);
00120   
00121   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>();  
00122   <span class="comment">// prepare termination sentry</span>
00123   
00124   <a class="code" href="classEventPacket.html">EventPacket</a> event=house-&gt;getNextEvent();              <span class="comment">//read a event</span>
00125   proc=0;
00126   subset = 0;
00127   <span class="keywordflow">while</span>(!(event==sentry)){
00128     <span class="keywordflow">if</span>(proc==0) {<span class="comment">//process 0</span>
00129       eventList.<a class="code" href="classEventList.html#a2">append</a>(subset,event);
00130       subset++;
00131       subset %= params.algorithm.numSets;
00132     }
00133     <span class="keywordflow">else</span>{
00134       <span class="comment">// The append method appends the next event to the buffer for</span>
00135       <span class="comment">// that node but also sends the buffer when it reaches the max size</span>
00136       <span class="keywordflow">if</span>(eventBuffer.<a class="code" href="classEventBuffer.html#a2">appendFixed</a>(proc,event)){
00137         eventBuffer.<a class="code" href="classEventBuffer.html#a4">sendAndClear</a>(proc);
00138         <span class="keywordflow">if</span>(params.frame.verbosity&gt;=5) {
00139           countSend++;
00140           cout&lt;&lt;countSend&lt;&lt;<span class="stringliteral">" Event buffers Sent to proc "</span>&lt;&lt;proc&lt;&lt;endl;
00141         }
00142       }
00143     }
00144     <span class="comment">// Now we have to find a processor that can accept the next event</span>
00145     <span class="comment">// This is done by incrementing the processor number until a</span>
00146     <span class="comment">// processor is found that has an event load that is at least</span>
00147     <span class="comment">// equal to the event cycle counter</span>
00148     <span class="keywordflow">do</span>{
00149       proc++;
00150       <span class="keywordflow">if</span>(proc == numProcs){
00151         eventCycleCounter++;
00152         eventCycleCounter = eventCycleCounter%EVENT_CYCLE_SIZE;
00153       }
00154       proc = proc%numProcs;
00155     }<span class="keywordflow">while</span>(status.getEventLoad(proc,(<span class="keywordtype">float</span>)EVENT_CYCLE_SIZE) &lt;
00156            (<span class="keywordtype">float</span>)eventCycleCounter);
00157                   
00158     event = house-&gt;getNextEvent();
00159       
00160       
00161     <span class="keywordflow">if</span>(params.frame.verbosity&gt;=5) {
00162       <span class="keywordtype">float</span> z0 = (event.<a class="code" href="classEventPacket.html#o14">z1</a> + event.<a class="code" href="classEventPacket.html#o17">z2</a>)/2;
00163       <span class="keywordtype">float</span> theta = acos(event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
00164       <span class="keywordflow">if</span>(theta&gt;thetaMax) thetaMax=theta;
00165       <span class="keywordflow">if</span>(theta&lt;thetaMin) thetaMin=theta;
00166       <span class="keywordflow">if</span>(z0&gt;z0Max) z0Max=z0;
00167       <span class="keywordflow">if</span>(z0&lt;z0Min) z0Min=z0;
00168       count++ ;
00169       <span class="comment">//   cout&lt;&lt;"Sent event "&lt;&lt;count&lt;&lt;" to process "&lt;&lt;proc&lt;&lt;endl;</span>
00170     }
00171       
00172   }
00173   <span class="comment">// send termination sentry to all nodes</span>
00174   <span class="keywordflow">if</span>(params.frame.verbosity&gt;=5) {
00175     cout&lt;&lt;<span class="stringliteral">"Totally "</span>&lt;&lt;count&lt;&lt;<span class="stringliteral">" Events Got..."</span>&lt;&lt;endl;
00176     cout&lt;&lt;<span class="stringliteral">"z0 max is "</span>&lt;&lt; z0Max &lt;&lt;<span class="stringliteral">" And z0 min is "</span>&lt;&lt;z0Min&lt;&lt;endl;
00177     cout&lt;&lt;<span class="stringliteral">"theta max is "</span>&lt;&lt; thetaMax &lt;&lt;<span class="stringliteral">" And theta min is "</span>
00178         &lt;&lt;thetaMin&lt;&lt;endl;
00179   }
00180   
00181   <span class="keywordflow">if</span>(params.frame.verbosity&gt;=3) {
00182     cout&lt;&lt;<span class="stringliteral">"Sending sentries"</span>&lt;&lt;endl;
00183   }
00184 
00185   <span class="comment">//send a sentry to all proc other than root</span>
00186   <span class="keywordflow">for</span>(proc=1;proc&lt;numProcs;proc++){
00187     eventBuffer.<a class="code" href="classEventBuffer.html#a2">appendFixed</a>(proc,sentry);
00188     eventBuffer.<a class="code" href="classEventBuffer.html#a4">sendAndClear</a>(proc);
00189   }
00190   <span class="comment">//update status file</span>
00191   comm = <span class="stringliteral">"List mode file read and Event list built"</span>;
00192   code = Status::StatusCode(101); 
00193   status.update( comm, code);
00194   cout&lt;&lt;<span class="stringliteral">"=============================================="</span>&lt;&lt;endl;
00195   cout&lt;&lt;<span class="stringliteral">"List mode file read and Event list built"</span>&lt;&lt;endl;
00196   house-&gt;getFrameInfo().init();
00197   house-&gt;getFrameInfo().writeFrameInfo();
00198   <span class="comment">//</span>
00199   
00200 }
00201 
00202 
<a name="l00214"></a><a class="code" href="classMOLAR.html#a1">00214</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a1">MOLAR::player</a>(<span class="keywordtype">bool</span> randomFlag,Params &amp;params, <a class="code" href="classEventList.html">EventList</a> &amp; eventList, Status &amp;status)
00215 {
00216   <a class="code" href="classEventBuffer.html">EventBuffer</a> eventBuffer(1); <span class="comment">//        init event buffer</span>
00217   <span class="keywordtype">int</span> proc;     <span class="comment">//process number</span>
00218   <span class="keywordtype">int</span> numProcs=status.numProcs; <span class="comment">//total number of processes</span>
00219   <a class="code" href="classEventPacket.html">EventPacket</a> event;    <span class="comment">//event </span>
00220   <span class="keywordtype">int</span> subset = 0;       <span class="comment">//sub-list of the eventlist</span>
00221   <span class="keywordtype">bool</span> sentryReached = <span class="keyword">false</span>;   <span class="comment">//if sentry is reached, init as false</span>
00222   
00223   <span class="keywordflow">if</span> (randomFlag) {
00224    <span class="comment">// on the random pass, if we are doing 4D simulation, we must pick up the</span>
00225    <span class="comment">// kinetics information from processor 0</span>
00226    <span class="keywordflow">if</span>(params.algorithm.name == <span class="stringliteral">"simulation"</span> &amp;&amp; params.algorithm.algorithmKeys == <span class="stringliteral">"4D"</span>) {
00227     <span class="comment">//cout&lt;&lt;"Processor "&lt;&lt;status.proc&lt;&lt;" receiving 4D structure"&lt;&lt;endl;</span>
00228     <a class="code" href="classFourDReconstruction.html">FourDReconstruction</a> *fourd = <a class="code" href="classFourDReconstruction.html#e0">FourDReconstruction::getFourD</a>();
00229     fourd-&gt;<a class="code" href="classFourDReconstruction.html#a2">initplayer</a>(status);
00230     <span class="comment">//cout&lt;&lt;"Processor "&lt;&lt;status.proc&lt;&lt;" received 4D structure"&lt;&lt;endl;</span>
00231    }
00232   }
00233   
00234   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); 
00235   <span class="comment">// prepare termination sentry</span>
00236   <span class="comment">//debug variable</span>
00237   <span class="keywordtype">int</span> countRec = 0;
00238 
00239   eventBuffer.<a class="code" href="classEventBuffer.html#a5">receive</a>(0); <span class="comment">//receive an event to event buffer</span>
00240   <span class="keywordflow">while</span>(!sentryReached){ <span class="comment">//receive a sentry?{</span>
00241     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ie=0;ie&lt;eventBuffer.<a class="code" href="classEventBuffer.html#a11">getNumEvents</a>();ie++){
00242       event = eventBuffer.<a class="code" href="classEventBuffer.html#a7">getNext</a>(0);
00243       <span class="keywordflow">if</span>(event == sentry)
00244         sentryReached = <span class="keyword">true</span>;
00245       <span class="keywordflow">if</span> (sentryReached) <span class="keywordflow">break</span>;
00246 
00247       eventList.<a class="code" href="classEventList.html#a2">append</a>(subset,event);
00248       subset++;
00249       subset %= params.algorithm.numSets;
00250     }
00251     <span class="comment">// We can assume that as long as the sentry hasnt been reached,</span>
00252     <span class="comment">// more data will be received.</span>
00253     <span class="keywordflow">if</span>(!sentryReached) eventBuffer.<a class="code" href="classEventBuffer.html#a5">receive</a>(0);
00254     <span class="keywordflow">if</span>(params.frame.verbosity&gt;=5) {
00255       countRec++;
00256       cout&lt;&lt;countRec&lt;&lt;<span class="stringliteral">" Event buffers Received..."</span>&lt;&lt;endl;
00257     }
00258   }
00259   <span class="keywordflow">if</span>(params.frame.verbosity&gt;=5) {
00260     cout&lt;&lt;countRec&lt;&lt;<span class="stringliteral">" Event buffers Received..."</span>&lt;&lt;endl;
00261   }
00262   
00263 }
00264 
00265 
00266 
<a name="l00267"></a><a class="code" href="classMOLAR.html#a17">00267</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a17">MOLAR::generateSinoGram</a>(<a class="code" href="classEventList.html">EventList</a> &amp; eventList, Params &amp; params, 
00268                             Status &amp; status)
00269 {
00270   <span class="comment">//init sinogram</span>
00271   Sinogram sinoGram(params);
00272   <span class="comment">//sinogram calculation and output</span>
00273   sinoGram.generateSino(eventList, status);
00274 }
00275 
00276 
00277 
<a name="l00292"></a><a class="code" href="classMOLAR.html#a2">00292</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a2">MOLAR::boundaryCheckingFwdProject</a>(<a class="code" href="classImage.html">Image</a> &amp;mu, <a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; QMask, 
00293                                         <a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; lambdaMask,
00294                                         Params &amp;params, 
00295                                       <a class="code" href="classEventList.html">EventList</a> &amp;eventList, 
00296                                       <span class="keywordtype">bool</span> exponentiate, 
00297                                       <span class="keywordtype">bool</span> discardFlag)
00298 {
00299   <span class="comment">//update status file</span>
00300   Status *status = Status::getStatus();
00301 
00302   <span class="keywordflow">if</span>(status-&gt;proc==0){
00303     stringstream ss;
00304     ss&lt;&lt;<span class="stringliteral">"================================="</span>&lt;&lt;endl;
00305     ss&lt;&lt;<span class="stringliteral">"BoundaryChecking Forward projection"</span>&lt;&lt;endl;
00306     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00307     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(ss.str(),FRAME, 0);
00308     string comm=ss.str();
00309     Status::StatusCode code=Status::RUNNING;
00310     status-&gt;update(comm,code);
00311   }
00312   <span class="keywordtype">int</span> nAcceptObject =0, nRejectObject = 0;
00313   <span class="keywordtype">double</span> nAcceptObjectD =0., nRejectObjectD = 0.;
00314   <span class="keywordtype">double</span> nAcceptObjectGrandD =0., nRejectObjectGrandD = 0.;
00315    
00316   <a class="code" href="structResolutionTable.html">ResolutionTable</a> resFunR, resFunZ; <span class="comment">//resolution functions</span>
00317   <span class="keywordtype">bool</span> fwdStatus;       
00318   <span class="comment">//fwd status which returns from fwdProjectionEventX or </span>
00319   <span class="comment">// fwdProjectionEventY</span>
00320   <span class="keywordtype">int</span> subset; <span class="comment">//sub-list of the event list</span>
00321   <a class="code" href="classEventPacket.html">EventPacket</a> event; <span class="comment">//event attracted from the event lise</span>
00322   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); <span class="comment">//prepare for sentry</span>
00323   
00324   timeBoundCheck1=clock();
00325   <span class="keywordflow">for</span>(subset=0;subset&lt;params.algorithm.numSets;subset++){
00326     event = eventList.<a class="code" href="classEventList.html#a3">getFirst</a>(subset);<span class="comment">//Get first event</span>
00327     <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got</span>
00328     <span class="keywordflow">while</span> (!(event==sentry)){
00329       <span class="comment">//get resolution functions of the event</span>
00330       resFunR = house-&gt;getResFunR(event.<a class="code" href="classEventPacket.html#o6">resModelCodeR</a>);
00331       resFunZ = house-&gt;getResFunZ(event.<a class="code" href="classEventPacket.html#o7">resModelCodeZ</a>);
00332       <span class="comment">//forward project</span>
00333       <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o22">sinphi</a> &gt; Constant::SIN45) <span class="comment">//x is primary direction</span>
00334         fwdStatus = <a class="code" href="classMOLAR.html#a3">boundaryCheckingFwdProjectEventX</a>(mu,QMask, lambdaMask, event,resFunR,
00335                                                      resFunZ,
00336                                                      params,
00337                                                      exponentiate);
00338       <span class="keywordflow">else</span>  <span class="comment">//y is primary direction</span>
00339         fwdStatus = <a class="code" href="classMOLAR.html#a4">boundaryCheckingFwdProjectEventY</a>(mu,QMask, lambdaMask, event,resFunR,
00340                                                      resFunZ,
00341                                                      params,
00342                                                      exponentiate);
00343       <span class="keywordflow">if</span>(fwdStatus == <span class="keyword">false</span>){
00344         nRejectObject ++;
00345         <span class="keywordflow">if</span>(discardFlag)
00346           eventList.<a class="code" href="classEventList.html#a5">remove</a>(subset);
00347         <span class="keywordflow">else</span>{
00348           event.<a class="code" href="classEventPacket.html#o1">jstop</a> = event.<a class="code" href="classEventPacket.html#o0">jstart</a> - 1 ;
00349           eventList.<a class="code" href="classEventList.html#a7">replace</a>(subset, event);
00350         }
00351       }         
00352       <span class="keywordflow">else</span>{
00353         nAcceptObject++;
00354         eventList.<a class="code" href="classEventList.html#a7">replace</a>(subset,event);
00355       }
00356     
00357       <span class="comment">//get next event</span>
00358       event = eventList.<a class="code" href="classEventList.html#a4">getNext</a>(subset);
00359       ++countT; <span class="comment">//increase count</span>
00360       <span class="keywordflow">if</span>(status-&gt;proc ==0 &amp;&amp; params.frame.verbosity&gt;=2){ 
00361         <span class="keywordflow">if</span>(countT%50000==0) 
00362           (cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">" events out  of "</span> 
00363            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00364            &lt;&lt;<span class="stringliteral">" events (subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">") checked boundary. nAcceptObject="</span>&lt;&lt;nAcceptObject&lt;&lt;
00365            <span class="stringliteral">" nRejectObject="</span>&lt;&lt;nRejectObject&lt;&lt;endl).flush();
00366         <span class="comment">//      if(event==sentry) (cout&lt;&lt;countT&lt;&lt;endl).flush();</span>
00367       } <span class="comment">//end if</span>
00368       
00369       
00370     }<span class="comment">//while loop</span>
00371     <span class="keywordflow">if</span>(status-&gt;proc ==0 &amp;&amp; params.frame.verbosity&gt;=2){ 
00372      cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">" events out of "</span> 
00373            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00374            &lt;&lt;<span class="stringliteral">" events (subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">") checked boundary. nAcceptObject="</span>&lt;&lt;nAcceptObject&lt;&lt;
00375            <span class="stringliteral">" nRejectObject="</span>&lt;&lt;nRejectObject&lt;&lt;endl;
00376     }
00377   } <span class="comment">//for loop-subset</span>
00378   timeBoundCheck2=clock();
00379   timeBoundCheck= (timeBoundCheck2-timeBoundCheck1)/
00380     (CLOCKS_PER_SEC / (<span class="keywordtype">double</span>) 1000.0);
00381 
00382   <span class="comment">// double precision float version</span>
00383   nAcceptObjectD=nAcceptObject;
00384   nRejectObjectD=nRejectObject;
00385   MPI::COMM_WORLD.Allreduce(&amp;nAcceptObjectD, &amp;nAcceptObjectGrandD,1,MPI::DOUBLE,MPI::SUM);
00386 
00387   MPI::COMM_WORLD.Allreduce(&amp;nRejectObjectD, &amp;nRejectObjectGrandD,1,MPI::DOUBLE,MPI::SUM); 
00388   <a class="code" href="classFrameInfo.html">FrameInfo</a> * fi = FrameInfo::getInstance();
00389   fi-&gt;<a class="code" href="classFrameInfo.html#o7">nAcceptObject</a> = nAcceptObjectGrandD;
00390   fi-&gt;<a class="code" href="classFrameInfo.html#o8">nRejectObject</a> = nRejectObjectGrandD;
00391 
00392   <span class="comment">//MPI::COMM_WORLD.Allreduce(&amp;nAcceptObject, &amp;(fi-&gt;nAcceptObject),1,MPI::LONG,MPI::SUM);</span>
00393 
00394   <span class="comment">//MPI::COMM_WORLD.Allreduce(&amp;nRejectObject, &amp;(fi-&gt;nRejectObject),1,MPI::LONG,MPI::SUM); </span>
00395   <span class="keywordflow">if</span>(status-&gt;proc ==0)
00396     fi-&gt;<a class="code" href="classFrameInfo.html#a0">writeFrameInfo</a>();
00397 }
00398   
<a name="l00412"></a><a class="code" href="classMOLAR.html#a3">00412</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classMOLAR.html#a3">MOLAR::boundaryCheckingFwdProjectEventX</a>(<a class="code" href="classImage.html">Image</a> &amp;mu,<a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; QMask, 
00413                                                 <a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; lambdaMask,
00414                                                <a class="code" href="classEventPacket.html">EventPacket</a> &amp;event, 
00415                                                <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, 
00416                                                <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, 
00417                                                    Params &amp;params, 
00418                                                    <span class="keywordtype">bool</span> exponentiate)
00419 {
00420   <span class="comment">//int boundaryBackOff[0] = params.algorithm.boundaryBackOff[0];</span>
00421   <span class="comment">//intersection with phantom on primary direction</span>
00422   <span class="keywordtype">int</span> jStartOut=event.<a class="code" href="classEventPacket.html#o1">jstop</a>,jStopOut=event.<a class="code" href="classEventPacket.html#o0">jstart</a>;
00423   <span class="comment">//loop ints</span>
00424   <span class="keywordtype">int</span> jx, jy, jz;
00425   <span class="comment">//voxel centers</span>
00426   <span class="keywordtype">int</span> jyCentral, jzCentral;
00427   <span class="comment">//deviation from voxel centers</span>
00428   <span class="keywordtype">float</span> dyCentral, dzCentral;
00429   <span class="comment">//start points and increasments on R and U direction</span>
00430   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
00431   <span class="comment">//indices of resolution functions</span>
00432   <span class="keywordtype">int</span> kIndexR, kIndexU;
00433         
00434   <span class="keywordtype">int</span> jStartSave = event.<a class="code" href="classEventPacket.html#o0">jstart</a>, jStopSave = event.<a class="code" href="classEventPacket.html#o1">jstop</a>;
00435   <span class="comment">//intermeidate variable</span>
00436   <span class="comment">//float partial_yhat=0, yhat =0;</span>
00437   <span class="comment">//y and z starting points</span>
00438   <span class="comment">//float y = event.secondaryStart&lt;0?0:event.secondaryStart;</span>
00439   <span class="comment">//float z = event.zStart&lt;0?0:event.zStart;</span>
00440   <span class="keywordtype">float</span> y = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
00441   <span class="keywordtype">float</span> z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
00442 
00443   <span class="comment">//perform forward projection</span>
00444   <span class="keywordtype">int</span> discardit = 1;
00445   <span class="keywordflow">for</span>(jx=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jx&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jx++){
00446     <span class="comment">//center of the voxel</span>
00447     jyCentral = (<span class="keywordtype">int</span>)floor(y);
00448     jzCentral = (<span class="keywordtype">int</span>) floor(z);
00449 
00450     <span class="comment">//assign jy and jz</span>
00451     jy = jyCentral;
00452     jz = jzCentral;
00453 
00454     <span class="comment">//get kernel indices</span>
00455     <span class="comment">//kIndexR = resFunR.kCentralIndex;</span>
00456     <span class="comment">//kIndexU = resFunU.kCentralIndex;</span>
00457     <span class="comment">//foward projection</span>
00458     <span class="comment">//partial_yhat = resFunR.kernel[kIndexR]*resFunU.kernel[kIndexU]* </span>
00459     <span class="comment">//  mu(jx,jy,jz);</span>
00460     <span class="comment">//partial_yhat = mu(jx,jy,jz);</span>
00461     <span class="comment">// old way - use attenuation image directly - now use QMask image</span>
00462     <span class="comment">//if (partial_yhat &gt; params.attenuation.threshold){</span>
00463     <span class="comment">// Qmask decides whether it is kept, lambdaMask decides the bounds</span>
00464     <span class="keywordflow">if</span> (QMask(jx,jy,jz) &gt; 0){
00465       discardit = 0;
00466     }
00467     <span class="keywordflow">if</span> (lambdaMask(jx,jy,jz) &gt; 0){
00468       jStartOut = min(jStartOut,jx);<span class="comment">//</span>
00469       jStopOut = max( jStopOut,jx);<span class="comment">//</span>
00470     }
00471     y += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>; 
00472     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00473     <span class="comment">//yhat += partial_yhat;</span>
00474   }
00475   <span class="comment">//event.yhat = yhat;</span>
00476  
00477   <span class="keywordflow">if</span>( discardit){
00478     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00479   }
00480   <span class="keywordflow">else</span>{
00481     <span class="comment">// used to expand by 2 boundary BackOff (twice as far as lambda expanded</span>
00482     <span class="comment">//jStartOut = max((jStartOut - 2*boundaryBackOff), jStartSave);</span>
00483     <span class="comment">//jStopOut = min((jStopOut+2*boundaryBackOff), jStopSave);</span>
00484     jStartOut = max(jStartOut , jStartSave);
00485     jStopOut = min(jStopOut, jStopSave);
00486     event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a> +=(jStartOut-event.<a class="code" href="classEventPacket.html#o0">jstart</a>)*
00487       event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
00488     event.<a class="code" href="classEventPacket.html#o3">zStart</a> += (jStartOut-event.<a class="code" href="classEventPacket.html#o0">jstart</a>)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00489     event.<a class="code" href="classEventPacket.html#o0">jstart</a> = jStartOut;
00490     event.<a class="code" href="classEventPacket.html#o1">jstop</a> = jStopOut;
00491     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00492   }
00493 }
00494 
<a name="l00509"></a><a class="code" href="classMOLAR.html#a4">00509</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classMOLAR.html#a4">MOLAR::boundaryCheckingFwdProjectEventY</a>(<a class="code" href="classImage.html">Image</a> &amp;mu,<a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; QMask, 
00510                                                 <a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; lambdaMask,
00511                                            <a class="code" href="classEventPacket.html">EventPacket</a> &amp;event, 
00512                                            <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR,
00513                                            <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, 
00514                                            Params &amp;params, 
00515                                            <span class="keywordtype">bool</span> exponentiate)
00516 {
00517   <span class="comment">//int boundaryBackOff = params.algorithm.boundaryBackOff;</span>
00518 
00519   <span class="comment">//intersection with phantom on primary direction</span>
00520   <span class="keywordtype">int</span> jStartOut=event.<a class="code" href="classEventPacket.html#o1">jstop</a>,jStopOut=event.<a class="code" href="classEventPacket.html#o0">jstart</a>;
00521   <span class="comment">//loop ints</span>
00522   <span class="keywordtype">int</span> jx, jy, jz;
00523   <span class="comment">//voxel centers</span>
00524   <span class="keywordtype">int</span> jxCentral, jzCentral;
00525   <span class="comment">//deviation from voxel centers</span>
00526   <span class="keywordtype">float</span> dxCentral, dzCentral;
00527   <span class="comment">//start points and increasments on R and U direction</span>
00528   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
00529   <span class="comment">//indices of resolution functions</span>
00530   <span class="keywordtype">int</span> kIndexR, kIndexU;
00531   <span class="comment">//x and z coordinates</span>
00532   <span class="keywordtype">float</span> x, z;
00533   <span class="comment">//intermeidate variable</span>
00534   <span class="comment">//float partial_yhat=0, yhat = 0;</span>
00535   <span class="comment">//save the valud of event.jstart and event.jstop</span>
00536   <span class="keywordtype">int</span> jStartSave = event.<a class="code" href="classEventPacket.html#o0">jstart</a>, jStopSave = event.<a class="code" href="classEventPacket.html#o1">jstop</a>;
00537 
00538   <span class="comment">//get x and z</span>
00539   x = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
00540   z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
00541   <span class="keywordtype">int</span> discardit = 1;
00542   <span class="keywordflow">for</span>(jy=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jy&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jy++){
00543     <span class="comment">//center of the voxel</span>
00544     jxCentral = (<span class="keywordtype">int</span>)floor(x);
00545     jzCentral = (<span class="keywordtype">int</span>)floor(z);
00546 
00547     <span class="comment">//assign jx and jz</span>
00548     jx=jxCentral;
00549     jz=jzCentral;
00550 
00551     <span class="comment">//get indices of resolution functions</span>
00552     <span class="comment">//kIndexR = resFunR.kCentralIndex;</span>
00553     <span class="comment">//kIndexU = resFunU.kCentralIndex;</span>
00554 
00555     <span class="comment">//partial_yhat = resFunR.kernel[kIndexR]*resFunU.kernel[kIndexU]* </span>
00556     <span class="comment">//  mu(jx,jy,jz);</span>
00557     <span class="comment">//partial_yhat = mu(jx,jy,jz);</span>
00558     <span class="comment">//boundary checking</span>
00559     <span class="comment">// old way - use attenuation image directly - now use QMask image</span>
00560     <span class="comment">//if (partial_yhat &gt; params.attenuation.threshold)</span>
00561     <span class="comment">// Qmask decides whether it is kept, lambdaMask decides the bounds</span>
00562     <span class="keywordflow">if</span> (QMask(jx,jy,jz) &gt; 0)
00563       {
00564       discardit = 0;
00565       } 
00566     <span class="keywordflow">if</span> (lambdaMask(jx,jy,jz) &gt; 0)
00567       {
00568         jStartOut = min( jStartOut,jy);
00569         jStopOut = max( jStopOut,jy);
00570       } 
00571     x += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
00572     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00573     <span class="comment">//yhat += partial_yhat;</span>
00574       
00575   }
00576   <span class="comment">//event.yhat = yhat;</span>
00577 
00578   <span class="comment">//renew boundary</span>
00579   <span class="keywordflow">if</span>( discardit){
00580     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00581   }
00582   <span class="keywordflow">else</span>
00583     {
00584       <span class="comment">// used to expand by 2 boundary BackOff (twice as far as lambda expanded</span>
00585       <span class="comment">//jStartOut = max((jStartOut - 2*boundaryBackOff), jStartSave);</span>
00586       <span class="comment">//jStopOut = min((jStopOut+2*boundaryBackOff), jStopSave);</span>
00587       jStartOut = max(jStartOut , jStartSave);
00588       jStopOut = min(jStopOut, jStopSave);
00589       event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a> +=(jStartOut-event.<a class="code" href="classEventPacket.html#o0">jstart</a>)*
00590         event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
00591       event.<a class="code" href="classEventPacket.html#o3">zStart</a> += (jStartOut-event.<a class="code" href="classEventPacket.html#o0">jstart</a>)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00592       event.<a class="code" href="classEventPacket.html#o0">jstart</a> = jStartOut;
00593       event.<a class="code" href="classEventPacket.html#o1">jstop</a> = jStopOut;
00594       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00595     }
00596 }
00597 
00598 
00599 
<a name="l00612"></a><a class="code" href="classMOLAR.html#a5">00612</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a5">MOLAR::fwdProject</a>(<a class="code" href="classImage.html">Image</a> &amp;mu, Params &amp;params,  
00613                       <a class="code" href="classEventList.html">EventList</a> &amp;eventList, <span class="keywordtype">bool</span> exponentiate)
00614 {
00615   <span class="comment">//update status file</span>
00616   timeFwdProj1 = time((time_t *) 0);
00617 
00618   Status *status = Status::getStatus();
00619   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> &amp;scannerParams=*<a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00620   <span class="comment">//paramter for solid angle correction</span>
00621   <span class="keywordtype">float</span> d0 = scannerParams.<a class="code" href="classHRRTScannerParams.html#o6">panelSeparation</a>/2.0;
00622   <span class="keywordtype">float</span> omega[params.geometry.nX];<span class="comment">//dummy solid angle correction coefficient</span>
00623   <span class="keywordtype">float</span> dl; <span class="comment">//paramter for attenuation</span>
00624   <span class="keywordtype">float</span> sumCij; 
00625 
00626   <span class="keywordflow">if</span>(status-&gt;proc==0){
00627     stringstream ss;
00628     ss&lt;&lt;<span class="stringliteral">"================================="</span>&lt;&lt;endl;
00629     ss&lt;&lt;<span class="stringliteral">"Forward projection"</span>&lt;&lt;endl;
00630     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00631     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(ss.str(),FRAME, 0);
00632     string comm=ss.str();
00633     Status::StatusCode code=Status::RUNNING;
00634     status-&gt;update(comm,code);
00635   }
00636 
00637   <a class="code" href="structResolutionTable.html">ResolutionTable</a> resFunR, resFunU; <span class="comment">//resolution functions</span>
00638   <span class="keywordtype">int</span> subset; <span class="comment">//sub-list of the event list</span>
00639   <a class="code" href="classEventPacket.html">EventPacket</a> event; <span class="comment">//event attracted from the event lise</span>
00640   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); <span class="comment">//prepare for sentry</span>
00641   <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got   </span>
00642   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> averageStart = 0, averageStop=0;
00643   <span class="comment">// create dummy omega vector so no correction is applied</span>
00644   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jx=0; jx&lt;=params.geometry.nX; jx++){
00645     omega[jx]=1.0;
00646   }
00647 
00648   <span class="keywordflow">for</span>(subset=0;subset&lt;params.algorithm.numSets;subset++){
00649     event = eventList.<a class="code" href="classEventList.html#a3">getFirst</a>(subset);<span class="comment">//Get first event</span>
00650     <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got</span>
00651     <span class="keywordflow">while</span> (!(event==sentry)) {
00652       <span class="comment">//get resolution functions of the event</span>
00653       resFunR = house-&gt;getResFunR(event.<a class="code" href="classEventPacket.html#o6">resModelCodeR</a>);
00654       resFunU = house-&gt;getResFunZ(event.<a class="code" href="classEventPacket.html#o7">resModelCodeZ</a>);
00655       <span class="comment">//forward project</span>
00656       <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o22">sinphi</a> &gt; Constant::SIN45) {<span class="comment">//x is primary direction</span>
00657         <span class="comment">// not correct here - dl = fwdProjectSolidAngleEventX(event, params,d0,omega);</span>
00658         dl =sqrt(POW2((params.geometry.dX))+
00659                   POW2((params.geometry.dY*event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>))+
00660                   POW2((params.geometry.dZ)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>));
00661         sumCij = <a class="code" href="classMOLAR.html#a6">fwdProjectEventX</a>(mu,event,resFunR,resFunU,params,omega);
00662 
00663       }
00664       <span class="keywordflow">else</span> { <span class="comment">//y is primary direction</span>
00665         dl =sqrt(POW2((params.geometry.dY))+
00666                   POW2((params.geometry.dX*event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>))+
00667                   POW2((params.geometry.dZ)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>));
00668         <span class="comment">// not correct here - dl = fwdProjectSolidAngleEventY(event, params, d0, omega);</span>
00669         sumCij = <a class="code" href="classMOLAR.html#a8">fwdProjectEventY</a>(mu,event,resFunR,resFunU,params,omega);
00670       }
00671       <span class="keywordflow">if</span>(exponentiate) {
00672         <span class="comment">// Exponentiate the integral of mu*dl</span>
00673         <span class="comment">//  Convert dl to units of mm so that mu will be in units of 1/mm</span>
00674         <span class="keywordtype">float</span> length = dl*(event.<a class="code" href="classEventPacket.html#o1">jstop</a>-event.<a class="code" href="classEventPacket.html#o0">jstart</a>+1);
00675         <span class="keywordflow">if</span>(sumCij != 0)
00676           event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> = length/sumCij;
00677         <span class="keywordflow">else</span>
00678           event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> = 0;
00679         event.<a class="code" href="classEventPacket.html#o10">atten</a> = exp(-event.<a class="code" href="classEventPacket.html#o18">yhat</a>*event.<a class="code" href="classEventPacket.html#o21">CijNorm</a>);
00680       }
00681       <span class="keywordflow">else</span>{
00682         <span class="comment">// case of no attenuation - simply calculate cijNorm    </span>
00683         <span class="keywordtype">float</span> length = dl*(event.<a class="code" href="classEventPacket.html#o1">jstop</a>-event.<a class="code" href="classEventPacket.html#o0">jstart</a>+1);
00684         <span class="keywordflow">if</span>(sumCij != 0)
00685           event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> = length/sumCij;
00686         <span class="keywordflow">else</span>
00687           event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> = 0;
00688           <span class="comment">// What is the purpose of the next statement - </span>
00689         event.<a class="code" href="classEventPacket.html#o18">yhat</a> = event.<a class="code" href="classEventPacket.html#o18">yhat</a> * event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> * event.<a class="code" href="classEventPacket.html#o9">norm</a>*
00690           event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a> * event.<a class="code" href="classEventPacket.html#o10">atten</a> +event.<a class="code" href="classEventPacket.html#o8">rand</a> + event.<a class="code" href="classEventPacket.html#o11">scatter</a>;
00691       }
00692 
00693       eventList.<a class="code" href="classEventList.html#a7">replace</a>(subset,event);
00694       <span class="comment">//get next event</span>
00695       event = eventList.<a class="code" href="classEventList.html#a4">getNext</a>(subset);
00696       ++countT; <span class="comment">//increase count</span>
00697       <span class="keywordflow">if</span>(status-&gt;proc ==0){ 
00698         <span class="keywordflow">if</span>(countT%50000==0 &amp;&amp; params.frame.verbosity&gt;=2) 
00699           (cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">"  events out of "</span>
00700            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00701            &lt;&lt;<span class="stringliteral">" events forward projected"</span>&lt;&lt;endl).flush();
00702         <span class="comment">//if(event==sentry) (cout&lt;&lt;countT&lt;&lt;endl).flush();</span>
00703       } <span class="comment">//end if</span>
00704 
00705     }<span class="comment">//while loop</span>
00706     <span class="comment">//     averageStart=averageStart/countT;</span>
00707     <span class="comment">//     averageStop = averageStop/countT;</span>
00708    <span class="keywordflow">if</span>(status-&gt;proc ==0)
00709     cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">"  events out of "</span>
00710            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00711            &lt;&lt;<span class="stringliteral">" events forward projected"</span>&lt;&lt;endl;
00712   } <span class="comment">//for loop - subset</span>
00713   timeFwdProj2 = time((time_t *) 0);
00714   timeFwdProj = difftime(timeFwdProj2, timeFwdProj1);
00715   <span class="keywordflow">if</span>(status-&gt;proc == 0){
00716     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00717     stringstream msg;
00718     msg &lt;&lt; <span class="stringliteral">"Forward projection takes "</span>&lt;&lt; timeFwdProj&lt;&lt; <span class="stringliteral">" s"</span>&lt;&lt;endl;
00719     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(msg.str(),ATTENUATION, 2);
00720   }
00721  
00722 }
00723 
<a name="l00728"></a><a class="code" href="classMOLAR.html#a9">00728</a> <span class="keywordtype">float</span> <a class="code" href="classMOLAR.html#a9">MOLAR::fwdProjectSolidAngleEventX</a>(<a class="code" href="classEventPacket.html">EventPacket</a> &amp;event, 
00729                                        Params &amp;params, 
00730                                        <span class="keywordtype">float</span> &amp; d0, <span class="keywordtype">float</span> omega[])
00731 {
00732   <span class="keywordtype">float</span>  dl =sqrt(POW2((params.geometry.dX))+
00733                   POW2((params.geometry.dY*event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>))+
00734                   POW2((params.geometry.dZ)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>));
00735   <span class="keywordtype">float</span> dmid = sqrt(POW2((event.<a class="code" href="classEventPacket.html#o15">x2</a>-event.<a class="code" href="classEventPacket.html#o12">x1</a>))+POW2((event.<a class="code" href="classEventPacket.html#o16">y2</a>-event.<a class="code" href="classEventPacket.html#o13">y1</a>))+
00736                     POW2((event.<a class="code" href="classEventPacket.html#o17">z2</a>-event.<a class="code" href="classEventPacket.html#o14">z1</a>)))/2.0;
00737   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jx=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jx&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jx++){
00738     <span class="comment">//solid angle correction</span>
00739     <span class="comment">//omega[jx]=POW2((d0/(dmid+dl*fabs(jx-event.jmid))));</span>
00740     omega[jx]=2.*POW2(d0)/(POW2(dmid+dl*(jx-event.<a class="code" href="classEventPacket.html#o28">jmid</a>))+POW2(dmid-dl*(jx-event.<a class="code" href="classEventPacket.html#o28">jmid</a>)));
00741     <span class="comment">//omega[jx]=1;</span>
00742   }
00743   <span class="keywordflow">return</span> dl;
00744 }
00745 
<a name="l00751"></a><a class="code" href="classMOLAR.html#a10">00751</a> <span class="keywordtype">float</span> <a class="code" href="classMOLAR.html#a10">MOLAR::fwdProjectSolidAngleEventY</a>(<a class="code" href="classEventPacket.html">EventPacket</a> &amp;event, 
00752                                        Params &amp;params, 
00753                                        <span class="keywordtype">float</span> &amp; d0, <span class="keywordtype">float</span> omega[])
00754 {
00755   <span class="keywordtype">float</span>  dl =sqrt(POW2((params.geometry.dY))+
00756                   POW2((params.geometry.dX*event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>))+
00757                   POW2((params.geometry.dZ)*event.<a class="code" href="classEventPacket.html#o5">zStep</a>));
00758   <span class="keywordtype">float</span> dmid = sqrt(POW2((event.<a class="code" href="classEventPacket.html#o15">x2</a>-event.<a class="code" href="classEventPacket.html#o12">x1</a>))+
00759                     POW2((event.<a class="code" href="classEventPacket.html#o16">y2</a>-event.<a class="code" href="classEventPacket.html#o13">y1</a>))+
00760                     POW2((event.<a class="code" href="classEventPacket.html#o17">z2</a>-event.<a class="code" href="classEventPacket.html#o14">z1</a>)))/2.0;
00761   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jy=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jy&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jy++){
00762     <span class="comment">//solid angle correction</span>
00763     <span class="comment">//omega[jy]=POW2((d0/(dmid+dl*fabs(jy-event.jmid))));</span>
00764     omega[jy]=2.*POW2(d0)/(POW2(dmid+dl*(jy-event.<a class="code" href="classEventPacket.html#o28">jmid</a>))+POW2(dmid-dl*(jy-event.<a class="code" href="classEventPacket.html#o28">jmid</a>)));
00765     <span class="comment">//omega[jy]=1;</span>
00766   }
00767   <span class="keywordflow">return</span> dl;
00768 }
00769 <span class="comment">/* This function performs a foward projection with the solid angle correction</span>
00770 <span class="comment">   It is used for calculating the expected event for each simulated LOR */</span>
<a name="l00771"></a><a class="code" href="classMOLAR.html#a7">00771</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a7">MOLAR::fwdProjectSolidAngle</a>(<a class="code" href="classImage.html">Image</a> &amp;lambda, Params &amp;params,  
00772                       <a class="code" href="classEventList.html">EventList</a> &amp;eventList)
00773 {
00774   <span class="comment">//update status file</span>
00775   Status *status = Status::getStatus();
00776   
00777   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> &amp;scannerParams=*<a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00778   <a class="code" href="classFourDReconstruction.html">FourDReconstruction</a> *fourd= <a class="code" href="classFourDReconstruction.html#e0">FourDReconstruction::getFourD</a>();;
00779   <span class="comment">// DO not know how to do this only for 4D simulation</span>
00780   <span class="comment">//if (params.algorithm.name == "simulation" &amp;&amp; params.algorithm.algorithmKeys=="4D") {</span>
00781   <span class="comment">//  *fourd = FourDReconstruction::getFourD();</span>
00782   <span class="comment">//}</span>
00783   <span class="comment">//paramter for solid angle correction</span>
00784   <span class="keywordtype">float</span> d0 = scannerParams.<a class="code" href="classHRRTScannerParams.html#o6">panelSeparation</a>/2.0;
00785   <span class="keywordtype">float</span> omega[params.geometry.nX];<span class="comment">//dummy solid angle correction coefficient</span>
00786 
00787   <span class="keywordflow">if</span>(status-&gt;proc==0){
00788     stringstream ss;
00789     ss&lt;&lt;<span class="stringliteral">"================================="</span>&lt;&lt;endl;
00790     ss&lt;&lt;<span class="stringliteral">"Forward projection"</span>&lt;&lt;endl;
00791     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00792     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(ss.str(),FRAME, 0);
00793     string comm=ss.str();
00794     Status::StatusCode code=Status::RUNNING;
00795     status-&gt;update(comm,code);
00796   }
00797 
00798   <a class="code" href="structResolutionTable.html">ResolutionTable</a> resFunR, resFunU; <span class="comment">//resolution functions</span>
00799   <span class="keywordtype">int</span> subset; <span class="comment">//sub-list of the event list</span>
00800   <a class="code" href="classEventPacket.html">EventPacket</a> event; <span class="comment">//event attracted from the event lise</span>
00801   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); <span class="comment">//prepare for sentry</span>
00802   <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got   </span>
00803   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> averageStart = 0, averageStop=0;
00804 
00805   <span class="keywordflow">for</span>(subset=0;subset&lt;params.algorithm.numSets;subset++){
00806     event = eventList.<a class="code" href="classEventList.html#a3">getFirst</a>(subset);<span class="comment">//Get first event</span>
00807     <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got</span>
00808     <span class="keywordflow">while</span> (!(event==sentry)) {
00809     
00810       <span class="comment">// update lambda if doing 4D simulation (whl- 04/15/07)</span>
00811        
00812       <span class="keywordflow">if</span> (params.algorithm.name == <span class="stringliteral">"simulation"</span> &amp;&amp; params.algorithm.algorithmKeys==<span class="stringliteral">"4D"</span>) {
00813         fourd-&gt;<a class="code" href="classFourDReconstruction.html#a3">updatelambda</a>(lambda,event,params);       
00814       }
00815  
00816       <span class="comment">//get resolution functions of the event</span>
00817       resFunR = house-&gt;getResFunR(event.<a class="code" href="classEventPacket.html#o6">resModelCodeR</a>);
00818       resFunU = house-&gt;getResFunZ(event.<a class="code" href="classEventPacket.html#o7">resModelCodeZ</a>);
00819       <span class="comment">//forward project</span>
00820       <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o22">sinphi</a> &gt; Constant::SIN45) {<span class="comment">//x is primary direction</span>
00821         <a class="code" href="classMOLAR.html#a9">fwdProjectSolidAngleEventX</a>(event, params,d0,omega);
00822         <a class="code" href="classMOLAR.html#a6">fwdProjectEventX</a>(lambda,event,resFunR,resFunU,params,omega);
00823 
00824       }
00825       <span class="keywordflow">else</span> { <span class="comment">//y is primary direction</span>
00826         <a class="code" href="classMOLAR.html#a10">fwdProjectSolidAngleEventY</a>(event, params, d0, omega);
00827         <a class="code" href="classMOLAR.html#a8">fwdProjectEventY</a>(lambda,event,resFunR,resFunU,params,omega);
00828       }
00829       event.<a class="code" href="classEventPacket.html#o18">yhat</a> = event.<a class="code" href="classEventPacket.html#o18">yhat</a> * event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> * event.<a class="code" href="classEventPacket.html#o9">norm</a>*
00830           event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a> * event.<a class="code" href="classEventPacket.html#o10">atten</a> +event.<a class="code" href="classEventPacket.html#o8">rand</a> + event.<a class="code" href="classEventPacket.html#o11">scatter</a>;
00831 
00832       eventList.<a class="code" href="classEventList.html#a7">replace</a>(subset,event);
00833       <span class="comment">//get next event</span>
00834       event = eventList.<a class="code" href="classEventList.html#a4">getNext</a>(subset);
00835 
00836       ++countT; <span class="comment">//increase count</span>
00837       <span class="keywordflow">if</span>(status-&gt;proc ==0){ 
00838         <span class="keywordflow">if</span>(countT%50000==0 &amp;&amp; params.frame.verbosity&gt;=2) 
00839           (cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">"  events out of "</span>
00840            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00841            &lt;&lt;<span class="stringliteral">" events forward projected"</span>&lt;&lt;endl).flush();
00842         <span class="comment">//if(event==sentry) (cout&lt;&lt;countT&lt;&lt;endl).flush();</span>
00843       } <span class="comment">//end if</span>
00844 
00845     }<span class="comment">//while loop</span>
00846     <span class="comment">//     averageStart=averageStart/countT;</span>
00847     <span class="comment">//     averageStop = averageStop/countT;</span>
00848     <span class="keywordflow">if</span>(status-&gt;proc ==0)
00849      cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">"  events out of "</span>
00850            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
00851            &lt;&lt;<span class="stringliteral">" events forward projected"</span>&lt;&lt;endl;
00852   } <span class="comment">//for loop - subset</span>
00853   <span class="keywordflow">if</span>(status-&gt;proc == 0){
00854     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
00855     stringstream msg;
00856     msg &lt;&lt; <span class="stringliteral">"Forward projection takes "</span>&lt;&lt; timeFwdProj&lt;&lt; <span class="stringliteral">" s"</span>&lt;&lt;endl;
00857     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(msg.str(),ATTENUATION, 2);
00858   }
00859  
00860 }
00861 
00862   
<a name="l00874"></a><a class="code" href="classMOLAR.html#a6">00874</a> <span class="keywordtype">float</span> <a class="code" href="classMOLAR.html#a6">MOLAR::fwdProjectEventX</a>(<a class="code" href="classImage.html">Image</a> &amp;mu, <a class="code" href="classEventPacket.html">EventPacket</a> &amp;event, 
00875                              <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, 
00876                              <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, 
00877                              Params &amp; params, <span class="keywordtype">float</span> omega[])
00878 {
00879   <span class="comment">//spreads in y and z direction</span>
00880   <span class="keywordtype">int</span> downYSpread, upYSpread, downZSpread, upZSpread;
00881   <span class="comment">//loop ints</span>
00882   <span class="keywordtype">int</span> jx, jy, jz;
00883   <span class="comment">//voxel centers</span>
00884   <span class="keywordtype">int</span> jyCentral, jzCentral;
00885   <span class="comment">//deviation from voxel centers</span>
00886   <span class="keywordtype">float</span> dyCentral, dzCentral;
00887   <span class="comment">//table stuct to determine the size of quadrue</span>
00888   <a class="code" href="structMOLAR_1_1Table.html">Table</a> table;
00889   <span class="comment">//start points and increasments on R and U direction</span>
00890   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
00891   <span class="comment">//indices of resolution functions</span>
00892   <span class="keywordtype">int</span> kIndexR, kIndexU;
00893   <span class="keywordtype">float</span> kIndexUstart;
00894 
00895   <span class="comment">//intermeidate variable</span>
00896   <span class="comment">//float dl, dmid,omega, cijNorm, length;</span>
00897   <span class="keywordtype">float</span> yhat = 0, sumCij = 0;
00898   <span class="comment">//calculate the spreads of the quad</span>
00899   <span class="keywordtype">float</span> resFunRTable[params.geometry.nY], 
00900     resFunUTable[params.geometry.nZ];
00901   downYSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o22">sinphi</a>);
00902   upYSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o22">sinphi</a>);
00903   downZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
00904   upZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
00905   <span class="comment">//y and z starting points</span>
00906   <span class="keywordtype">float</span> y = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
00907   <span class="keywordtype">float</span> z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
00908 
00909   <span class="keywordflow">for</span>(jx=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jx&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jx++){
00910     <span class="comment">//solid angle correction</span>
00911     <span class="comment">// omega=POW2((d0/(dmid+dl*fabs(jx-event.jmid))));</span>
00912     <span class="comment">//center of the voxel</span>
00913     jyCentral = (<span class="keywordtype">int</span>)(y); <span class="comment">//we have maken sure that floor(y)&gt;0</span>
00914     jzCentral = (<span class="keywordtype">int</span>)(z); <span class="comment">//we have maken sure that floor(z)&gt;0</span>
00915     <span class="comment">//deviations from the center</span>
00916     dyCentral = jyCentral+0.5-y; <span class="comment">//+0.5 to transfer image index to </span>
00917                                  <span class="comment">//image coordinate system</span>
00918     dzCentral = jzCentral+0.5-z;
00919     <span class="comment">//calculate the size of the quad</span>
00920     table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a> = jyCentral - downYSpread;
00921     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>&lt;0){
00922       table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>=0;
00923     }
00924     table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a> = jyCentral + upYSpread;
00925     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>&gt;params.geometry.nY-1){
00926       table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>=params.geometry.nY-1;
00927       <span class="comment">//       cout&lt;&lt;"table.secondaryStop greater nY "&lt;&lt;endl;</span>
00928     }
00929     table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a> = jzCentral - downZSpread;
00930     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>&lt;0){
00931       table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>=0;
00932       <span class="comment">//       cout&lt;&lt;"table.zStart less than 0 in X"&lt;&lt;endl;</span>
00933     }
00934     table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> = jzCentral + upZSpread;
00935     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> &gt; params.geometry.nZ-1){
00936       table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>= params.geometry.nZ-1;
00937       <span class="comment">//       cout&lt;&lt;"table.zStop greater than nZ in X"&lt;&lt;endl;</span>
00938     }
00939     <span class="comment">//start points</span>
00940     dRStart = (dyCentral - downYSpread) * event.<a class="code" href="classEventPacket.html#o22">sinphi</a>;
00941     dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
00942     dR=dRStart;
00943     <span class="keywordflow">for</span>(jy=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jy&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jy++){
00944       <span class="comment">//get kernel index and value at R direction</span>
00945       kIndexR = resFunR.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
00946         (<span class="keywordtype">int</span>)floor(dR*resFunR.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
00947       resFunRTable[jy]=resFunR.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexR];
00948       dR += event.<a class="code" href="classEventPacket.html#o22">sinphi</a>;
00949       <span class="comment">//end test</span>
00950     }
00951     dU = dUStart;
00952     <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++){ 
00953 
00954       <span class="comment">//get kernel index and value at U direction</span>
00955       kIndexU = resFunU.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
00956         (<span class="keywordtype">int</span>)floor(dU * resFunU.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
00957       resFunUTable[jz]=resFunU.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexU];
00958       <span class="comment">// next value is not strictly costheta if voxels are not cubic</span>
00959       dU += event.<a class="code" href="classEventPacket.html#o24">costheta</a>;                     
00960 
00961     }
00962     <span class="keywordflow">for</span>(jy=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jy&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jy++){    
00963       <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++){ 
00964         <span class="comment">//foward projection</span>
00965         <span class="keywordtype">float</span> kernel = resFunRTable[jy]*resFunUTable[jz];
00966         
00967         <span class="comment">//float kernelU = resFunUTable[jz];</span>
00968         <span class="keywordtype">float</span> muValue = mu.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx];
00969         yhat += kernel*muValue*omega[jx];
00970         sumCij += kernel;
00971 
00972       }
00973     }
00974     y += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>; 
00975     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00976   }
00977   event.<a class="code" href="classEventPacket.html#o18">yhat</a> = yhat;
00978   <span class="keywordflow">return</span> sumCij;
00979 }
00980 
<a name="l00992"></a><a class="code" href="classMOLAR.html#a8">00992</a> <span class="keywordtype">float</span> <a class="code" href="classMOLAR.html#a8">MOLAR::fwdProjectEventY</a>(<a class="code" href="classImage.html">Image</a> &amp;mu, <a class="code" href="classEventPacket.html">EventPacket</a> &amp;event, 
00993                              <a class="code" href="structResolutionTable.html">ResolutionTable</a> 
00994                              &amp;resFunR, <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU,
00995                              Params &amp; params, <span class="keywordtype">float</span> omega[])
00996 {
00997   <span class="comment">//spreads in x and z direction</span>
00998   <span class="keywordtype">int</span> downXSpread, upXSpread, downZSpread, upZSpread;
00999   <span class="comment">//intermidiate variables</span>
01000   <span class="comment">//float dl, dmid,omega,cijNorm, length;</span>
01001   <span class="comment">//yhat and CijNomr</span>
01002   <span class="keywordtype">float</span> yhat = 0, sumCij = 0;
01003   <span class="comment">//loop variables</span>
01004   <span class="keywordtype">int</span>  jx, jy, jz;
01005   <span class="comment">//x z coordinates</span>
01006   <span class="keywordtype">float</span> x,z;
01007   <span class="comment">//voxel centers</span>
01008   <span class="keywordtype">int</span> jxCentral, jzCentral;
01009   <span class="comment">//voxel diviations</span>
01010   <span class="keywordtype">float</span>  dxCentral, dzCentral;
01011   <a class="code" href="structMOLAR_1_1Table.html">Table</a> table;
01012   <span class="comment">//starting points</span>
01013   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
01014   <span class="comment">//index of kernel</span>
01015   <span class="keywordtype">int</span> kIndexR, kIndexU;
01016   <span class="comment">//resolution function kernel table</span>
01017   <span class="keywordtype">float</span> resFunRTable[params.geometry.nX],
01018     resFunUTable[params.geometry.nZ]; 
01019   downXSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o23">cosphi</a>);
01020   upXSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o23">cosphi</a>);
01021   downZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01022   upZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01023 
01024   x = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
01025   z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
01026   <span class="keywordflow">for</span>(jy=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jy&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jy++){
01027     <span class="comment">//solid angle correction</span>
01028     <span class="comment">// omega=POW2((d0/(dmid+dl*fabs(jy-event.jmid))));</span>
01029 
01030     jxCentral = (<span class="keywordtype">int</span>)(x);<span class="comment">//we have maken sure that floor(x)&gt;=0</span>
01031     jzCentral = (<span class="keywordtype">int</span>)(z);<span class="comment">//we have maken sure that floor(z)&gt;=0</span>
01032     dxCentral = jxCentral+0.5-x; <span class="comment">//+0.5 to transfer image index </span>
01033                                  <span class="comment">//to image coordinate system</span>
01034     dzCentral = jzCentral+0.5-z;
01035     table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a> = jxCentral - downXSpread;<span class="comment">//int</span>
01036     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>&lt;0) {
01037       table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>=0;
01038       <span class="comment">// cout&lt;&lt;"table.secondaryStart less than 0 in Y"&lt;&lt;endl;</span>
01039     }
01040     table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a> = jxCentral + upXSpread;
01041     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>&gt;params.geometry.nX-1){
01042       table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>=params.geometry.nX-1;
01043     }
01044     table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a> = jzCentral - downZSpread;
01045     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>&lt;0){
01046       table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>=0;
01047       <span class="comment">//       cout&lt;&lt;"table.zStart less than 0 in Y"&lt;&lt;endl;</span>
01048     }
01049     table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> = jzCentral + upZSpread;
01050     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> &gt; params.geometry.nZ-1){
01051       table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>=params.geometry.nZ-1;
01052       <span class="comment">//       cout&lt;&lt;"talbe.zStop greater than nZ in Y"&lt;&lt;endl;</span>
01053     }
01054     dRStart = (dxCentral - downXSpread) * event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
01055     dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
01056 
01057     <span class="comment">//calculate the kernel of resolution function R</span>
01058     dR=dRStart;
01059     <span class="keywordflow">for</span>(jx=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jx&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jx++){
01060       kIndexR = resFunR.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01061         (<span class="keywordtype">int</span>)floor(dR*resFunR.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01062       resFunRTable[jx]=resFunR.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexR];
01063       dR += event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
01064     }
01065     <span class="comment">//calculate the kernel of resolution function U</span>
01066     dU = dUStart;
01067     <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;= table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++) {
01068       kIndexU = resFunU.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01069         (<span class="keywordtype">int</span>)floor(dU * resFunU.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01070       resFunUTable[jz]=resFunU.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexU];
01071       <span class="comment">// next value is not strictly costheta if voxels are not cubic</span>
01072       dU += event.<a class="code" href="classEventPacket.html#o24">costheta</a>;  
01073     }
01074     <span class="keywordflow">for</span>(jx=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jx&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jx++){  
01075       <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;= table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++) {    
01076    
01077         <span class="keywordtype">float</span> kernel =  resFunRTable[jx]*resFunUTable[jz];
01078         <span class="keywordtype">float</span> muValue= mu.z[jy][jz][jx];
01079        
01080         yhat +=kernel* muValue*omega[jy];
01081         sumCij +=  kernel;
01082       }
01083     }
01084     <span class="comment">//next </span>
01085     x += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
01086     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
01087   }
01088   event.<a class="code" href="classEventPacket.html#o18">yhat</a> = yhat;
01089   <span class="comment">//temp set for simulation</span>
01090 
01091   <span class="keywordflow">return</span> sumCij;
01092 }
01093 
01094 
01095 
01096 
01097 
<a name="l01107"></a><a class="code" href="classMOLAR.html#a11">01107</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a11">MOLAR::backProjectQ</a>(<a class="code" href="classImage.html">Image</a> &amp;Q, Params &amp;params,  
01108                         <a class="code" href="classEventList.html">EventList</a> &amp;eventList)
01109 {
01110   <span class="comment">//update status file</span>
01111   Status *status = Status::getStatus();
01112   
01113   
01114   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> &amp;scannerParams=*<a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
01115   <span class="comment">//paramter for solid angle correction</span>
01116   <span class="keywordtype">float</span> d0 = scannerParams.<a class="code" href="classHRRTScannerParams.html#o6">panelSeparation</a>/2.0;
01117   <span class="keywordtype">float</span> omega[params.geometry.nX];<span class="comment">//solid angle correction coefficient</span>
01118   <span class="keywordtype">float</span> dl; <span class="comment">//paramter for solid angle correction and attenuation</span>
01119   <span class="keywordtype">float</span> sumCij; 
01120   <span class="keywordflow">if</span>(status-&gt;proc==0){
01121     stringstream ss;
01122     ss&lt;&lt;<span class="stringliteral">"================================="</span>&lt;&lt;endl;
01123     ss&lt;&lt;<span class="stringliteral">"Back projection Q"</span>&lt;&lt;endl;
01124     <a class="code" href="classLog.html">Log</a> * log = <a class="code" href="classLog.html#e0">Log::getLog</a>();
01125     log-&gt;<a class="code" href="classLog.html#a2">outputMessage</a>(ss.str(),FRAME, 0);
01126     string comm=ss.str();
01127     Status::StatusCode code=Status::RUNNING;
01128     status-&gt;update(comm,code);
01129   }
01130   <span class="comment">//count time</span>
01131   timeBackProjQ1 = time((time_t *) 0);
01132 
01133   <a class="code" href="structResolutionTable.html">ResolutionTable</a> resFunR, resFunU; <span class="comment">//resolution functions</span>
01134   <span class="keywordtype">int</span> subset; <span class="comment">//sub-list of the event list</span>
01135   <a class="code" href="classEventPacket.html">EventPacket</a> event; <span class="comment">//event attracted from the event lise</span>
01136   <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); <span class="comment">//prepare for sentry</span>
01137   <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got   </span>
01138   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> averageStart = 0, averageStop=0;
01139 
01140   <span class="keywordflow">for</span>(subset=0;subset&lt;params.algorithm.numSets;subset++){
01141     event = eventList.<a class="code" href="classEventList.html#a3">getFirst</a>(subset);<span class="comment">//Get first event</span>
01142     <span class="keywordtype">int</span> countT = 0; <span class="comment">//count the number of the event got</span>
01143     <span class="keywordflow">while</span> (!(event==sentry)) {
01144       <span class="comment">//get resolution functions of the event</span>
01145       resFunR = house-&gt;getResFunR(event.<a class="code" href="classEventPacket.html#o6">resModelCodeR</a>);
01146       resFunU = house-&gt;getResFunZ(event.<a class="code" href="classEventPacket.html#o7">resModelCodeZ</a>);
01147       <span class="comment">//forward project</span>
01148       <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o22">sinphi</a> &gt; Constant::SIN45) {<span class="comment">//x is primary direction</span>
01149         <a class="code" href="classMOLAR.html#a9">fwdProjectSolidAngleEventX</a>(event, params,d0,omega);
01150         <a class="code" href="classMOLAR.html#a12">backProjectQEventX</a>(Q,event,resFunR,resFunU,params, omega);
01151 
01152       }
01153       <span class="keywordflow">else</span> { <span class="comment">//y is primary direction</span>
01154         <a class="code" href="classMOLAR.html#a10">fwdProjectSolidAngleEventY</a>(event, params,d0,omega);
01155         <a class="code" href="classMOLAR.html#a13">backProjectQEventY</a>(Q,event,resFunR,resFunU,params,omega);
01156       }
01157       ++countT; <span class="comment">//increase count</span>
01158       <span class="keywordflow">if</span>(status-&gt;proc ==0){ 
01159         <span class="keywordflow">if</span>(countT%50000==0 &amp;&amp; params.frame.verbosity&gt;=2) 
01160           (cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">" events out of "</span>
01161            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
01162            &lt;&lt;<span class="stringliteral">"  back projected"</span>&lt;&lt;endl).flush();
01163       }
01164       event = eventList.<a class="code" href="classEventList.html#a4">getNext</a>(subset);
01165     }
01166     <span class="keywordflow">if</span>(status-&gt;proc ==0)
01167      cout&lt;&lt;<span class="stringliteral">"Subset "</span>&lt;&lt;subset&lt;&lt;<span class="stringliteral">": "</span>&lt;&lt;countT&lt;&lt;<span class="stringliteral">" events out of "</span>
01168            &lt;&lt;eventList.<a class="code" href="classEventList.html#a12">getNumEvents</a>(subset)
01169            &lt;&lt;<span class="stringliteral">"  back projected"</span>&lt;&lt;endl;
01170   } 
01171 
01172   MPI::COMM_WORLD.Barrier(); <span class="comment">//prepare processes</span>
01173 
01174   timeBackProjQ2 = time((time_t *) 0);
01175   timeBackProjQ = difftime(timeBackProjQ2,timeBackProjQ1);
01176 
01177   timeGlobalSum1 = time((time_t *) 0);
01178   <span class="comment">//global sum of Q slice by slice</span>
01179   countT =0;
01180   Q.globalSum(params);
01181   MPI::COMM_WORLD.Barrier(); <span class="comment">//prepare processes</span>
01182 
01183   timeGlobalSum2 = time((time_t *) 0);
01184   timeGlobalSum = difftime(timeGlobalSum2,timeGlobalSum1);
01185 
01186 }
01187   
<a name="l01197"></a><a class="code" href="classMOLAR.html#a12">01197</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a12">MOLAR::backProjectQEventX</a>(<a class="code" href="classImage.html">Image</a> &amp;Q, <a class="code" href="classEventPacket.html">EventPacket</a> &amp;event, 
01198                               <a class="code" href="structResolutionTable.html">ResolutionTable</a>  &amp;resFunR, 
01199                               <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, 
01200                               Params &amp; params, <span class="keywordtype">float</span> omega[])
01201 {
01202   <span class="comment">//spreads in y and z direction</span>
01203   <span class="keywordtype">int</span> downYSpread, upYSpread, downZSpread, upZSpread;
01204   <span class="comment">//loop ints</span>
01205   <span class="keywordtype">int</span> jx, jy, jz;
01206   <span class="comment">//voxel centers</span>
01207   <span class="keywordtype">int</span> jyCentral, jzCentral;
01208   <span class="comment">//deviation from voxel centers</span>
01209   <span class="keywordtype">float</span> dyCentral, dzCentral;
01210   <span class="comment">//table stuct to determine the size of quadrue</span>
01211   <a class="code" href="structMOLAR_1_1Table.html">Table</a> table;
01212   <span class="comment">//start points and increasments on R and U direction</span>
01213   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
01214   <span class="comment">//indices of resolution functions</span>
01215   <span class="keywordtype">int</span> kIndexR, kIndexU;
01216   <span class="keywordtype">float</span> kIndexUstart;
01217 
01218   <span class="comment">//intermeidate variable</span>
01219   <span class="comment">//float dl, dmid,omega, cijNorm, length;</span>
01220   <span class="keywordtype">float</span> yhat = 0, sumCij = 0;
01221   <span class="comment">//calculate the spreads of the quadraue</span>
01222   <span class="keywordtype">float</span> resFunRTable[params.geometry.nY], 
01223     resFunUTable[params.geometry.nZ];
01224   <span class="keywordtype">float</span> normFct = event.<a class="code" href="classEventPacket.html#o10">atten</a>*event.<a class="code" href="classEventPacket.html#o9">norm</a>*event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>*event.<a class="code" href="classEventPacket.html#o21">CijNorm</a>;
01225 
01226 
01227   downYSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o22">sinphi</a>);
01228   upYSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o22">sinphi</a>);
01229   downZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01230   upZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01231   <span class="comment">//y and z starting points</span>
01232   <span class="keywordtype">float</span> y = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
01233   <span class="keywordtype">float</span> z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
01234 
01235   <span class="keywordflow">for</span>(jx=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jx&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jx++){
01236     <span class="comment">//solid angle correction</span>
01237     <span class="comment">// omega=POW2((d0/(dmid+dl*fabs(jx-event.jmid))));</span>
01238     <span class="comment">//center of the voxel</span>
01239     jyCentral = (<span class="keywordtype">int</span>)(y); <span class="comment">//we have maken sure that floor(y)&gt;0</span>
01240     jzCentral = (<span class="keywordtype">int</span>)(z); <span class="comment">//we have maken sure that floor(z)&gt;0</span>
01241     <span class="comment">//deviations from the center</span>
01242     dyCentral = jyCentral+0.5-y; <span class="comment">//+0.5 to transfer image index </span>
01243                                  <span class="comment">//to image coordinate system</span>
01244     dzCentral = jzCentral+0.5-z;
01245     <span class="comment">//calculate the size of the quad</span>
01246     table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a> = jyCentral - downYSpread;
01247     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>&lt;0){
01248       table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>=0;
01249     }
01250     table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a> = jyCentral + upYSpread;
01251     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>&gt;params.geometry.nY-1){
01252       table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>=params.geometry.nY-1;
01253       <span class="comment">//       cout&lt;&lt;"table.secondaryStop greater nY "&lt;&lt;endl;</span>
01254     }
01255     table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a> = jzCentral - downZSpread;
01256     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>&lt;0){
01257       table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>=0;
01258       <span class="comment">//       cout&lt;&lt;"table.zStart less than 0 in X"&lt;&lt;endl;</span>
01259     }
01260     table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> = jzCentral + upZSpread;
01261     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> &gt; params.geometry.nZ-1){
01262       table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>= params.geometry.nZ-1;
01263       <span class="comment">//       cout&lt;&lt;"table.zStop greater than nZ in X"&lt;&lt;endl;</span>
01264     }
01265     <span class="comment">//start points</span>
01266     dRStart = (dyCentral - downYSpread) * event.<a class="code" href="classEventPacket.html#o22">sinphi</a>;
01267     dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
01268     dR=dRStart;
01269     <span class="keywordflow">for</span>(jy=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jy&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jy++){
01270       <span class="comment">//get kernel index and value at R direction</span>
01271       kIndexR = resFunR.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01272         (<span class="keywordtype">int</span>)floor(dR*resFunR.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01273       resFunRTable[jy]=resFunR.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexR];
01274       dR += event.<a class="code" href="classEventPacket.html#o22">sinphi</a>;
01275       <span class="comment">//end test</span>
01276     }
01277     dU = dUStart;
01278     <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++){ 
01279 
01280       <span class="comment">//get kernel index and value at U direction</span>
01281       kIndexU = resFunU.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01282         (<span class="keywordtype">int</span>)floor(dU * resFunU.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01283       resFunUTable[jz]=resFunU.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexU];
01284       <span class="comment">// next value is not strictly costheta if voxels are not cubic</span>
01285       dU += event.<a class="code" href="classEventPacket.html#o24">costheta</a>;                     
01286 
01287     }
01288     <span class="keywordflow">for</span>(jy=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jy&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jy++){    
01289       <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++){ 
01290         <span class="comment">//foward projection</span>
01291         <span class="keywordtype">float</span> kernel = resFunRTable[jy]*resFunUTable[jz];
01292         
01293         Q.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx] += kernel*normFct*omega[jx];
01294 
01295       }
01296     }
01297     y += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>; 
01298     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
01299   }
01300 }
01301 
<a name="l01312"></a><a class="code" href="classMOLAR.html#a13">01312</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a13">MOLAR::backProjectQEventY</a>(<a class="code" href="classImage.html">Image</a> &amp;Q, <a class="code" href="classEventPacket.html">EventPacket</a> &amp;event, 
01313                               <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, 
01314                               <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, 
01315                               Params &amp; params, <span class="keywordtype">float</span> omega[])
01316 {
01317   <span class="comment">//spreads in x and z direction</span>
01318   <span class="keywordtype">int</span> downXSpread, upXSpread, downZSpread, upZSpread;
01319   <span class="comment">//intermidiate variables</span>
01320   <span class="comment">//float dl, dmid,omega,cijNorm, length;</span>
01321   <span class="comment">//yhat and CijNomr</span>
01322   <span class="keywordtype">float</span> yhat = 0, sumCij = 0;
01323   <span class="comment">//loop variables</span>
01324   <span class="keywordtype">int</span>  jx, jy, jz;
01325   <span class="comment">//x z coordinates</span>
01326   <span class="keywordtype">float</span> x,z;
01327   <span class="comment">//voxel centers</span>
01328   <span class="keywordtype">int</span> jxCentral, jzCentral;
01329   <span class="comment">//voxel diviations</span>
01330   <span class="keywordtype">float</span>  dxCentral, dzCentral;
01331   <a class="code" href="structMOLAR_1_1Table.html">Table</a> table;
01332   <span class="comment">//starting points</span>
01333   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
01334   <span class="comment">//index of kernel</span>
01335   <span class="keywordtype">int</span> kIndexR, kIndexU;
01336   <span class="comment">//resolution function kernel table</span>
01337   <span class="keywordtype">float</span> resFunRTable[params.geometry.nX],
01338     resFunUTable[params.geometry.nZ]; 
01339 
01340   <span class="keywordtype">float</span> normFct = event.<a class="code" href="classEventPacket.html#o10">atten</a>*event.<a class="code" href="classEventPacket.html#o9">norm</a>*event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>*event.<a class="code" href="classEventPacket.html#o21">CijNorm</a>;
01341 
01342   downXSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o23">cosphi</a>);
01343   upXSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o23">cosphi</a>);
01344   downZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01345   upZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
01346 
01347   x = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
01348   z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
01349   <span class="keywordflow">for</span>(jy=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jy&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jy++){
01350     <span class="comment">//solid angle correction</span>
01351     <span class="comment">// omega=POW2((d0/(dmid+dl*fabs(jy-event.jmid))));</span>
01352 
01353     jxCentral = (<span class="keywordtype">int</span>)(x);<span class="comment">//we have maken sure that floor(x)&gt;=0</span>
01354     jzCentral = (<span class="keywordtype">int</span>)(z);<span class="comment">//we have maken sure that floor(z)&gt;=0</span>
01355     dxCentral = jxCentral+0.5-x; <span class="comment">//+0.5 to transfer image index to </span>
01356     <span class="comment">//image coordinate system</span>
01357     dzCentral = jzCentral+0.5-z;
01358     table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a> = jxCentral - downXSpread;<span class="comment">//int</span>
01359     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>&lt;0) {
01360       table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>=0;
01361       <span class="comment">// cout&lt;&lt;"table.secondaryStart less than 0 in Y"&lt;&lt;endl;</span>
01362     }
01363     table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a> = jxCentral + upXSpread;
01364     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>&gt;params.geometry.nX-1){
01365       table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>=params.geometry.nX-1;
01366     }
01367     table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a> = jzCentral - downZSpread;
01368     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>&lt;0){
01369       table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>=0;
01370       <span class="comment">//       cout&lt;&lt;"table.zStart less than 0 in Y"&lt;&lt;endl;</span>
01371     }
01372     table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> = jzCentral + upZSpread;
01373     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> &gt; params.geometry.nZ-1){
01374       table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>=params.geometry.nZ-1;
01375       <span class="comment">//       cout&lt;&lt;"talbe.zStop greater than nZ in Y"&lt;&lt;endl;</span>
01376     }
01377     dRStart = (dxCentral - downXSpread) * event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
01378     dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
01379 
01380     <span class="comment">//calculate the kernel of resolution function R</span>
01381     dR=dRStart;
01382     <span class="keywordflow">for</span>(jx=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jx&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jx++){
01383       kIndexR = resFunR.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01384         (<span class="keywordtype">int</span>)floor(dR*resFunR.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01385       resFunRTable[jx]=resFunR.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexR];
01386       dR += event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
01387     }
01388     <span class="comment">//calculate the kernel of resolution function U</span>
01389     dU = dUStart;
01390     <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;= table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++) {
01391       kIndexU = resFunU.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
01392         (<span class="keywordtype">int</span>)floor(dU * resFunU.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
01393       resFunUTable[jz]=resFunU.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexU];
01394       <span class="comment">// next value is not strictly costheta if voxels are not cubic</span>
01395       dU += event.<a class="code" href="classEventPacket.html#o24">costheta</a>;  
01396     }
01397     <span class="keywordflow">for</span>(jx=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jx&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jx++){  
01398       <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;= table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++) {    
01399    
01400         <span class="keywordtype">float</span> kernel =  resFunRTable[jx]*resFunUTable[jz];
01401         
01402         Q.z[jy][jz][jx] +=kernel* normFct*omega[jy];
01403       }
01404     }
01405     <span class="comment">//next </span>
01406     x += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
01407     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
01408   }
01409 }
01410 
<a name="l01424"></a><a class="code" href="classMOLAR.html#a18">01424</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a18">MOLAR::computeQ</a>(<a class="code" href="classImage.html">Image</a> &amp;Q, Params &amp;params,   
01425                     <a class="code" href="classEventList.html">EventList</a> &amp;eventList)
01426 {
01427  
01428   <span class="comment">//back projection Q</span>
01429   <a class="code" href="classMOLAR.html#a11">backProjectQ</a>(Q, params, eventList);
01430   <span class="keywordtype">float</span> totalEvents;
01431   Status *status = Status::getStatus();
01432   <span class="keywordflow">if</span>(status-&gt;proc == 0)
01433     totalEvents = house-&gt;getAcceptedEvents() +house-&gt;getRejectedEvents();
01434   MPI::COMM_WORLD.Barrier();
01435   MPI::COMM_WORLD.Bcast(&amp;totalEvents, 1, MPI::FLOAT, 0);
01436 
01437   <span class="comment">//post process of Q</span>
01438   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; iy &lt; params.geometry.nY; iy++)
01439     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0; iz &lt; params.geometry.nZ; iz++)
01440       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix = 0; ix&lt; params.geometry.nX; ix++)
01441         Q(ix,iy,iz) *= ((<span class="keywordtype">float</span>)house-&gt;getTotalPossibleEvents()
01442                         /(totalEvents*params.algorithm.numSets));
01443 }
<a name="l01456"></a><a class="code" href="classMOLAR.html#a19">01456</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a19">MOLAR::smoothQ</a>(<a class="code" href="classImage.html">Image</a> &amp;Q,<a class="code" href="classImage.html">Image</a> &amp;mu)
01457 { 
01458   Params &amp;params= *Params::getInstance();
01459   <span class="keywordflow">if</span> (params.algorithm.Q_fwhmx != 0) {
01460     <span class="keywordtype">int</span> midx,widthx;
01461     midx= int(1.5* params.algorithm.Q_fwhmx+0.99);
01462     widthx=2*midx+1;
01463     <span class="keywordtype">double</span> total=0;
01464     <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> kernelx(widthx);
01465     <a class="code" href="classImage.html">Image</a> Qsmoothx(params.geometry.nX,params.geometry.nY,params.geometry.nZ);
01466     for (<span class="keywordtype">int</span> i=0;i&lt;widthx;i++){
01467       <span class="comment">//smoothing kernel in x</span>
01468       kernelx(i) = (1/(sqrt(2*Constant::PI)* params.algorithm.Q_fwhmx/2.35))*exp(-0.5*(POW2(i-midx)/POW2(params.algorithm.Q_fwhmx/2.35)));
01469       total+=kernelx(i);
01470     }
01471     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;widthx;i++){
01472       <span class="comment">//normalizing the smoothing kernel in x</span>
01473       kernelx(i) /= total;
01474     }
01475     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0;k&lt;params.geometry.nZ;k++){
01476       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;params.geometry.nY;j++){
01477         for (<span class="keywordtype">int</span> i=0;i&lt;params.geometry.nX;i++){
01478           Qsmoothx(i,j,k)=0;
01479           <span class="comment">// control bounts of kernel so as not to run over the edge of the image   </span>
01480           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii=max(0,midx-i);ii&lt;min(params.geometry.nX+midx-i,widthx);ii++){
01481             <span class="comment">// calculate the smoothed Q value for each voxel along x</span>
01482             Qsmoothx(i,j,k)+=Q(i-midx+ii,j,k)*kernelx(ii);
01483           }
01484         }
01485       }
01486     }
01487     <span class="comment">// smoothing of Q produces large biases IF Q is changing "rapidly"</span>
01488     <span class="comment">// Remember that errors in Q get multiplied MANY  times in lambda.</span>
01489     <span class="comment">//  This only seems to happen on the edge of the mu mask if we have</span>
01490     <span class="comment">// included/excluded LORs (i.e. enabled bounds check)</span>
01491     <span class="comment">//</span>
01492     <span class="comment">// Therefore, only use the smoothed Qs inside the object</span>
01493     <span class="comment">//</span>
01494     <span class="comment">// It is likely that there will still be hot edges on the edge of the FOV</span>
01495     <span class="comment">// if there is no attenuation or bounds check is off</span>
01496     <span class="keywordflow">if</span> (params.attenuation.enable &amp;&amp; params.frame.enableBoundsCheck) {
01497      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0;iz &lt; params.geometry.nZ; iz++)
01498       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0;iy &lt; params.geometry.nY; iy++)
01499        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0;ix &lt; params.geometry.nX; ix++)
01500         <span class="keywordflow">if</span>(mu(ix,iy,iz)&gt;params.attenuation.threshold) {
01501          Q(ix,iy,iz)=Qsmoothx(ix,iy,iz);
01502         }
01503     }  <span class="keywordflow">else</span> Q=Qsmoothx;
01504   }
01505   
01506   <span class="keywordflow">if</span> (params.algorithm.Q_fwhmy != 0) {
01507     <span class="keywordtype">int</span> midy,widthy;
01508     midy=<span class="keywordtype">int</span>(1.5* params.algorithm.Q_fwhmy+0.99);
01509     widthy=2*midy+1;
01510     <span class="keywordtype">double</span> total=0;
01511     <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> kernely(widthy);
01512     Image Qsmoothy(params.geometry.nX,params.geometry.nY,params.geometry.nZ);
01513     for (<span class="keywordtype">int</span> j=0;j&lt;widthy;j++){
01514       <span class="comment">//smoothing kernel in y</span>
01515       kernely(j) = (1/(sqrt(2*Constant::PI)* params.algorithm.Q_fwhmy/2.35))*exp(-0.5*(POW2(j-midy)/POW2(params.algorithm.Q_fwhmy/2.35)));
01516       total+=kernely(j);
01517     }
01518     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;widthy;j++){
01519       <span class="comment">//normalizing the smoothing kernel in y</span>
01520       kernely(j) /= total;
01521     }    
01522     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0;k&lt;params.geometry.nZ;k++){
01523       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;params.geometry.nX;i++){
01524         for (<span class="keywordtype">int</span> j=0;j&lt;params.geometry.nY;j++){
01525           Qsmoothy(i,j,k)=0;
01526           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj=max(0,midy-j);jj&lt;min(params.geometry.nY+midy-j,widthy);jj++){
01527             <span class="comment">// calculate the smoothed Q value for each voxel along y</span>
01528             Qsmoothy(i,j,k)+=Q(i,j-midy+jj,k)*kernely(jj);
01529           }
01530         }
01531       }
01532     }
01533     <span class="keywordflow">if</span> (params.attenuation.enable &amp;&amp; params.frame.enableBoundsCheck) {
01534      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0;iz &lt; params.geometry.nZ; iz++)
01535       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0;iy &lt; params.geometry.nY; iy++)
01536        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0;ix &lt; params.geometry.nX; ix++)
01537         <span class="keywordflow">if</span>(mu(ix,iy,iz)&gt;params.attenuation.threshold) {
01538          Q(ix,iy,iz)=Qsmoothy(ix,iy,iz);
01539         }
01540     } <span class="keywordflow">else</span> Q=Qsmoothy;
01541     
01542   }
01543   
01544   <span class="keywordflow">if</span> (params.algorithm.Q_fwhmz!= 0) {
01545     <span class="comment">// special code for Z smooth to handle the edge slices</span>
01546     <span class="comment">// taper the kernel down toward the edge slice - this avoids averaging with 0's outside the FOV</span>
01547     <span class="keywordtype">int</span> midz,widthz,midz1,widthz1;
01548     <span class="keywordtype">double</span> total=0;
01549     midz=<span class="keywordtype">int</span>(1.5* params.algorithm.Q_fwhmz+0.99);
01550     widthz=2*midz+1;
01551     <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> kernelz(widthz);
01552     Image Qsmoothz(params.geometry.nX,params.geometry.nY,params.geometry.nZ);
01553     <span class="comment">//  </span>
01554     for (<span class="keywordtype">int</span> k=0;k&lt;params.geometry.nZ;k++){
01555      <span class="comment">// Build the kernel for this slice. Be sure it fits in remaining slices</span>
01556       midz1=min(midz,min(k,params.geometry.nZ-1-k));
01557       widthz1=2*midz1+1;
01558       total=0.;
01559       for (<span class="keywordtype">int</span> kk=0;kk&lt;widthz1;kk++){
01560         <span class="comment">//smoothing kernel in z</span>
01561         kernelz(kk) = (1/(sqrt(2*Constant::PI)* params.algorithm.Q_fwhmz/2.35))*exp(-0.5*(POW2(kk-midz1)/POW2(params.algorithm.Q_fwhmz/2.35)));
01562         total+=kernelz(kk);
01563       }
01564       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kk=0;kk&lt;widthz1;kk++){
01565         <span class="comment">//normalizing the smoothing kernel in z</span>
01566         kernelz(kk) /= total;
01567       }
01568      
01569       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;params.geometry.nY;j++){
01570         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;params.geometry.nX;i++){
01571           Qsmoothz(i,j,k)=0;
01572           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kk=0;kk&lt;widthz1;kk++){
01573             <span class="comment">// calculate the smoothed Q value for each voxel along z</span>
01574             Qsmoothz(i,j,k)+=Q(i,j,k-midz1+kk)*kernelz(kk);
01575           }
01576         }
01577       }
01578     }
01579     <span class="keywordflow">if</span> (params.attenuation.enable &amp;&amp; params.frame.enableBoundsCheck) {
01580      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0;iz &lt; params.geometry.nZ; iz++)
01581       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0;iy &lt; params.geometry.nY; iy++)
01582        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0;ix &lt; params.geometry.nX; ix++)
01583         <span class="keywordflow">if</span>(mu(ix,iy,iz)&gt;params.attenuation.threshold) {
01584          Q(ix,iy,iz)=Qsmoothz(ix,iy,iz);
01585         }
01586     }  <span class="keywordflow">else</span> Q=Qsmoothz; 
01587 
01588   }
01589 }
<a name="l01596"></a><a class="code" href="classMOLAR.html#a20">01596</a> <span class="keywordtype">void</span> MOLAR::initializeLambda(Image &amp; lambda, <a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; lambdaMask, 
01597                             Params &amp; params)
01598 {
01599   <span class="keywordtype">float</span> initLambda;
01600   <span class="keywordflow">if</span>(params.algorithm.initialValue&gt;0)
01601     initLambda = params.algorithm.initialValue;
01602   <span class="keywordflow">else</span>
01603     initLambda = Constant::INITLAMBDA;
01604   
01605   <span class="keywordflow">if</span>(params.algorithm.enableInitLambdaMasking)
01606     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; iy&lt;params.geometry.nY; iy++)
01607       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0; iz &lt; params.geometry.nZ; iz++)
01608         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0; ix&lt; params.geometry.nX; ix++){
01609           lambda(ix,iy,iz) = initLambda*lambdaMask(ix,iy,iz);
01610         }
01611   <span class="keywordflow">else</span>
01612     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; iy&lt;params.geometry.nY; iy++)
01613       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0; iz &lt; params.geometry.nZ; iz++)
01614         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0; ix&lt; params.geometry.nX; ix++){
01615           lambda(ix,iy,iz) = initLambda;
01616         }
01617 
01618 }
01619 
01620 
01621 
01622 
<a name="l01637"></a><a class="code" href="classMOLAR.html#a21">01637</a> <span class="keywordtype">void</span> MOLAR::calculateMask(<a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; lambdaMask, Image &amp; Q, Params &amp; params)
01638 {
01639   QAve = Q.<a class="code" href="classArray3D.html#a17">average</a>();
01640   <span class="keywordtype">float</span> thresholdInSlice = (params.algorithm.Qthreshold*10&gt;
01641                           Constant:: PERCENTMASKQSLICE )?
01642     Constant:: PERCENTMASKQSLICE : params.algorithm.Qthreshold;
01643   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0; iz &lt; params.geometry.nZ; iz++){
01644     <span class="keywordtype">float</span> QAveSlice = Q.<a class="code" href="classImage.html#a13">getSliceAverage</a>(iz);
01645     <span class="comment">//the threshold among slices </span>
01646     <span class="keywordflow">if</span>(QAveSlice&lt;=  params.algorithm.Qthreshold*<a class="code" href="classMOLAR.html#o16">QAve</a>){
01647       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; iy&lt;params.geometry.nY; iy++)
01648         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0; ix&lt; params.geometry.nX; ix++){
01649           lambdaMask(ix,iy,iz) = 0;
01650         }
01651     }
01652     <span class="keywordflow">else</span>{
01653       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; iy&lt;params.geometry.nY; iy++)
01654         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0; ix&lt; params.geometry.nX; ix++){
01655           <span class="comment">//the threshold in a slice</span>
01656           <span class="keywordflow">if</span>(Q(ix,iy,iz)&lt;=thresholdInSlice*QAveSlice)
01657             lambdaMask(ix,iy,iz) = 0;
01658           <span class="keywordflow">else</span>
01659             lambdaMask(ix,iy,iz) = 1;
01660         }
01661     }
01662   }
01663 }
<a name="l01675"></a><a class="code" href="classMOLAR.html#a22">01675</a> <span class="keywordtype">void</span> <a class="code" href="classMOLAR.html#a22">MOLAR::calculateMaskMu</a>(<a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; QMask, <a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; lambdaMask,
01676          Image &amp; mu, Params &amp; params)
01677 {
01678   Status *status = Status::getStatus();
01679   <span class="keywordtype">int</span> boundaryBackOff = params.algorithm.boundaryBackOff[0];
01680   <span class="keywordflow">if</span> (params.frame.verbosity &gt;= 2 &amp;&amp; status-&gt;proc == 0) {
01681    cout&lt;&lt;<span class="stringliteral">"Creating lambdaMask with backOff "</span>&lt;&lt;boundaryBackOff&lt;&lt;endl;
01682   }
01683   lambdaMask = 0.0;
01684   <span class="comment">// be sure the mask for lambda is trimmed to be the FOV_r</span>
01685   <span class="comment">// grown for the difference in dilate sizes of the 2 masks</span>
01686   <span class="keywordtype">int</span> fovr = params.geometry.FOV_r + 
01687    2*(params.algorithm.boundaryBackOff[0]-params.algorithm.boundaryBackOff[1]);
01688   dilateMask(<span class="stringliteral">"lambda"</span>,lambdaMask,mu,boundaryBackOff,params,fovr);
01689   
01690   boundaryBackOff = params.algorithm.boundaryBackOff[1];
01691   <span class="keywordflow">if</span> (params.frame.verbosity &gt;= 2 &amp;&amp; status-&gt;proc == 0) {
01692    cout&lt;&lt;<span class="stringliteral">"Creating QMask with backOff "</span>&lt;&lt;boundaryBackOff&lt;&lt;endl;
01693   }
01694   QMask = 0.0;
01695    fovr = params.geometry.FOV_r;
01696   dilateMask(<span class="stringliteral">"Q"</span>,QMask,mu,boundaryBackOff,params,fovr);
01766 }
01767 <span class="keywordtype">void</span> MOLAR::dilateMask(string MaskName,<a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> &amp; <a class="code" href="classMask.html">Mask</a>, Image &amp; mu, <span class="keywordtype">int</span> boundaryBackOff,
01768         Params &amp; params, <span class="keywordtype">int</span> fovr)
01769 {
01770   <span class="comment">// Assume lambdaMask and Qmask has been pre-initialized to 0</span>
01771    <span class="comment">// build lambdaMask by dilating mu</span>
01772    <span class="comment">// This logic could possibly produce interesting inconsistencies on the edge slices</span>
01773    <span class="keywordtype">int</span> nedge; 
01774    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0;iz &lt; params.geometry.nZ; iz++)
01775     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0;iy &lt; params.geometry.nY; iy++)
01776      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0;ix &lt; params.geometry.nX; ix++)
01777       <span class="keywordflow">if</span>(mu(ix,iy,iz)&gt;params.attenuation.threshold) {
01778         Mask(ix,iy,iz)=1;
01779         <span class="comment">// if this voxel has a direct neighbor (6 of them) that is 0, then do the erode from here</span>
01780         <span class="comment">// If I am an edge voxel, that automatically erode</span>
01781         <span class="comment">// otherwise, it is a waste of time, i.le., one of the edge voxels will work</span>
01782         nedge=0;
01783         <span class="keywordflow">if</span> ((ix &gt; 0) &amp;&amp;(ix &lt; params.geometry.nX-1) &amp;&amp; 
01784             (iy &gt; 0) &amp;&amp;(iy &lt; params.geometry.nY-1) &amp;&amp; 
01785             (iz &gt; 0) &amp;&amp;(iz &lt; params.geometry.nZ-1)) {
01786          <span class="keywordflow">if</span>(mu(ix+1,iy,iz)&gt;params.attenuation.threshold) nedge++;
01787          <span class="keywordflow">if</span>(mu(ix-1,iy,iz)&gt;params.attenuation.threshold) nedge++;
01788          <span class="keywordflow">if</span>(mu(ix,iy+1,iz)&gt;params.attenuation.threshold) nedge++;
01789          <span class="keywordflow">if</span>(mu(ix,iy-1,iz)&gt;params.attenuation.threshold) nedge++;
01790          <span class="keywordflow">if</span>(mu(ix,iy,iz+1)&gt;params.attenuation.threshold) nedge++;
01791          <span class="keywordflow">if</span>(mu(ix,iy,iz-1)&gt;params.attenuation.threshold) nedge++;
01792         }
01793         <span class="keywordflow">if</span> (nedge &lt; 6) {
01794          <span class="comment">// dilate from this voxel</span>
01795          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jz = max(0,iz-boundaryBackOff);jz &lt; min(params.geometry.nZ,iz+boundaryBackOff+1); jz++)
01796           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jy = max(0,iy-boundaryBackOff);jy &lt; min(params.geometry.nY,iy+boundaryBackOff+1); jy++)
01797            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> jx = max(0,ix-boundaryBackOff);jx &lt; min(params.geometry.nX,ix+boundaryBackOff+1); jx++) {
01798             <span class="comment">//spherical operaot</span>
01799             <span class="keywordflow">if</span> (POW2(iz-jz)+POW2(iy-jy)+POW2(ix-jx) &lt;= POW2(boundaryBackOff))
01800                 Mask(jx,jy,jz)=1;
01801            }
01802          }      <span class="comment">// do the dilate here</span>
01803        }        <span class="comment">// main voxel loop</span>
01804     <span class="comment">// now trim the mask to the requested radial fov</span>
01805     <span class="keywordtype">float</span> r2max=POW2(fovr/2.0);
01806     <span class="keywordtype">float</span> xmid = (params.geometry.nX-1)/2.0;
01807     <span class="keywordtype">float</span> ymid = (params.geometry.nY-1)/2.0;
01808     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0;iz &lt; params.geometry.nZ; iz++)
01809      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0;iy &lt; params.geometry.nY; iy++)
01810       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0;ix &lt; params.geometry.nX; ix++) 
01811        <span class="keywordflow">if</span> (POW2(ix-xmid) + POW2(iy-ymid)&gt; r2max) 
01812         Mask(ix,iy,iz) = 0;
01813        <span class="comment">// add diagnostics</span>
01814     Status *status = Status::getStatus();
01815     <span class="keywordflow">if</span> (params.frame.verbosity &gt;= 2 &amp;&amp; status-&gt;proc == 0) {
01816      <span class="keywordtype">int</span> numMask=0;
01817      <span class="keywordtype">int</span> zmin=params.geometry.nZ;
01818      <span class="keywordtype">int</span> zmax=0;
01819      <span class="keywordtype">int</span> nummu=0;
01820      <span class="keywordtype">int</span> zminmu=params.geometry.nZ;
01821      <span class="keywordtype">int</span> zmaxmu=0;
01822      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iz = 0;
01823          iz &lt; params.geometry.nZ; iz++)
01824       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iy = 0; 
01825           iy &lt; params.geometry.nY; iy++)
01826        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ix =0; 
01827            ix &lt; params.geometry.nX; ix++) {
01828         <span class="keywordflow">if</span> (Mask(ix,iy,iz)) {
01829                 numMask++;
01830                 <span class="keywordflow">if</span> (iz &lt; zmin) zmin=iz;
01831                 <span class="keywordflow">if</span> (iz &gt; zmax) zmax=iz;
01832                 }
01833         <span class="keywordflow">if</span> (mu(ix,iy,iz)&gt;params.attenuation.threshold) {
01834                 nummu++;
01835                 <span class="keywordflow">if</span> (iz &lt; zminmu) zminmu=iz;
01836                 <span class="keywordflow">if</span> (iz &gt; zmaxmu) zmaxmu=iz;
01837                 }
01838         }
01839       cout&lt;&lt;MaskName&lt;&lt;<span class="stringliteral">"Mask has "</span>&lt;&lt;numMask
01840        &lt;&lt;<span class="stringliteral">" nonzero  voxels from slice "</span>&lt;&lt;zmin&lt;&lt;<span class="stringliteral">" to "</span>&lt;&lt;zmax&lt;&lt;endl;
01841       cout&lt;&lt;<span class="stringliteral">"mu has "</span>&lt;&lt;nummu
01842        &lt;&lt;<span class="stringliteral">" nonzero  voxels from slice "</span>&lt;&lt;zminmu&lt;&lt;<span class="stringliteral">" to "</span>&lt;&lt;zmaxmu&lt;&lt;endl;
01843      }
01844 }
01845 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Dec 13 14:13:48 2007 for reconHRRT by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
