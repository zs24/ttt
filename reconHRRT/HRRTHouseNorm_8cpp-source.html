<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>reconHRRT: HRRTHouseNorm.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>HRRTHouseNorm.cpp</h1><div class="fragment"><pre>00001 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00002 <span class="preprocessor">#include &lt;string.h&gt;</span>
00003 <span class="preprocessor">#include &lt;sstream&gt;</span>
00004 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00005 <span class="preprocessor">#include "HRRTHouse.hpp"</span>
00006 <span class="preprocessor">#include "Status.hpp"</span>
00007 <span class="preprocessor">#include "ResolutionFunction.hpp"</span>
00008 <span class="preprocessor">#include "IsoGaussian.hpp"</span>
00009 <span class="preprocessor">#include "Utilities.hpp"</span>
00010 <span class="preprocessor">#include "Constant.hpp"</span>
00011 <span class="preprocessor">#include "TOC.hpp"</span>
00012 
00013 
00014 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00015 
00016 <span class="comment">//---------------------------------------------------------------------</span>
00017 <span class="comment">// NAME</span>
00018 <span class="comment">//              setHrrtDtct()</span>
00019 <span class="comment">//DESCRIPTION</span>
00020 <span class="comment">//              set detector coordinates (xd, yd,zd) </span>
00021 <span class="comment">//              xd, yd, zd are detector coordinates </span>
00022 <span class="comment">//      this program generates crystal coordinates with the</span>
00023 <span class="comment">//              exact specification of the scanner</span>
00024 <span class="comment">//              the scanner-&gt;dtctPitch from xml file is ignored</span>
00025 <span class="comment">//---------------------------------------------------------------------</span>
00026 <span class="keywordtype">void</span> HRRTHouseNorm::setHrrtDtct()
00027 {
00028     <span class="comment">//check if the pointer initialized when use it</span>
00029   Status * status= Status::getStatus();
00030   <span class="keywordflow">if</span>(!checkValid()){
00031     <span class="keywordflow">if</span>(status-&gt;proc==0){
00032       cout&lt;&lt;<span class="stringliteral">"Error in use of HRRTHouseNorm"</span>
00033           &lt;&lt;<span class="stringliteral">"Programmer make sure call the getInstance"</span>
00034           &lt;&lt;<span class="stringliteral">"Program aborted"</span>&lt;&lt;endl;
00035       cout.flush();
00036     }
00037     <a class="code" href="classUtilities.html#e8">Utilities::cleanUp</a>(Constant::POINTERERROR);
00038   }
00039   
00040   <span class="keywordtype">float</span> r1,r2,halfd,half; <span class="comment">//inter variables</span>
00041   <span class="keyword">const</span> <span class="keywordtype">float</span> cvtrad = 3.14159265/180.0; 
00042   <span class="comment">//transform factor from degree to rad</span>
00043   <span class="keywordtype">int</span> i,j,k,p; <span class="comment">//loop ints</span>
00044         
00045   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> *scanner = <a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00046   <span class="comment">//init xd, yd , with dimension (detector number </span>
00047   <span class="comment">//in transaxle direction, </span>
00048   <span class="comment">//number of layer, number of bank)</span>
00049   xd.init(scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>);
00050   yd.init(scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>);
00051   <span class="comment">//init zd with dimension dectector number in axle direction)</span>
00052   zd.init(scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o12">nRing</a>);
00053 
00054 
00055   r1 = scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o6">panelSeparation</a>/2.0; <span class="comment">//inner radias</span>
00056   r2 = r1 + scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o8">dtctDepth1</a>+scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o9">dtctDepth2</a>;<span class="comment">//outer radias</span>
00057         
00058   <span class="comment">//crystal dimension in a block</span>
00059   <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> dx(scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>);
00060   dx(0)=dx(scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>-1)=scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o25">endDtctPitch</a>;
00061   <span class="keywordflow">for</span>(i=1;i&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>-1;i++)
00062     dx(i) = scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o26">middleDtctPitch</a>;
00063         
00064   <span class="comment">//gaps in block</span>
00065   <span class="keywordtype">float</span> gapWithinBlock = scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o27">gapWithinBlock</a> ;
00066   <span class="keywordtype">float</span> gapBetweenBlock = scanner-&gt; gapBetweenBlock;
00067         
00068   <span class="comment">//block dimension</span>
00069   <span class="keywordtype">float</span> db = dx.<a class="code" href="classArray1D.html#a17">sum</a>()+gapWithinBlock*(scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>-1);
00070         
00071   <span class="comment">//offset from the center of the panel, = panel dimension (in x) /2</span>
00072   <span class="keywordtype">float</span> offset = (db*scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o1">blockPerBankX</a>+gapBetweenBlock*
00073                   (scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o1">blockPerBankX</a>-1))/2.0;
00074         
00075   <span class="comment">//compute xd and yd for panel 0</span>
00076   <span class="keywordflow">for</span>(i=0;i&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o1">blockPerBankX</a>; i++)
00077     <span class="keywordflow">for</span>(j=0;j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>; j++)
00078       {
00079         xd(i*scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>+j,0,0) =
00080           xd(i*scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>+j,1,0)  
00081           = db*i+dx.<a class="code" href="classArray1D.html#a17">sum</a>(0,j)+gapBetweenBlock*i+
00082           gapWithinBlock*j-dx(j)/2.0- offset;
00083         yd(i*scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>+j,0,0) = r1 + scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o8">dtctDepth1</a>/2.0;
00084         yd(i*scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>+j,1,0) = r1 + scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o8">dtctDepth1</a>+
00085           scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o9">dtctDepth2</a>/2.0;
00086       }
00087                 
00088   <span class="comment">//rotate every 45 degrees to get xd and yd for the other 7 panels</span>
00089   <span class="keywordflow">for</span>(i=0;i&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>; i++)
00090     <span class="keywordflow">for</span>(k=1; k&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>; k++)
00091       {
00092         <span class="keywordtype">float</span> ang= 45.0*k*cvtrad; <span class="comment">//angle of the kth bank</span>
00093         xd(i,0,k) = cos(ang)*xd(i,0,0) + sin(ang)*yd(i,0,0);
00094         yd(i,0,k) = -sin(ang)*xd(i,0,0)+ cos(ang)*yd(i,0,0);
00095         xd(i,1,k) = cos(ang)*xd(i,1,0) + sin(ang)*yd(i,1,0);
00096         yd(i,1,k) = -sin(ang)*xd(i,1,0) + cos(ang)*yd(i,1,0);
00097       }
00098                 
00099   <span class="comment">//calculate zd, zoffset = panel dimension (in z) /2</span>
00100   <span class="keywordtype">float</span> zoffset = (db*scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o2">blockPerBankZ</a>+gapBetweenBlock*
00101                    (scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o2">blockPerBankZ</a>-1))/2.0;
00102   <span class="keywordflow">for</span>(i=0;i&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o2">blockPerBankZ</a>; i++)
00103     <span class="keywordflow">for</span>(j=0; j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>; j++)
00104       zd(i*scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>+j) = 
00105         db*i+dx.<a class="code" href="classArray1D.html#a17">sum</a>(0,j)+gapBetweenBlock*i+
00106         gapWithinBlock*j-dx(j)/2.0-zoffset;
00107 
00108   Params * params = Params::getInstance();
00109 
00110   <span class="keywordflow">if</span>(params-&gt;frame.verbosity&gt;=5) {
00111     cout&lt;&lt;db&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;offset*2&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;zoffset*2&lt;&lt;endl;
00112     cout&lt;&lt;xd(0,0,0)&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;xd(71,0,0)&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;xd(0,0,4)&lt;&lt;<span class="stringliteral">","</span>
00113         &lt;&lt;xd(71,0,4)&lt;&lt;endl;
00114     cout&lt;&lt;yd(0,0,0)&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;yd(20,0,2)&lt;&lt;<span class="stringliteral">","</span>
00115         &lt;&lt;yd(20,0,4)&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;yd(20,0,6)&lt;&lt;endl;
00116     cout&lt;&lt;zd(0)&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;zd(103)&lt;&lt;endl;
00117     <span class="comment">//output to a file for debug</span>
00118     ofstream fDtct(<span class="stringliteral">"houseDtct.dat"</span>);
00119     <span class="keywordflow">for</span> (k=0; k&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o12">nRing</a>;k++){
00120       <span class="keywordflow">for</span> (j=0; j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>; j++){
00121         <span class="keywordflow">for</span> (p=0; p&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>; p++)   {
00122           <span class="keywordflow">for</span> (i=0; i&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>; i++){
00123             fDtct&lt;&lt;xd(i,p,j)&lt;&lt;<span class="stringliteral">"  "</span>;                             
00124           }
00125           fDtct&lt;&lt;endl;
00126         }
00127       }
00128     }
00129     <span class="keywordflow">for</span> (k=0; k&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o12">nRing</a>;k++) {
00130       <span class="keywordflow">for</span> (j=0; j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>; j++) {
00131         <span class="keywordflow">for</span> (p=0; p&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>; p++){
00132           <span class="keywordflow">for</span> (i=0; i&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>; i++){
00133             fDtct&lt;&lt;yd(i,p,j)&lt;&lt;<span class="stringliteral">"  "</span>;                             
00134           }
00135           fDtct&lt;&lt;endl;
00136         }
00137       }
00138     }
00139     <span class="keywordflow">for</span> (k=0; k&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o12">nRing</a>;k++)  {
00140       <span class="keywordflow">for</span> (j=0; j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>; j++) {
00141         <span class="keywordflow">for</span> (p=0; p&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>; p++)  {
00142           <span class="keywordflow">for</span> (i=0; i&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>; i++)      {
00143             fDtct&lt;&lt;zd(k)&lt;&lt;<span class="stringliteral">"  "</span>;                         
00144           }
00145           fDtct&lt;&lt;endl;
00146         }
00147       }
00148     }
00149     fDtct.close();
00150   }
00151 
00152 }
00153 
00154 <span class="comment">//--------------------------------------------------------------------</span>
00156 <span class="comment"></span><span class="comment">//              calculateDtctSensitivity()</span>
00157 <span class="comment">//DESCRIPTION</span>
00158 <span class="comment">//              calculate detector normalization sensitivity functions</span>
00159 <span class="comment">//              at this moment, the sensitivity function was </span>
00160 <span class="comment">//              written in a binary file</span>
00161 <span class="comment">//              this function opens the file and read in the data</span>
00162 <span class="comment">//---------------------------------------------------------------------</span>
00163 <span class="keywordtype">void</span> HRRTHouseNorm::calculateDtctSensitivity()
00164 {
00165   <span class="comment">//check if the pointer initialized when use it</span>
00166   Status * status= Status::getStatus();
00167   <span class="keywordflow">if</span>(!checkValid()){
00168     <span class="keywordflow">if</span>(status-&gt;proc==0){
00169       cout&lt;&lt;<span class="stringliteral">"Error in use of HRRTScannerParams"</span>
00170           &lt;&lt;<span class="stringliteral">"Programmer make sure call the getInstance"</span>
00171           &lt;&lt;<span class="stringliteral">"Program aborted"</span>&lt;&lt;endl;
00172       cout.flush();
00173     }
00174     <a class="code" href="classUtilities.html#e8">Utilities::cleanUp</a>(Constant::POINTERERROR);
00175   }
00176   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> *scanner = <a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00177   Params *params = Params::getInstance();
00178   <span class="comment">//calculate sin cos look up table</span>
00179   <span class="keyword">const</span> <span class="keywordtype">float</span> cvtrad = 180.0/3.14159265;
00180   <span class="keywordtype">float</span> primary [] = {0,45,90,135,180,225,270,315}; <span class="comment">//angles                </span>
00181   <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; i&lt;<span class="keyword">sizeof</span>(primary)/<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>); i++){
00182     primary[i] = primary[i]/cvtrad;  <span class="comment">//transfrom to rad</span>
00183   }    
00184   SIN.init(scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>);
00185   COS.init(scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>);
00186   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>; i++){
00187     SIN(i) = sin(primary[i]);
00188     COS(i) = cos(primary[i]);
00189   }
00190 
00191 
00192   FILE * fSen; <span class="comment">//binary file pointer</span>
00193   <span class="keywordtype">float</span> * senTmp; <span class="comment">//temp variable</span>
00194   size_t senSize = scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>*scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>*
00195     scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>*scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o12">nRing</a>; <span class="comment">//size of the factors</span>
00196   <span class="keywordtype">int</span> i,j,k,p; <span class="comment">//loop int</span>
00197   senTmp = <span class="keyword">new</span> <span class="keywordtype">float</span>[senSize];
00198   sen.init(scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o12">nRing</a>);
00199   <span class="comment">//open file</span>
00200   string fileName = params-&gt;normalization.filePath+<span class="stringliteral">"/sensitivity_all.dat"</span>;
00201   <span class="comment">//filename and path from xml file</span>
00202   <span class="keywordflow">if</span>((fSen = fopen( fileName.c_str(), <span class="stringliteral">"rb"</span>)) ==0){
00203     printf(<span class="stringliteral">"Cannot open detector sensitivity file...\n"</span>);
00204     MPI::COMM_WORLD.Abort(-1);
00205   }
00206   <span class="keywordflow">if</span>(fread(senTmp, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), senSize, fSen)!=senSize){
00207     cout&lt;&lt;<span class="stringliteral">"Error in reading detector sensitivity file..."</span>&lt;&lt;endl;
00208     MPI::COMM_WORLD.Abort(-1);
00209   }
00210   sen = senTmp;
00211   <span class="keywordflow">if</span>(params-&gt;frame.verbosity&gt;=5) {
00212     FILE *fSenTest;
00213     <span class="keywordflow">if</span>((fSenTest = fopen( <span class="stringliteral">"sensitivity_all_test.dat"</span>, <span class="stringliteral">"wb"</span>)) ==0)
00214       MPI::COMM_WORLD.Abort(-1);
00215                 
00216     <span class="comment">//Output sen to file</span>
00217     <span class="keywordflow">for</span> (k=0; k&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o12">nRing</a>;k++) {
00218       <span class="keywordflow">for</span> (j=0; j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>; j++){
00219         <span class="keywordflow">for</span> (p=0; p&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>; p++){
00220                                 
00221           <span class="keywordflow">for</span> (i=0; i&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>; i++){
00222             fwrite(&amp; sen(i,p,j,k), <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), 1, fSenTest);
00223           }
00224         }
00225       }
00226     }
00227     fclose(fSenTest);
00228   }
00229   <span class="keyword">delete</span> []senTmp;
00230   fclose(fSen);
00231 }
00232 
00233 <span class="comment">//---------------------------------------------------------------------------</span>
00234 <span class="comment">// NAME</span>
00235 <span class="comment">//              calculateAxGeoFctr()</span>
00236 <span class="comment">//DESCRIPTION</span>
00237 <span class="comment">//              calculate detector normalization geometry functions in </span>
00238 <span class="comment">//             tranaxial direction</span>
00239 <span class="comment">//              at this moment, the  function was written in a file</span>
00240 <span class="comment">//              this function opens the file and read in the data</span>
00241 <span class="comment">//---------------------------------------------------------------------------</span>
00242 
00243 <span class="keywordtype">void</span> HRRTHouseNorm::calculateAxGeoFctr()
00244 {
00245   <span class="comment">//check if the pointer initialized when use it</span>
00246   Status * status= Status::getStatus();
00247   <span class="keywordflow">if</span>(!checkValid()){
00248     <span class="keywordflow">if</span>(status-&gt;proc==0){
00249       cout&lt;&lt;<span class="stringliteral">"Error in use of HRRTScannerParams"</span>
00250           &lt;&lt;<span class="stringliteral">"Programmer make sure call the getInstance"</span>
00251           &lt;&lt;<span class="stringliteral">"Program aborted"</span>&lt;&lt;endl;
00252       cout.flush();
00253     }
00254     <a class="code" href="classUtilities.html#e8">Utilities::cleanUp</a>(Constant::POINTERERROR);
00255   }
00256   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> *scanner = <a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00257   Params *params = Params::getInstance();
00258 
00259   <span class="keyword">const</span> <span class="keywordtype">int</span> binsz = 28;
00260   <span class="comment">//init the geoAx function (3D array, with dimesion binsize, )</span>
00261   geoAx.init(binsz, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o2">blockPerBankZ</a>, 
00262              scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>);
00263   <span class="comment">//normalization geometry factors in axial directions, 3d array</span>
00264   <span class="comment">//dimension: 28 (incidence angle from -70 deg to 70 deg for every 5 deg), </span>
00265   <span class="comment">//detector number per block in axial direction, layer number</span>
00266   string fileName = params-&gt;normalization.filePath+<span class="stringliteral">"/ax_geo.dat"</span>;
00267   ifstream fGeoAx(fileName.c_str());
00268   <span class="keywordflow">if</span>(!fGeoAx )  {
00269     cout&lt;&lt;<span class="stringliteral">"Error openning detector geo_ax file..."</span>&lt;&lt;endl;
00270     MPI::COMM_WORLD.Abort(-1);
00271   }
00272   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>;k++) {
00273     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p=0; p&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o2">blockPerBankZ</a>; p++){
00274       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>; j++)  {
00275         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;binsz; i++){
00276           fGeoAx&gt;&gt;geoAx(i,j,p,k);
00277         }
00278       } 
00279     }
00280   }
00281   <span class="keywordflow">if</span>(params-&gt;frame.verbosity&gt;=5) {
00282     ofstream fGeoAxTest(<span class="stringliteral">"ax_geo_test.dat"</span>);
00283     <span class="keywordflow">if</span>(!fGeoAxTest) {
00284       cout&lt;&lt;<span class="stringliteral">"Error opennig geo_ax test file..."</span>&lt;&lt;endl;
00285       MPI::COMM_WORLD.Abort(-1);
00286     }
00287 
00288     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>;k++) {
00289       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p=0; p&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o2">blockPerBankZ</a>; p++){
00290         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>; j++) {
00291           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;binsz; i++){
00292             fGeoAxTest&lt;&lt;geoAx(i,j,p,k)&lt;&lt;<span class="stringliteral">" "</span>;
00293 
00294           }
00295         }
00296         fGeoAxTest&lt;&lt;endl;
00297       }
00298     }
00299     fGeoAxTest.close();
00300   }
00301   fGeoAx.close();
00302 }
00303 
00304 <span class="comment">//---------------------------------------------------------------------------</span>
00305 <span class="comment">//calculate detector normalization geometry functions in axial direction</span>
00306 <span class="comment">//at this moment, the  function was written in a file</span>
00307 <span class="comment">//this function opens the file and read in the data</span>
00308 <span class="comment">//---------------------------------------------------------------------------</span>
00309 <span class="keywordtype">void</span> HRRTHouseNorm::calculateTxGeoFctr()
00310 {
00311   <span class="comment">//check if the pointer initialized when use it</span>
00312   Status * status= Status::getStatus();
00313   <span class="keywordflow">if</span>(!checkValid()){
00314     <span class="keywordflow">if</span>(status-&gt;proc==0){
00315       cout&lt;&lt;<span class="stringliteral">"Error in use of HRRTScannerParams"</span>
00316           &lt;&lt;<span class="stringliteral">"Programmer make sure call the getInstance"</span>
00317           &lt;&lt;<span class="stringliteral">"Program aborted"</span>&lt;&lt;endl;
00318       cout.flush();
00319     }
00320     <a class="code" href="classUtilities.html#e8">Utilities::cleanUp</a>(Constant::POINTERERROR);
00321   }
00322   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> *scanner = <a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00323   Params *params = Params::getInstance();
00324 
00325   <span class="keyword">const</span> <span class="keywordtype">int</span> binsz = 28;
00326   geoTx.init(binsz, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>, scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o1">blockPerBankX</a>, 
00327              scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>);
00328   <span class="comment">//normalization geometry factors in transaxle directions, </span>
00329   <span class="comment">//3d array, with dimension: 28 (incidence angle from -70 deg to 70 deg for </span>
00330   <span class="comment">//every 5 deg), detector number per block in transaxle direction, layer number</span>
00331   string fileName = params-&gt;normalization.filePath+<span class="stringliteral">"/tx_geo.dat"</span>;
00332   ifstream fGeoTx(fileName.c_str());
00333   <span class="keywordflow">if</span>(!fGeoTx)    {
00334     cout&lt;&lt;<span class="stringliteral">"Error openning detector geo_tx file..."</span>&lt;&lt;endl;
00335     MPI::COMM_WORLD.Abort(-1);
00336   }
00337   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>;k++) {
00338     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p=0; p&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o1">blockPerBankX</a>; p++){
00339       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>; j++){
00340         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;binsz; i++){
00341           fGeoTx&gt;&gt;geoTx(i,j,p,k);
00342         }
00343       }
00344     }
00345   }
00346   <span class="keywordflow">if</span>(params-&gt;frame.verbosity&gt;=5) {
00347     ofstream fGeoTxTest(<span class="stringliteral">"tx_geo_test.dat"</span>);
00348     <span class="keywordflow">if</span>(!fGeoTxTest) {
00349       cout&lt;&lt;<span class="stringliteral">"Cannot open geo_tx test file..."</span>&lt;&lt;endl;
00350       MPI::COMM_WORLD.Abort(-1);
00351     }
00352 
00353     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>;k++)  {
00354       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p=0; p&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o1">blockPerBankX</a>; p++){
00355         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>; j++) {
00356           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;binsz; i++){
00357             fGeoTxTest&lt;&lt;geoTx(i,j,p,k)&lt;&lt;<span class="stringliteral">" "</span>;
00358           }
00359         }
00360         fGeoTxTest&lt;&lt;endl;
00361       }
00362     }
00363     fGeoTxTest.close();
00364   }
00365   fGeoTx.close();
00366 }
00367 
00368 
00369 <span class="comment">//--------------------------------------------------------------------------</span>
00370 <span class="comment">//Calculate normalization factor</span>
00371 <span class="comment">//------------------------------------------------------------------------</span>
00372 <span class="keywordtype">float</span> HRRTHouseNorm::getNormFctr(<span class="keyword">const</span> <a class="code" href="structCrystalID.html">CrystalID</a> &amp;e1, 
00373                              <span class="keyword">const</span> <a class="code" href="structCrystalID.html">CrystalID</a> &amp;e2)
00374 {
00375   <span class="keyword">const</span> <span class="keywordtype">float</span> cvtrad = 180.0/3.14159265;
00376         
00377   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> *scanner = <a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00378   Params *params = Params::getInstance();
00379   <a class="code" href="classHRRTHouseSingles.html">HRRTHouseSingles</a> *houseSingles = HRRTHouseSingles::getInstance();
00380 
00381   <span class="comment">//calculate axial incident angle</span>
00382 
00383   <span class="keywordtype">float</span> y1 = SIN(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>) +
00384     COS(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>);
00385   <span class="keywordtype">float</span> y2 = SIN(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>) +
00386     COS(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>);
00387   <span class="keywordtype">float</span> z1 = zd(e1.<a class="code" href="structCrystalID.html#o1">ring</a>);
00388   <span class="keywordtype">float</span> z2 = zd(e2.<a class="code" href="structCrystalID.html#o1">ring</a>);
00389   <span class="keywordtype">float</span> theta1 = atan((z2-z1)/(y2-y1));                                 
00390   <span class="keywordtype">int</span> axAngle1= static_cast&lt;int&gt; ((theta1*cvtrad+70)/5);
00391 
00392   y1 = SIN(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>) +
00393     COS(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>) ;
00394   y2 = SIN(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>) +
00395     COS(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>);
00396   <span class="keywordtype">float</span> theta2 = atan((z2-z1)/(y2-y1));                            
00397   <span class="keywordtype">int</span> axAngle2 = static_cast&lt;int&gt; ((theta2*cvtrad+70)/5);
00398   
00399   <span class="comment">//Calculate transaxial incident angle                                 </span>
00400   <span class="keywordtype">float</span> x1 = COS(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>) - 
00401     SIN(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>);
00402   y1 = SIN(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>) + 
00403     COS(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>);
00404   
00405   <span class="keywordtype">float</span> x2 = COS(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>) - 
00406     SIN(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>);
00407   y2 = SIN(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>) + 
00408     COS(e1.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>);
00409 
00410   theta1 = atan((x2-x1)/(y2-y1));
00411   <span class="keywordtype">int</span> txAngle1 = static_cast&lt;int&gt;((theta1*cvtrad+70)/5);
00412 
00413   x1 = COS(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>) -
00414     SIN(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>);
00415   y1 = SIN(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>) +
00416     COS(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>);
00417 
00418   x2 = COS(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>) -
00419     SIN(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>);
00420   y2 = SIN(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*xd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>)+
00421     COS(e2.<a class="code" href="structCrystalID.html#o2">bank</a>)*yd(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>);
00422 
00423   theta2 = atan((x2-x1)/(y2-y1));
00424   <span class="keywordtype">int</span> txAngle2 = static_cast&lt;int&gt; ((theta2*cvtrad+70)/5);
00425 
00426   <span class="comment">//assembly the factor</span>
00427   <span class="keywordtype">int</span> rankGeo1;
00428   <span class="keywordtype">int</span> rankGeo2;
00429   
00430   <span class="keywordtype">float</span> eff1 = getSen(e1.<a class="code" href="structCrystalID.html#o0">dtct</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e1.<a class="code" href="structCrystalID.html#o2">bank</a>,e1.<a class="code" href="structCrystalID.html#o1">ring</a>,houseSingles-&gt;<a class="code" href="classHRRTHouseSingles.html#d5">getSingles</a>(e1.<a class="code" href="structCrystalID.html#o9">block</a>));
00431   <span class="keywordtype">float</span> eff2 = getSen(e2.<a class="code" href="structCrystalID.html#o0">dtct</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o2">bank</a>,e2.<a class="code" href="structCrystalID.html#o1">ring</a>,houseSingles-&gt;<a class="code" href="classHRRTHouseSingles.html#d5">getSingles</a>(e2.<a class="code" href="structCrystalID.html#o9">block</a>));
00432   
00433   <span class="keywordtype">float</span> fctr = eff1*eff2*
00434     geoAx(axAngle1,e1.<a class="code" href="structCrystalID.html#o1">ring</a>%scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>,
00435           e1.<a class="code" href="structCrystalID.html#o1">ring</a>/scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>,e1.<a class="code" href="structCrystalID.html#o3">layer</a>)*
00436     geoAx(axAngle2, e2.<a class="code" href="structCrystalID.html#o1">ring</a> % scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>, 
00437           e2.<a class="code" href="structCrystalID.html#o1">ring</a> / scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>, e2.<a class="code" href="structCrystalID.html#o3">layer</a>)*
00438     geoTx(txAngle1,e1.<a class="code" href="structCrystalID.html#o0">dtct</a> % scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>,
00439           e1.<a class="code" href="structCrystalID.html#o0">dtct</a> / scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>, e1.<a class="code" href="structCrystalID.html#o3">layer</a>)
00440     *geoTx(txAngle2, e2.<a class="code" href="structCrystalID.html#o0">dtct</a> % scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>,
00441            e2.<a class="code" href="structCrystalID.html#o0">dtct</a> / scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o0">dtctPerBlock</a>, e2.<a class="code" href="structCrystalID.html#o3">layer</a>)
00442     *params-&gt;normalization.globalsens;
00443 
00444   <span class="keywordflow">return</span> fctr;
00445 }
00446 
00447 <span class="keywordtype">void</span>  HRRTHouseNorm::read_countrate_factor(){
00448   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> *scanner = <a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00449   Params *params = Params::getInstance();
00450   FILE * factor;
00451   alpha.init(scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>,scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>,scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>,scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o12">nRing</a>);
00452   string fileName = params-&gt;normalization.filePath+<span class="stringliteral">"/alpha.dat"</span>;
00453   <span class="keywordflow">if</span> ((atoi(params-&gt;normalization.normalizationType.c_str()) == 2)){
00454     <span class="keywordflow">if</span>((factor = fopen( fileName.c_str(), <span class="stringliteral">"rb"</span>)) == 0){
00455       printf(<span class="stringliteral">"Did not find the alpha.dat file to adjust efficiency with count rate\n"</span>);
00456       MPI::COMM_WORLD.Abort(-1);
00457     }
00458     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o12">nRing</a>;k++) {
00459       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o4">nBank</a>; j++){
00460         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o3">nLayer</a>; i++){
00461           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;scanner-&gt;<a class="code" href="classHRRTScannerParams.html#o11">nDtct</a>; l++){ 
00462             fread(&amp; alpha(l,i,j,k), <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),1, factor);
00463           }
00464         }
00465      }
00466     }
00467   }
00468 }
00469 
00472 <span class="keywordtype">float</span> HRRTHouseNorm::getSen(<span class="keywordtype">int</span> dtct, <span class="keywordtype">int</span> layer, <span class="keywordtype">int</span> bank, <span class="keywordtype">int</span> ring, <span class="keywordtype">int</span> singles)
00473 {
00474   <a class="code" href="classHRRTScannerParams.html">HRRTScannerParams</a> *scanner = <a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00475   Params *params = Params::getInstance();
00476 
00477   <span class="keywordtype">float</span> normSingles = params-&gt;normalization.normSinglesRate;
00478   
00479   <span class="keywordtype">float</span> offsetSign = ( layer==0 ) ? -1.0 : 1.0 ;
00480   <span class="keywordtype">float</span> effOffset = params-&gt;normalization.effOffset;
00481   <span class="keywordtype">float</span> singles_weight=1.0;<span class="comment">//this factor accounts for the diference in the singles rate </span>
00482                            <span class="comment">//measured from the rod source and the 20 cm phantom</span>
00483 
00484   <span class="keywordtype">float</span> eff = sen(dtct,layer,bank,ring);
00485   <span class="comment">// add offset IF this efficiency is nonzero</span>
00486   <span class="comment">// We have three types of normalization, identified as 0, 1 or 2 in the field normalization.normalizationType (xml file)</span>
00487   <span class="comment">// Thre difference between the three types is the way we correct for count rate variations of crystal efficieny "eff"</span>
00488   <span class="comment">// Norm type 0 means no effciency adjustment</span>
00489   <span class="comment">// Norm type 1 means adjusting "eff" only with one global factor (mean of the individual  crystal factors).  This global factor is effoffset</span>
00490   <span class="comment">// Norm type 2 means adjusting "eff" with an individual parameter for each crystal. This parameters are stored in the array alpha</span>
00491   
00492   <span class="keywordflow">if</span> ((eff &gt; 0) &amp;&amp; (atoi(params-&gt;normalization.normalizationType.c_str()) == 1)) {
00493    eff+= offsetSign*effOffset*(singles-singles_weight*normSingles);
00494   }
00495   <span class="keywordflow">if</span> ((eff &gt; 0) &amp;&amp; (atoi(params-&gt;normalization.normalizationType.c_str()) == 2)) {
00496    eff+= alpha(dtct,layer,bank,ring)*(singles-singles_weight*normSingles);
00497   }
00498 
00499   <span class="keywordflow">if</span>(params-&gt;randoms.verbosity&gt;=4 || params-&gt;normalization.verbosity&gt;=4){
00500     <span class="keywordflow">if</span>( (dtct == 36) &amp;&amp; (ring == 52) &amp;&amp; (bank == 0) ) {
00501       cout&lt;&lt;<span class="stringliteral">"getSen: "</span>&lt;&lt;eff&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;sen(dtct,layer,bank,ring)&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;effOffset&lt;&lt;<span class="stringliteral">" "</span>
00502           &lt;&lt;singles&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;normSingles&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;layer&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;params-&gt;normalization.filePath&lt;&lt;endl;
00503     }
00504   }
00505   
00506   <span class="keywordflow">return</span> eff;
00507 }
00508 
00509   
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Dec 13 14:13:47 2007 for reconHRRT by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
