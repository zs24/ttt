<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>reconHRRT: Array1D.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Array1D.hpp</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef ARRAY1D_HPP</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define ARRAY1D_HPP</span>
00003 <span class="preprocessor"></span>
<a name="l00007"></a><a class="code" href="classArray1D.html">00007</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span><a class="code" href="classArray1D.html">Array1D</a>
00008 {
00009 <span class="keyword">public</span>:
00010   <span class="comment">//------------------------------------</span>
00011   <span class="comment">//public member variables</span>
00012   <span class="comment">//------------------------------------</span>
00013   <span class="keywordtype">int</span> dim1; <span class="comment">//dimension, initialized to zero for safety</span>
00014   <span class="keywordtype">float</span> loc1; <span class="comment">//offset of first index</span>
00015   <span class="keywordtype">float</span> step1; <span class="comment">//sampling interval</span>
00016   string step_units1; <span class="comment">//units of step</span>
00017   string units; <span class="comment">// units of the values</span>
00018         
00019   <span class="comment">//------------------------------------------</span>
00020   <span class="comment">//constructors</span>
00021   <span class="comment">//------------------------------------------</span>
00022   <a class="code" href="classArray1D.html">Array1D</a>():dim1(0) <span class="comment">//Default constructor </span>
00023   {
00024     x = NULL; isnew = 1;
00025   }
00026   <a class="code" href="classArray1D.html">Array1D</a>(<span class="keywordtype">int</span> N1) <span class="comment">//constructor with dimension</span>
00027   {
00028     x = NULL; isnew = 1;
00029     init(N1);
00030   }
00031   <a class="code" href="classArray1D.html">Array1D</a> (<a class="code" href="classArray1D.html">Array1D</a> &amp; obj) <span class="comment">//copy constructor</span>
00032   {
00033     isnew = 1;
00034     copy(obj);
00035 
00036   }
00037         
00038   <span class="comment">//-------------------------------------------</span>
00039   <span class="comment">//destructor</span>
00040   <span class="comment">//-------------------------------------------</span>
00041   ~<a class="code" href="classArray1D.html">Array1D</a>()
00042   {
00043     <span class="keywordflow">if</span> (isnew &amp;&amp; x)
00044       <span class="keyword">delete</span> [] x;
00045   }
00046         
00047   <span class="comment">//---------------------------------------------</span>
00048   <span class="comment">//Operator overloading</span>
00049   <span class="comment">//---------------------------------------------</span>
00050   <a class="code" href="classArray1D.html">Array1D&lt;T&gt;</a>&amp;  operator= (<a class="code" href="classArray1D.html">Array1D&lt;T&gt;</a> &amp; obj)
00051   {
00052     <span class="keywordflow">if</span> (x == obj.<a class="code" href="classArray1D.html#r1">x</a>) <span class="keywordflow">return</span> (*this);
00053     <span class="keywordflow">if</span>( isnew &amp;&amp; x) <span class="keyword">delete</span> [] x;
00054     copy(obj);
00055     <span class="keywordflow">return</span> (*this);
00056   }
00057         
00058   <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> T &amp; value)
00059   {
00060     <span class="keywordflow">if</span>(!x)
00061       {
00062         cout&lt;&lt;<span class="stringliteral">"Error in Array1D : Array not initialized... "</span>&lt;&lt;endl;
00063         exit(-1);
00064       }
00065     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;dim1; i++)
00066       x[i] = value;
00067   }
00068         
00069   T&amp; operator() (<span class="keywordtype">int</span> i) <span class="comment">//Accessor, access array(index)</span>
00070   {
00071     <span class="keywordflow">if</span>(i&lt;0 || i&gt;= dim1)
00072       {
00073         cout&lt;&lt;<span class="stringliteral">"Bad index ("</span>&lt;&lt; i&lt;&lt;<span class="stringliteral">")"</span>&lt;&lt;endl;
00074         <span class="keywordflow">return</span> (*x);
00075       }
00076     <span class="keywordflow">return</span> (x[i]);
00077   }
00078         
00079   T&amp;  operator [] (<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> (x[i]);} <span class="comment">//Another accessor</span>
00080 
00081         
00082   <span class="comment">//------------------------------------------------------</span>
00083   <span class="comment">//init function</span>
00084   <span class="comment">//-------------------------------------------------------</span>
00085   <span class="keywordtype">void</span> init(<span class="keywordtype">int</span> N1)<span class="comment">//Aonther choice to initialize the array</span>
00086   {
00087     dim1 = N1; 
00088     <span class="keywordflow">if</span> (isnew &amp;&amp; x) <span class="keyword">delete</span> []x;
00089     isnew = 1;
00090     x = <span class="keyword">new</span> T [N1];
00091     <span class="comment">// (*this) = 0;</span>
00092   }
00093 
00094         
00095   <span class="comment">//--------------------------------------------------------</span>
00096   <span class="comment">//utility functions</span>
00097   <span class="comment">//--------------------------------------------------------</span>
00098   <span class="comment">//return pointer to specified index</span>
00099   T *ptr(<span class="keywordtype">int</span> i)
00100   {
00101     <span class="keywordflow">return</span> (&amp;x[i]);
00102   }
00103         
00104   <span class="comment">//Return a block of the array starting at specific index. This allocates new memory</span>
00105   T * getBlock(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> size)
00106   {
00107     <span class="keywordflow">if</span>(i&lt;0 || i&gt;= dim1) {cout&lt;&lt;<span class="stringliteral">"Bad index:"</span>&lt;&lt;i&lt;&lt;endl; <span class="keywordflow">return</span> x;}
00108     <span class="keywordflow">if</span>((i+size)&gt;dim1) {cout&lt;&lt;<span class="stringliteral">"Size too large:"</span>&lt;&lt;size&lt;&lt;endl; <span class="keywordflow">return</span> x;}
00109     T * block = <span class="keyword">new</span> T [size];
00110     memcpy(block, &amp;x[i], <span class="keyword">sizeof</span>(T)*size);
00111     <span class="keywordflow">return</span> block;
00112   }
00113         
00114   <span class="keywordtype">void</span> putBlock(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> size, T* array)
00115   {
00116     <span class="keywordflow">if</span>(i&lt;0 || i&gt;= dim1) {cout&lt;&lt;<span class="stringliteral">"Bad index:"</span>&lt;&lt;i&lt;&lt;endl;<span class="keywordflow">return</span>;}
00117     <span class="keywordflow">if</span>((i+size)&gt;dim1) {cout&lt;&lt;<span class="stringliteral">"Size too large:"</span>&lt;&lt;size&lt;&lt;endl;<span class="keywordflow">return</span>;}
00118     memcpy(&amp;x[i], array, <span class="keyword">sizeof</span>(T)*size);
00119   }
00120         
00121   <span class="comment">//Get maximum value of the array</span>
00122   T max()
00123   {
00124     T maxVal = x[0]; 
00125     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;dim1; i++)
00126       {
00127         <span class="keywordflow">if</span> (x[i] &gt; maxVal) 
00128           maxVal = x[i];
00129       }
00130     <span class="keywordflow">return</span> maxVal;
00131   }
00132    
00133   <span class="comment">//Get minimum value of the array</span>
00134   T min()
00135   {
00136     T minVal = x[0]; 
00137     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;dim1; i++)
00138       {
00139         <span class="keywordflow">if</span> (x[i] &lt; minVal) 
00140           minVal = x[i];
00141       }
00142     <span class="keywordflow">return</span> minVal;
00143   }
00144         
00145   <span class="comment">//-----------------------------------------------------------------------</span>
00146   <span class="comment">//utility function, get index of max value of an array</span>
00147   <span class="comment">//-----------------------------------------------------------------------</span>
00148   <span class="keywordtype">int</span> maxIndex() 
00149   {
00150     <span class="keywordtype">short</span> maxIndex = 0;
00151     <span class="keywordflow">for</span> (<span class="keywordtype">short</span> i=1; i&lt;dim1; i++) 
00152       {
00153         <span class="keywordflow">if</span> (x[i] &gt; x[maxIndex]) 
00154           {
00155             maxIndex = i;
00156           }
00157       }
00158     <span class="keywordflow">return</span> maxIndex;
00159   }<span class="comment">//end maxIndex</span>
00160 
00161   <span class="comment">//--------------------------------------------------------------------------</span>
00162   <span class="comment">//utility function, get the first index where x[i]&gt;b</span>
00163   <span class="comment">//--------------------------------------------------------------------------</span>
00164   <span class="keywordtype">int</span> where(<span class="keyword">const</span> T &amp;b)
00165   {
00166     <span class="keywordtype">int</span> index;
00167     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i= 0; i&lt;dim1; i++)
00168       {
00169         <span class="keywordflow">if</span>( x[i] &gt;= b) 
00170           {
00171             index = i; 
00172             <span class="keywordflow">return</span> index;
00173           }
00174       }
00175     index = -1;
00176     <span class="keywordflow">return</span> index;
00177   }
00178 
00179   <span class="comment">//-----------------------------------------------------------------------------</span>
00180   <span class="comment">//utility function, get the last index where x[i]&gt;b</span>
00181   <span class="comment">//-----------------------------------------------------------------------------</span>
00182   <span class="keywordtype">int</span> whereI(<span class="keyword">const</span> T &amp;b)
00183   {
00184     <span class="keywordtype">int</span> index;
00185     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i= dim1 - 1; i &gt;= 0 ; i--)
00186       {
00187         <span class="keywordflow">if</span>( x[i] &gt;= b) 
00188           {
00189             index = i; 
00190             <span class="keywordflow">return</span> index;
00191           }
00192       }
00193     index = -1;
00194     <span class="keywordflow">return</span> index;
00195   }
00196         
00197   <span class="comment">//----------------------------------------------------------------------------</span>
00198   <span class="comment">//utility function, get the sum of the array</span>
00199   <span class="comment">//----------------------------------------------------------------------------</span>
00200   T sum()
00201   {
00202     T sumx=0;
00203     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;dim1;i++)
00204       sumx+=x[i];
00205     <span class="keywordflow">return</span> sumx;
00206   }
00207         
00208   <span class="comment">//--------------------------------------------------------------------------</span>
00209   <span class="comment">//utility function, get the sum of the array from index1 to index2</span>
00210   <span class="comment">//-------------------------------------------------------------------------</span>
00211   T sum(<span class="keywordtype">int</span> index1, <span class="keywordtype">int</span> index2)
00212   {
00213     <span class="keywordflow">if</span>( 0&gt;index1 || index1&gt;=dim1)
00214       {
00215         cout&lt;&lt;<span class="stringliteral">"bad index1 "</span>&lt;&lt;index1&lt;&lt;endl;
00216         <span class="keywordflow">return</span> 0;
00217       }
00218     <span class="keywordflow">if</span>( 0&gt;index2 || index2&gt;dim1)
00219       {
00220         cout&lt;&lt;<span class="stringliteral">"bad index2 "</span>&lt;&lt;index2&lt;&lt;endl;
00221         <span class="keywordflow">return</span> 0;
00222       }
00223     <span class="keywordflow">if</span>(index2&lt;index1)
00224       {
00225         cout&lt;&lt;<span class="stringliteral">"Index2 should not be less than index1"</span>&lt;&lt;endl;
00226         <span class="keywordflow">return</span> 0;
00227       }
00228     T sumx=0;
00229     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=index1; i&lt;=index2; i++)
00230       sumx +=x[i];
00231     <span class="keywordflow">return</span> sumx;
00232   } 
00233                 
00234   <span class="comment">/**************************************************************</span>
00235 <span class="comment">   * broadcast</span>
00236 <span class="comment">   * Via a call to the MPI Bcast function, broadcasts the substance of</span>
00237 <span class="comment">   * Array1D from the sourceproc to all the processors.</span>
00238 <span class="comment">   * Here we assume that the memory has already been allocated and</span>
00239 <span class="comment">   * that dim1 is large enough.</span>
00240 <span class="comment">   * @param sourceproc - The source processor that is sending to the</span>
00241 <span class="comment">   * others.</span>
00242 <span class="comment">  **********/</span>
00243   <span class="keywordtype">void</span> broadcast(<span class="keywordtype">int</span> sourceproc)
00244   {
00245     <span class="keywordflow">if</span>(MPI::COMM_WORLD.Get_rank() != sourceproc){
00246       <span class="keywordflow">if</span>(dim1==0){
00247         cout &lt;&lt; <span class="stringliteral">"Fatal error in Array1D::broadcast(): unitialized array "</span> 
00248              &lt;&lt; <span class="stringliteral">"on processor "</span>&lt;&lt;MPI::COMM_WORLD.Get_rank()&lt;&lt;endl;
00249         <a class="code" href="classUtilities.html#e8">Utilities::cleanUp</a>(MPI::COMM_WORLD.Get_rank());
00250       }
00251     }
00252     MPI::COMM_WORLD.Bcast((<span class="keywordtype">void</span> *)(&amp;x[0]),dim1*<span class="keyword">sizeof</span>(T),MPI::CHAR,
00253                           sourceproc);
00254   }
00255                 
00256 <span class="keyword">private</span>:
00257   <span class="comment">//------------------------------------------------------------</span>
00258   <span class="comment">//private member variables</span>
00259   <span class="comment">//------------------------------------------------------------</span>
00260   <span class="keywordtype">int</span> isnew;
00261   T * x;  <span class="comment">// The actual array</span>
00262         
00263   <span class="comment">//---------------------------------------------------------</span>
00264   <span class="comment">//private member functions</span>
00265   <span class="comment">//---------------------------------------------------------</span>
00266   <span class="keywordtype">void</span> copy (<a class="code" href="classArray1D.html">Array1D</a> &amp;obj)
00267   {
00268     dim1 = obj.<a class="code" href="classArray1D.html#o0">dim1</a>;
00269     <span class="keywordflow">if</span>(isnew)   x = <span class="keyword">new</span> T [dim1];
00270     memcpy(x, obj.<a class="code" href="classArray1D.html#r1">x</a>, <span class="keyword">sizeof</span>(T)*dim1);
00271   }
00272 };
00273 
00274 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Dec 13 14:13:46 2007 for reconHRRT by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
