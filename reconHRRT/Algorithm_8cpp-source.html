<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>reconHRRT: Algorithm.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Algorithm.cpp</h1><div class="fragment"><pre>00001 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00002 <span class="preprocessor">#include "HRRTHouse.hpp"</span>
00003 <span class="preprocessor">#include "EventList.hpp"</span>
00004 <span class="preprocessor">#include "Params.hpp"</span>
00005 <span class="preprocessor">#include "Image.hpp"</span>
00006 <span class="preprocessor">#include "MOLAR.hpp"</span>
00007 <span class="preprocessor">#include "Algorithm.hpp"</span>
00008 
00009 <span class="comment">// 2004-07-22 rc added more output based on randoms.verbosity</span>
<a name="l00010"></a><a class="code" href="classAlgorithm.html#a0">00010</a> <span class="keywordtype">void</span> <a class="code" href="classAlgorithm.html#a0">Algorithm::fwdBackProjectEventX</a>(<a class="code" href="classImage.html">Image</a> &amp;Q, <a class="code" href="classImage.html">Image</a> &amp;lambda,
00011                                      <a class="code" href="classImage.html">Image</a> &amp;nu, <a class="code" href="classEventPacket.html">EventPacket</a> &amp;event, 
00012                                      <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, 
00013                                      <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, 
00014                                      Params &amp; params, <span class="keywordtype">float</span> &amp;duration,
00015                                      <span class="keywordtype">float</span> omega[])
00016 {
00017   <span class="comment">//spreads in y and z direction</span>
00018   <span class="keywordtype">int</span> downYSpread, upYSpread, downZSpread, upZSpread;
00019   <span class="comment">//loop ints</span>
00020   <span class="keywordtype">int</span> jx, jy, jz;
00021   <span class="comment">//voxel centers</span>
00022   <span class="keywordtype">int</span> jyCentral, jzCentral;
00023   <span class="comment">//deviation from voxel centers</span>
00024   <span class="keywordtype">float</span> dyCentral, dzCentral;
00025   <span class="comment">//table stuct to determine the size of quadraue</span>
00026   <a class="code" href="structMOLAR_1_1Table.html">MOLAR::Table</a> table;
00027   <span class="comment">//start points and increasments on R and U direction</span>
00028   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
00029   <span class="comment">//indices of resolution functions</span>
00030   <span class="keywordtype">int</span> kIndexR, kIndexU;
00031   <span class="comment">//float kIndexUstart;</span>
00032 
00033   <span class="comment">//intermeidate variable</span>
00034   <span class="keywordtype">float</span> yhat = 0;
00035 
00036   <span class="comment">//calculate the spreads of the quad</span>
00037   <span class="keywordtype">float</span> resFunRTable[params.geometry.nX][params.geometry.nY], 
00038     resFunUTable[params.geometry.nX][params.geometry.nZ];
00039 
00040 
00041   downYSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o22">sinphi</a>);
00042   upYSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o22">sinphi</a>);
00043   downZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
00044   upZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
00045 
00046   <span class="keywordtype">float</span> y = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
00047   <span class="keywordtype">float</span> z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
00048 
00049   <span class="keywordflow">for</span>(jx=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jx&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jx++){
00050     <span class="comment">//center of the voxel</span>
00051     jyCentral = (<span class="keywordtype">int</span>)(y); <span class="comment">//we have maken sure that floor(y)&gt;0</span>
00052     jzCentral = (<span class="keywordtype">int</span>)(z); <span class="comment">//we have maken sure that floor(z)&gt;0</span>
00053     <span class="comment">//deviations from the center</span>
00054     dyCentral = jyCentral+0.5-y; <span class="comment">//+0.5 to transfer image index to </span>
00055                                  <span class="comment">//image coordinate system</span>
00056     dzCentral = jzCentral+0.5-z;
00057     <span class="comment">//calculate the size of the quad</span>
00058     table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a> = jyCentral - downYSpread;
00059      <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>&lt;0){
00060        table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>=0;
00061      }
00062     table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a> = jyCentral + upYSpread;
00063      <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>&gt;params.geometry.nY-1){
00064        table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>=params.geometry.nY-1;
00065      }
00066     table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a> = jzCentral - downZSpread;
00067     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>&lt;0){
00068       table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>=0;
00069      }
00070     table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> = jzCentral + upZSpread;
00071     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> &gt; params.geometry.nZ-1){
00072       table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>= params.geometry.nZ-1;
00073     }
00074     <span class="comment">//start points</span>
00075     dRStart = (dyCentral - downYSpread) * event.<a class="code" href="classEventPacket.html#o22">sinphi</a>;
00076     dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
00077     dR=dRStart;
00078     <span class="keywordflow">for</span>(jy=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jy&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jy++){
00079       <span class="comment">//get kernel index and value at R direction</span>
00080       kIndexR = resFunR.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
00081         (<span class="keywordtype">int</span>)floor(dR*resFunR.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
00082       resFunRTable[jx][jy]=resFunR.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexR];
00083       dR += event.<a class="code" href="classEventPacket.html#o22">sinphi</a>;
00084     }
00085     dU = dUStart;
00086     <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++){ 
00087 
00088       <span class="comment">//get kernel index and value at U direction</span>
00089       kIndexU = resFunU.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
00090         (<span class="keywordtype">int</span>)floor(dU *resFunU.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
00091       resFunUTable[jx][jz]=resFunU.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexU];
00092       <span class="comment">// next value is not strictly costheta if voxels are not cubic</span>
00093       dU += event.<a class="code" href="classEventPacket.html#o24">costheta</a>;                     
00094 
00095     }
00096     <span class="keywordflow">if</span>(params.randoms.verbosity&gt;=4){
00097      <span class="keywordflow">if</span> (isnan(yhat) || (!finite(yhat))) {
00098       cout&lt;&lt;<span class="stringliteral">"***fwdbackprojectX: yhat is nan before the loop at jx="</span>&lt;&lt;jx&lt;&lt;endl;
00099      }
00100     }
00101     <span class="keywordflow">for</span>(jy=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jy&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jy++){    
00102       <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++){ 
00103         <span class="comment">//foward projection</span>
00104         <span class="keywordtype">float</span> kernel = resFunRTable[jx][jy]*resFunUTable[jx][jz];
00105         
00106         <span class="keywordtype">float</span> lamValue = lambda.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx];
00107         yhat += kernel*lamValue*omega[jx];
00108 
00109       }
00110     }
00111      <span class="keywordflow">if</span>(params.randoms.verbosity&gt;=4){
00112       <span class="keywordflow">if</span> (isnan(yhat) || (!finite(yhat))) {
00113        cout&lt;&lt;<span class="stringliteral">"**fwdbackprojectX: nan created at jx="</span>&lt;&lt;jx&lt;&lt;
00114                <span class="stringliteral">" jstart,jstop="</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o0">jstart</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o1">jstop</a>&lt;&lt;
00115                  <span class="stringliteral">" omega[jx]="</span>&lt;&lt;omega[jx]&lt;&lt;endl;
00116       cout&lt;&lt;<span class="stringliteral">"** secondaryStart,zStart,secondaryStep,zStep,x1,y1,z1,x2,y2,z2="</span>&lt;&lt;
00117        event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o3">zStart</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o5">zStep</a>&lt;&lt;
00118        event.<a class="code" href="classEventPacket.html#o12">x1</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o13">y1</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o14">z1</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o15">x2</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o16">y2</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o17">z2</a>&lt;&lt;endl;
00119        <span class="keywordflow">for</span>(jy=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jy&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jy++){    
00120          <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++){ 
00121            <span class="comment">//foward projection</span>
00122            <span class="keywordtype">float</span> kernel = resFunRTable[jx][jy]*resFunUTable[jx][jz];
00123            <span class="keywordflow">if</span> (isnan(kernel)) cout&lt;&lt;<span class="stringliteral">"X:kernel isnan jx="</span>&lt;&lt;jx&lt;&lt;<span class="stringliteral">" jy="</span>&lt;&lt;jy&lt;&lt;<span class="stringliteral">" jz="</span>&lt;&lt;jz&lt;&lt;endl;
00124            <span class="keywordtype">float</span> lamValue = lambda.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx];
00125            <span class="keywordflow">if</span> (isnan(lamValue)) cout&lt;&lt;<span class="stringliteral">"X:lamValue isnan jx="</span>&lt;&lt;jx&lt;&lt;<span class="stringliteral">" jy="</span>&lt;&lt;jy&lt;&lt;<span class="stringliteral">" jz="</span>&lt;&lt;jz&lt;&lt;endl;
00126          }
00127        }
00128        <span class="comment">// for(jy=table.secondaryStart; jy&lt;=table.secondaryStop; jy++){</span>
00129          <span class="comment">//cout&lt;&lt;"jy="&lt;&lt;jy&lt;&lt;" resfunRtable="&lt;&lt;resFunRTable[jx][jy]&lt;&lt;endl;</span>
00130        <span class="comment">//}</span>
00131        <span class="comment">//for(jz=table.zStart; jz&lt;=table.zStop; jz++){</span>
00132          <span class="comment">//cout&lt;&lt;"jz="&lt;&lt;jz&lt;&lt;" resfunUtable="&lt;&lt;resFunUTable[jx][jz]&lt;&lt;endl;</span>
00133        <span class="comment">//} </span>
00134        <span class="keywordflow">break</span>;
00135       }
00136      }
00137     y += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>; 
00138     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00139   }
00140   <span class="comment">//event.yhat * duration to make reconstruction duration independent</span>
00141   <span class="comment">/*if (isnan(yhat) || (!finite(yhat))) {</span>
00142 <span class="comment">    cout&lt;&lt;"fwdbackprojectX: yhat,jstart,jstop,secondaryStart,zStart,secondaryStep,zStep: "&lt;&lt;yhat&lt;&lt;" "&lt;&lt;</span>
00143 <span class="comment">    event.jstart&lt;&lt;" "&lt;&lt;event.jstop&lt;&lt;" "&lt;&lt;event.secondaryStart&lt;&lt;" "&lt;&lt;event.zStart&lt;&lt;</span>
00144 <span class="comment">    " "&lt;&lt;event.secondaryStep&lt;&lt;" "&lt;&lt;event.zStep&lt;&lt;endl;</span>
00145 <span class="comment">    cout&lt;&lt;"downYSpread,upYSpread,downZSpread,upZSpread:"&lt;&lt;downYSpread&lt;&lt;" "&lt;&lt;upYSpread&lt;&lt;" "&lt;&lt;</span>
00146 <span class="comment">     downZSpread&lt;&lt;" "&lt;&lt;upZSpread&lt;&lt;endl;</span>
00147 <span class="comment">  }*/</span> 
00148 
00149   event.<a class="code" href="classEventPacket.html#o18">yhat</a> = yhat*event.<a class="code" href="classEventPacket.html#o10">atten</a>*event.<a class="code" href="classEventPacket.html#o9">norm</a>*event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>
00150     *event.<a class="code" href="classEventPacket.html#o21">CijNorm</a>+event.<a class="code" href="classEventPacket.html#o8">rand</a>+event.<a class="code" href="classEventPacket.html#o11">scatter</a>;
00151   <span class="keywordflow">if</span>(params.randoms.verbosity&gt;=5){
00152    <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o20">timeStamp</a> % 1000 == 0) {
00153     cout&lt;&lt;<span class="stringliteral">"yhat,atten,norm,livetime,cijNorm,randoms,scatter (before duration scaling) "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o18">yhat</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;
00154     event.<a class="code" href="classEventPacket.html#o10">atten</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o9">norm</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o21">CijNorm</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o8">rand</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o11">scatter</a>&lt;&lt;endl;
00155    }
00156   }
00157   event.<a class="code" href="classEventPacket.html#o18">yhat</a> *= duration/1000;
00158   
00159   <span class="keywordtype">float</span> normFct = 0;
00160   <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o18">yhat</a> !=0)
00161     normFct = (<span class="keywordtype">float</span>)event.<a class="code" href="classEventPacket.html#o19">numEvents</a>*event.<a class="code" href="classEventPacket.html#o10">atten</a>*event.<a class="code" href="classEventPacket.html#o9">norm</a>
00162       *event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>*event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> / event.<a class="code" href="classEventPacket.html#o18">yhat</a>;
00163   <span class="comment">//cout&lt;&lt;normFct&lt;&lt;" X primary direction"&lt;&lt;endl;</span>
00164 
00165   <span class="comment">//y and z starting points</span>
00166   y = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
00167   z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
00168 
00169   <span class="keywordflow">for</span>(jx=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jx&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jx++){
00170     <span class="comment">//solid angle correction</span>
00171     <span class="comment">// omega=POW2((d0/(dmid+dl*fabs(jx-event.jmid))));</span>
00172     <span class="comment">//center of the voxel</span>
00173     jyCentral = (<span class="keywordtype">int</span>)(y); <span class="comment">//we have maken sure that floor(y)&gt;0</span>
00174     jzCentral = (<span class="keywordtype">int</span>)(z); <span class="comment">//we have maken sure that floor(z)&gt;0</span>
00175     <span class="comment">//deviations from the center</span>
00176     dyCentral = jyCentral+0.5-y; <span class="comment">//+0.5 to transfer image index to </span>
00177                                  <span class="comment">//image coordinate system</span>
00178     dzCentral = jzCentral+0.5-z;
00179     <span class="comment">//calculate the size of the quad</span>
00180     table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a> = jyCentral - downYSpread;
00181      <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>&lt;0){
00182        table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>=0;
00183      }
00184     table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a> = jyCentral + upYSpread;
00185      <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>&gt;params.geometry.nY-1){
00186        table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>=params.geometry.nY-1;
00187      }
00188     table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a> = jzCentral - downZSpread;
00189     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>&lt;0){
00190       table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>=0;
00191      }
00192     table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> = jzCentral + upZSpread;
00193     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> &gt; params.geometry.nZ-1){
00194       table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>= params.geometry.nZ-1;
00195     }
00196     <span class="keywordflow">for</span>(jy=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jy&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jy++){    
00197       <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++){ 
00198 
00199         <span class="keywordtype">float</span> kernel = resFunRTable[jx][jy]*resFunUTable[jx][jz];
00200         
00201         nu.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx] +=kernel* normFct*omega[jx] ;    
00202 
00203       }
00204     }
00205     y += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>; 
00206     z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00207   }
00208 }
00209 
00210 
00211 
<a name="l00212"></a><a class="code" href="classAlgorithm.html#a1">00212</a> <span class="keywordtype">void</span> <a class="code" href="classAlgorithm.html#a1">Algorithm::fwdBackProjectEventY</a>(<a class="code" href="classImage.html">Image</a> &amp;Q, <a class="code" href="classImage.html">Image</a> &amp;lambda, <a class="code" href="classImage.html">Image</a> &amp;nu, 
00213                                      <a class="code" href="classEventPacket.html">EventPacket</a> &amp;event,  
00214                                      <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunR, 
00215                                      <a class="code" href="structResolutionTable.html">ResolutionTable</a> &amp;resFunU, 
00216                                      Params &amp; params, <span class="keywordtype">float</span> &amp; duration,
00217                                      <span class="keywordtype">float</span> omega[])
00218 {
00219   <span class="comment">//spreads in x and z direction</span>
00220   <span class="keywordtype">int</span> downXSpread, upXSpread, downZSpread, upZSpread;
00221   <span class="comment">//intermidiate variables</span>
00222   <span class="comment">//float dl, dmid,omega,cijNorm, length;</span>
00223   <span class="comment">//yhat and CijNomr</span>
00224   <span class="keywordtype">float</span> yhat = 0;
00225   <span class="comment">//loop variables</span>
00226   <span class="keywordtype">int</span>  jx, jy, jz;
00227   <span class="comment">//x z coordinates</span>
00228   <span class="keywordtype">float</span> x,z;
00229   <span class="comment">//voxel centers</span>
00230   <span class="keywordtype">int</span> jxCentral, jzCentral;
00231   <span class="comment">//voxel diviations</span>
00232   <span class="keywordtype">float</span>  dxCentral, dzCentral;
00233   <a class="code" href="structMOLAR_1_1Table.html">MOLAR::Table</a> table;
00234   <span class="comment">//starting points</span>
00235   <span class="keywordtype">float</span> dRStart, dUStart, dR, dU;
00236   <span class="comment">//index of kernel</span>
00237   <span class="keywordtype">int</span> kIndexR, kIndexU;
00238   <span class="comment">//resolution function kernel table</span>
00239   <span class="keywordtype">float</span> resFunRTable[params.geometry.nY][params.geometry.nX],
00240     resFunUTable[params.geometry.nY][params.geometry.nZ]; 
00241 
00242  
00243   downXSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o23">cosphi</a>);
00244   upXSpread = (<span class="keywordtype">int</span>)ceil(resFunR.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o23">cosphi</a>);
00245   downZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o1">downSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
00246   upZSpread = (<span class="keywordtype">int</span>)ceil(resFunU.<a class="code" href="structResolutionTable.html#o2">upSpread</a>/event.<a class="code" href="classEventPacket.html#o24">costheta</a>);
00247 
00248 
00249   x = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
00250   z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
00251   <span class="keywordflow">for</span>(jy=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jy&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jy++){
00252 
00253     jxCentral = (<span class="keywordtype">int</span>)(x);<span class="comment">//we have maken sure that floor(x)&gt;=0</span>
00254     jzCentral = (<span class="keywordtype">int</span>)(z);<span class="comment">//we have maken sure that floor(z)&gt;=0</span>
00255     dxCentral = jxCentral+0.5-x; <span class="comment">//+0.5 to transfer image </span>
00256                                <span class="comment">//index to image coordinate system</span>
00257     dzCentral = jzCentral+0.5-z;
00258     table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a> = jxCentral - downXSpread;<span class="comment">//int</span>
00259     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>&lt;0) {
00260       table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>=0;
00261     }
00262     table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a> = jxCentral + upXSpread;
00263     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>&gt;params.geometry.nX-1){
00264       table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>=params.geometry.nX-1;
00265     }
00266     table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a> = jzCentral - downZSpread;
00267     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>&lt;0){
00268       table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>=0;
00269     }
00270     table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> = jzCentral + upZSpread;
00271    <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> &gt; params.geometry.nZ-1){
00272      table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>=params.geometry.nZ-1;
00273    }
00274    dRStart = (dxCentral - downXSpread) * event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
00275    dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
00276 
00277    <span class="comment">//calculate the kernel of resolution function R</span>
00278    dR=dRStart;
00279    <span class="keywordflow">for</span>(jx=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jx&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jx++){
00280      kIndexR = resFunR.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
00281        (<span class="keywordtype">int</span>)floor(dR*resFunR.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
00282      resFunRTable[jy][jx]=resFunR.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexR];
00283      dR += event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
00284    }
00285    <span class="comment">//calculate the kernel of resolution function U</span>
00286    dU = dUStart;
00287    <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;= table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++) {
00288      kIndexU = resFunU.<a class="code" href="structResolutionTable.html#o0">kCentralIndex</a> + 
00289        (<span class="keywordtype">int</span>)floor(dU * resFunU.<a class="code" href="structResolutionTable.html#o3">magnification</a>+0.5);
00290      resFunUTable[jy][jz]=resFunU.<a class="code" href="structResolutionTable.html#o4">kernel</a>[kIndexU];
00291      <span class="comment">// next value is not strictly costheta if voxels are not cubic</span>
00292      dU += event.<a class="code" href="classEventPacket.html#o24">costheta</a>;  
00293    }
00294    <span class="keywordflow">if</span>(params.randoms.verbosity&gt;=4){
00295     <span class="keywordflow">if</span> (isnan(yhat) || (!finite(yhat))) {
00296      cout&lt;&lt;<span class="stringliteral">"***fwdbackprojectY: yhat is nan before the loop at jy="</span>&lt;&lt;jy&lt;&lt;endl;
00297     }
00298    }
00299    <span class="keywordflow">for</span>(jx=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jx&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jx++){  
00300      <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;= table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++) {    
00301    
00302        <span class="keywordtype">float</span> kernel =  resFunRTable[jy][jx]*resFunUTable[jy][jz];
00303        <span class="keywordtype">float</span> lamValue= lambda.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx];
00304        yhat +=kernel* lamValue*omega[jy];
00305      }
00306    }
00307      <span class="keywordflow">if</span>(params.randoms.verbosity&gt;=4){
00308       <span class="keywordflow">if</span> (isnan(yhat) || (!finite(yhat))) {
00309        cout&lt;&lt;<span class="stringliteral">"***fwdbackprojectY: nan created at jy="</span>&lt;&lt;jy&lt;&lt;
00310         <span class="stringliteral">" jstart,jstop="</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o0">jstart</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o1">jstop</a>&lt;&lt;
00311         <span class="stringliteral">" omega[jy]="</span>&lt;&lt;omega[jy]&lt;&lt;endl;
00312        cout&lt;&lt;<span class="stringliteral">"** secondaryStart,zStart,secondaryStep,zStep,x1,y1,z1,x2,y2,z2="</span>&lt;&lt;
00313         event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o3">zStart</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o5">zStep</a>&lt;&lt;
00314         event.<a class="code" href="classEventPacket.html#o12">x1</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o13">y1</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o14">z1</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o15">x2</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o16">y2</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o17">z2</a>&lt;&lt;endl;
00315        <span class="comment">//for(jx=table.secondaryStart; jx&lt;=table.secondaryStop; jx++){</span>
00316         <span class="comment">// cout&lt;&lt;"jy="&lt;&lt;jy&lt;&lt;" resfunRtable="&lt;&lt;resFunRTable[jy][jx]&lt;&lt;endl;</span>
00317        <span class="comment">//}</span>
00318        <span class="comment">//for(jz=table.zStart; jz&lt;=table.zStop; jz++){</span>
00319          <span class="comment">//cout&lt;&lt;"jz="&lt;&lt;jz&lt;&lt;" resfunUtable="&lt;&lt;resFunUTable[jy][jz]&lt;&lt;endl;</span>
00320        <span class="comment">//} </span>
00321         <span class="keywordflow">for</span>(jx=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jx&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jx++){  
00322           <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;= table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++) {    
00323 
00324             <span class="keywordtype">float</span> kernel =  resFunRTable[jy][jx]*resFunUTable[jy][jz];
00325             <span class="keywordflow">if</span> (isnan(kernel)) cout&lt;&lt;<span class="stringliteral">"Y:kernel isnan jx="</span>&lt;&lt;jx&lt;&lt;<span class="stringliteral">" jy="</span>&lt;&lt;jy&lt;&lt;<span class="stringliteral">" jz="</span>&lt;&lt;jz&lt;&lt;endl;
00326             <span class="keywordtype">float</span> lamValue= lambda.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx];
00327             <span class="keywordflow">if</span> (isnan(lamValue)) cout&lt;&lt;<span class="stringliteral">"Y:lamValue isnan jx="</span>&lt;&lt;jx&lt;&lt;<span class="stringliteral">" jy="</span>&lt;&lt;jy&lt;&lt;<span class="stringliteral">" jz="</span>&lt;&lt;jz&lt;&lt;endl;
00328           }
00329         }
00330         <span class="keywordflow">break</span>;
00331       }
00332      }
00333    <span class="comment">//next </span>
00334    x += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
00335    z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00336 
00337   }
00338   <span class="comment">//event.yhat * duration to make reconstruction duration independent</span>
00339   <span class="comment">/*if (isnan(yhat) || (!finite(yhat))) {</span>
00340 <span class="comment">    cout&lt;&lt;"fwdbackprojectY: yhat,jstart,jstop,secondaryStart,zStart,secondaryStep,zStep: "&lt;&lt;yhat&lt;&lt;" "&lt;&lt;</span>
00341 <span class="comment">    event.jstart&lt;&lt;" "&lt;&lt;event.jstop&lt;&lt;" "&lt;&lt;event.secondaryStart&lt;&lt;" "&lt;&lt;event.zStart&lt;&lt;</span>
00342 <span class="comment">    " "&lt;&lt;event.secondaryStep&lt;&lt;" "&lt;&lt;event.zStep&lt;&lt;endl;</span>
00343 <span class="comment">    cout&lt;&lt;"downXSpread,upXSpread,downZSpread,upZSpread:"&lt;&lt;downXSpread&lt;&lt;" "&lt;&lt;upXSpread&lt;&lt;" "&lt;&lt;</span>
00344 <span class="comment">     downZSpread&lt;&lt;" "&lt;&lt;upZSpread&lt;&lt;endl;</span>
00345 <span class="comment">  } */</span>
00346 
00347   event.<a class="code" href="classEventPacket.html#o18">yhat</a> = yhat*event.<a class="code" href="classEventPacket.html#o10">atten</a>*event.<a class="code" href="classEventPacket.html#o9">norm</a>*event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>
00348     *event.<a class="code" href="classEventPacket.html#o21">CijNorm</a>+event.<a class="code" href="classEventPacket.html#o8">rand</a>+event.<a class="code" href="classEventPacket.html#o11">scatter</a>;
00349   event.<a class="code" href="classEventPacket.html#o18">yhat</a> *= duration/1000;
00350 
00351   <span class="keywordtype">float</span> normFct = 0;
00352   <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o18">yhat</a>!=0)
00353     normFct = (<span class="keywordtype">float</span>)event.<a class="code" href="classEventPacket.html#o19">numEvents</a>*event.<a class="code" href="classEventPacket.html#o10">atten</a>*event.<a class="code" href="classEventPacket.html#o9">norm</a>*
00354       event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>*event.<a class="code" href="classEventPacket.html#o21">CijNorm</a> / event.<a class="code" href="classEventPacket.html#o18">yhat</a>;
00355   <span class="comment">//cout&lt;&lt;normFct&lt;&lt;" Y primary"&lt;&lt;endl;</span>
00356 
00357   x = event.<a class="code" href="classEventPacket.html#o2">secondaryStart</a>;
00358   z = event.<a class="code" href="classEventPacket.html#o3">zStart</a>;
00359   <span class="keywordflow">for</span>(jy=event.<a class="code" href="classEventPacket.html#o0">jstart</a>; jy&lt;=event.<a class="code" href="classEventPacket.html#o1">jstop</a>; jy++){
00360 
00361     jxCentral = (<span class="keywordtype">int</span>)(x);<span class="comment">//we have maken sure that floor(x)&gt;=0</span>
00362     jzCentral = (<span class="keywordtype">int</span>)(z);<span class="comment">//we have maken sure that floor(z)&gt;=0</span>
00363     dxCentral = jxCentral+0.5-x; <span class="comment">//+0.5 to transfer image index </span>
00364                                  <span class="comment">//to image coordinate system</span>
00365     dzCentral = jzCentral+0.5-z;
00366     table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a> = jxCentral - downXSpread;<span class="comment">//int</span>
00367     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>&lt;0) {
00368       table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>=0;
00369     }
00370     table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a> = jxCentral + upXSpread;
00371     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>&gt;params.geometry.nX-1){
00372       table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>=params.geometry.nX-1;
00373     }
00374     table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a> = jzCentral - downZSpread;
00375     <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>&lt;0){
00376       table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>=0;
00377     }
00378     table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> = jzCentral + upZSpread;
00379    <span class="keywordflow">if</span>(table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a> &gt; params.geometry.nZ-1){
00380      table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>=params.geometry.nZ-1;
00381    }
00382    dRStart = (dxCentral - downXSpread) * event.<a class="code" href="classEventPacket.html#o23">cosphi</a>;
00383    dUStart = (dzCentral - downZSpread) * event.<a class="code" href="classEventPacket.html#o24">costheta</a>;
00384 
00385    <span class="comment">//calculate the kernel of resolution function R</span>
00386    <span class="keywordflow">for</span>(jx=table.<a class="code" href="structMOLAR_1_1Table.html#o0">secondaryStart</a>; jx&lt;=table.<a class="code" href="structMOLAR_1_1Table.html#o1">secondaryStop</a>; jx++){  
00387      <span class="keywordflow">for</span>(jz=table.<a class="code" href="structMOLAR_1_1Table.html#o2">zStart</a>; jz &lt;= table.<a class="code" href="structMOLAR_1_1Table.html#o3">zStop</a>; jz++) {    
00388    
00389        <span class="keywordtype">float</span> kernel =  resFunRTable[jy][jx]*resFunUTable[jy][jz];
00390         
00391        nu.<a class="code" href="classArray3D.html#p2">z</a>[jy][jz][jx] +=kernel* normFct*omega[jy] ;
00392       
00393      }
00394    }
00395    <span class="comment">//next </span>
00396    x += event.<a class="code" href="classEventPacket.html#o4">secondaryStep</a>;
00397    z += event.<a class="code" href="classEventPacket.html#o5">zStep</a>;
00398   }
00399 }
00400 
<a name="l00408"></a><a class="code" href="classAlgorithm.html#a3">00408</a> <span class="keywordtype">void</span> <a class="code" href="classAlgorithm.html#a3">Algorithm::collectEstimates</a>(<a class="code" href="classEventList.html">EventList</a> &amp;eventList) {
00409    <span class="keywordtype">double</span> scatterEstimate=0., yhat=0., randomsEstimate=0., events=0.;
00410    <span class="keywordtype">double</span> randoms=0., scatter=0.;
00411    Status *status = Status::getStatus();
00412    <a class="code" href="classFrameInfo.html">FrameInfo</a> *fi = FrameInfo::getInstance();
00413    <a class="code" href="classEventPacket.html">EventPacket</a> event; <span class="comment">//event extracted from the event list</span>
00414    <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); <span class="comment">//prepare for sentry</span>
00415    Params *params = Params::getInstance();
00416    <span class="keywordflow">for</span>(status-&gt;subset=0;status-&gt;subset&lt;
00417       params-&gt;algorithm.numSets;status-&gt;subset++){
00418 
00419       event = eventList.<a class="code" href="classEventList.html#a3">getFirst</a>(status-&gt;subset);<span class="comment">//Get first event</span>
00420                 
00421       <span class="keywordflow">while</span> (!(event==sentry)) {
00422         <span class="comment">// be sure the event is still in play</span>
00423         <span class="keywordflow">if</span> (event.<a class="code" href="classEventPacket.html#o1">jstop</a> &gt;= event.<a class="code" href="classEventPacket.html#o0">jstart</a>) {
00424           events++;
00425           scatter += event.<a class="code" href="classEventPacket.html#o11">scatter</a>;
00426           randoms += event.<a class="code" href="classEventPacket.html#o8">rand</a>;
00427           scatterEstimate += event.<a class="code" href="classEventPacket.html#o11">scatter</a>*(fi-&gt;<a class="code" href="classFrameInfo.html#o3">Duration</a>/1000.0)/event.<a class="code" href="classEventPacket.html#o18">yhat</a>;
00428           randomsEstimate += event.<a class="code" href="classEventPacket.html#o8">rand</a>*(fi-&gt;<a class="code" href="classFrameInfo.html#o3">Duration</a>/1000.0)/event.<a class="code" href="classEventPacket.html#o18">yhat</a>;
00429           yhat += event.<a class="code" href="classEventPacket.html#o18">yhat</a>;
00430         }
00431 
00432         event = eventList.<a class="code" href="classEventList.html#a4">getNext</a>(status-&gt;subset);
00433       }
00434    }
00435 
00436    <span class="comment">//global sum all </span>
00437    
00438    MPI::COMM_WORLD.Barrier();
00439    <span class="keywordtype">double</span> totalEvents = events;
00440    MPI::COMM_WORLD.Allreduce(&amp;events, &amp;totalEvents , 1, 
00441                             MPI::DOUBLE, MPI::SUM);
00442    <span class="keywordtype">double</span> totalScatterEstimate = scatterEstimate;
00443    MPI::COMM_WORLD.Allreduce(&amp;scatterEstimate, &amp;totalScatterEstimate , 1, 
00444                             MPI::DOUBLE, MPI::SUM);
00445    <span class="keywordtype">double</span> totalRandomsEstimate = randomsEstimate;
00446    MPI::COMM_WORLD.Allreduce(&amp;randomsEstimate, &amp;totalRandomsEstimate , 1, 
00447                             MPI::DOUBLE, MPI::SUM);
00448    <span class="keywordtype">double</span> totalScatter = scatter;
00449    MPI::COMM_WORLD.Allreduce(&amp;scatter, &amp;totalScatter , 1, 
00450                             MPI::DOUBLE, MPI::SUM);
00451    <span class="keywordtype">double</span> totalRandoms = randoms;
00452    MPI::COMM_WORLD.Allreduce(&amp;randoms, &amp;totalRandoms , 1, 
00453                             MPI::DOUBLE, MPI::SUM);
00454    <span class="keywordtype">double</span> totalYhat = yhat;
00455    MPI::COMM_WORLD.Allreduce(&amp;yhat, &amp;totalYhat , 1, 
00456                             MPI::DOUBLE, MPI::SUM);
00457    <span class="keywordflow">if</span>(status-&gt;proc == 0) {
00458       <span class="keywordtype">double</span> randomsFraction=0., scatterFraction=0.;
00459       scatterFraction = static_cast&lt;float&gt; (totalScatterEstimate/(totalEvents - totalRandomsEstimate));
00460       randomsFraction = static_cast&lt;float&gt; (totalRandomsEstimate/totalEvents);
00461       cout&lt;&lt;<span class="stringliteral">"In collectEstimates"</span>&lt;&lt;endl;
00462       cout&lt;&lt;<span class="stringliteral">"totalEvents="</span>&lt;&lt;totalEvents&lt;&lt;endl;
00463       cout&lt;&lt;<span class="stringliteral">"totalScatterEstimate="</span>&lt;&lt;totalScatterEstimate&lt;&lt;endl;
00464       cout&lt;&lt;<span class="stringliteral">"totalRandomsEstimate="</span>&lt;&lt;totalRandomsEstimate&lt;&lt;endl;
00465       <span class="comment">// randoms and scater are count rates - convert to counts</span>
00466       fi-&gt;<a class="code" href="classFrameInfo.html#o16">totalRandomsEstimate</a> = static_cast&lt;float&gt; (totalRandoms * (fi-&gt;<a class="code" href="classFrameInfo.html#o3">Duration</a>/1000.));
00467       fi-&gt;<a class="code" href="classFrameInfo.html#o17">randomsFraction</a> = static_cast&lt;float&gt; (randomsFraction);
00468       fi-&gt;<a class="code" href="classFrameInfo.html#o19">totalScatterEstimate</a>(status-&gt;iter -1) = static_cast&lt;float&gt; (totalScatter * (fi-&gt;<a class="code" href="classFrameInfo.html#o3">Duration</a>/1000.));
00469       fi-&gt;<a class="code" href="classFrameInfo.html#o21">scatterFraction</a>(status-&gt;iter -1) = static_cast&lt;float&gt; (scatterFraction);
00470       fi-&gt;<a class="code" href="classFrameInfo.html#o20">totalYhatEstimate</a>(status-&gt;iter -1) = totalYhat;
00471 
00472       fi-&gt;<a class="code" href="classFrameInfo.html#a0">writeFrameInfo</a>();
00473    }
00474 }
00475 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Dec 13 14:13:46 2007 for reconHRRT by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
