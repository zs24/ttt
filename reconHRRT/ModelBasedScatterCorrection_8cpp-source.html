<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>reconHRRT: ModelBasedScatterCorrection.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>ModelBasedScatterCorrection.cpp</h1><div class="fragment"><pre>00001 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00002 <span class="preprocessor">#include &lt;math.h&gt;</span>
00003 <span class="preprocessor">#include &lt;time.h&gt;</span>
00004 <span class="preprocessor">#include "ModelBasedScatterCorrection.hpp"</span>
00005 
00006 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00007 
00008 ModelBasedScatterCorrection::ModelBasedScatterCorrection() {
00009 
00010 }
00011 
00012 ModelBasedScatterCorrection::~ModelBasedScatterCorrection() {
00013 }
00014 
00015 <span class="comment">/*******************************************************</span>
00016 <span class="comment"></span>
00017 <span class="comment">Compute dimensions of .sinograms. from scatter params</span>
00018 <span class="comment"></span>
00019 <span class="comment">Set up arrays for binning delays, prompts and scatter</span>
00020 <span class="comment"></span>
00021 <span class="comment">Create mask indicating which bins intersect the mu map</span>
00022 <span class="comment"></span>
00023 <span class="comment">*******************************************************/</span> 
00024 
00025 <span class="keywordtype">void</span> ModelBasedScatterCorrection::randomsScatterInit(<a class="code" href="classImage.html">Image</a> &amp;muImage) {
00026 
00027    Params *params = Params::getInstance();
00028    Status *status = Status::getStatus();
00029 
00030    <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.enable) {
00031 
00032     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
00033           status-&gt;printMemInfo();
00034     }
00035 
00036         <span class="keywordtype">unsigned</span> us_zero = 0;
00037         binDelays.init(endPointList.nAngles,endPointList.nSlices,
00038                 endPointList.nAngles,endPointList.nSlices);
00039         binDelays = us_zero;
00040 
00041         binPrompts.init(endPointList.nAngles,endPointList.nSlices,
00042                 endPointList.nAngles,endPointList.nSlices);
00043         binPrompts = us_zero;
00044         
00045         binRandomized.init(endPointList.nAngles,endPointList.nSlices,
00046                 endPointList.nAngles,endPointList.nSlices);
00047         binRandomized = 0.0;
00048 
00049         binInsideMask.init(endPointList.nAngles,endPointList.nSlices,
00050                 endPointList.nAngles,endPointList.nSlices);
00051 
00052     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
00053           status-&gt;printMemInfo();
00054     }
00055 
00056         coordIndex endPoint1;
00057         coordIndex endPoint2;
00058         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceA = 0; iSliceA &lt;= endPointList.nSlices-1; iSliceA++) {
00059                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleA = 0; iAngleA &lt;= endPointList.nAngles-1; iAngleA++) {
00060                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceB = 0; iSliceB &lt;= endPointList.nSlices-1; iSliceB++) {
00061                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleB = 0; iAngleB &lt;= endPointList.nAngles-1; iAngleB++) {
00062 
00063                                         endPoint1.x = endPointList.x(iAngleA,iSliceA);
00064                                         endPoint1.y = endPointList.y(iAngleA,iSliceA);
00065                                         endPoint1.z = endPointList.z(iAngleA,iSliceA);
00066                                         endPoint2.x = endPointList.x(iAngleB,iSliceB);
00067                                         endPoint2.y = endPointList.y(iAngleB,iSliceB);
00068                                         endPoint2.z = endPointList.z(iAngleB,iSliceB);
00069                                         binInsideMask(iAngleA,iSliceA,iAngleB,iSliceB) = isInsideMuMap(endPoint1,endPoint2,muImage); 
00070 <span class="comment">//if(status-&gt;proc == 0) cout &lt;&lt; "  muMap Mask: "&lt;&lt;iAngleA&lt;&lt;" "&lt;&lt;iSliceA&lt;&lt;" "&lt;&lt;iAngleB&lt;&lt;" "&lt;&lt;iSliceB&lt;&lt;"   MASK= "&lt;&lt;binInsideMask(iAngleA,iSliceA,iAngleB,iSliceB)&lt;&lt;endl;</span>
00071                                 }
00072                         }
00073                 }
00074         }
00075    }
00076 <span class="comment">/*</span>
00077 <span class="comment">//find edges and get neighboring elements</span>
00078 <span class="comment">   int nAngles = endPointList.nAngles;  </span>
00079 <span class="comment">   for (int iSliceB = 0; iSliceB &lt;= endPointList.nSlices-1; iSliceB++) {</span>
00080 <span class="comment">      for (int iAngleB = 0; iAngleB &lt;= endPointList.nAngles-1; iAngleB++) {</span>
00081 <span class="comment">         for (int iSliceA = 0; iSliceA &lt;= endPointList.nSlices-1; iSliceA++) {</span>
00082 <span class="comment">            int flag = 0;</span>
00083 <span class="comment">            for (int iAngleA = 0; iAngleA &lt;= endPointList.nAngles-1; iAngleA++) {</span>
00084 <span class="comment">               if (   binInsideMask((iAngleA-iAngleB+nAngles)   % nAngles,iSliceA,iAngleB,iSliceB) != flag and flag == 0 and iAngleA &gt; 2) {</span>
00085 <span class="comment">                  if (binInsideMask((iAngleA-iAngleB+nAngles-4) % nAngles,iSliceA,iAngleB,iSliceB) == 0) {</span>
00086 <span class="comment">                      binInsideMask((iAngleA-iAngleB+nAngles-4) % nAngles,iSliceA,iAngleB,iSliceB) = 4;</span>
00087 <span class="comment">                  }</span>
00088 <span class="comment">                  if (binInsideMask((iAngleA-iAngleB+nAngles-3) % nAngles,iSliceA,iAngleB,iSliceB) == 0) {</span>
00089 <span class="comment">                      binInsideMask((iAngleA-iAngleB+nAngles-3) % nAngles,iSliceA,iAngleB,iSliceB) = 3;</span>
00090 <span class="comment">                  }</span>
00091 <span class="comment">                  if (binInsideMask((iAngleA-iAngleB+nAngles-2) % nAngles,iSliceA,iAngleB,iSliceB) == 0) {</span>
00092 <span class="comment">                      binInsideMask((iAngleA-iAngleB+nAngles-2) % nAngles,iSliceA,iAngleB,iSliceB) = 2;</span>
00093 <span class="comment">                  }</span>
00094 <span class="comment">                  flag = 1;</span>
00095 <span class="comment">               }</span>
00096 <span class="comment">               if (   binInsideMask((iAngleA-iAngleB+nAngles)   % nAngles,iSliceA,iAngleB,iSliceB) != flag and flag == 1 and iAngleA &lt; nAngles-2) {</span>
00097 <span class="comment">                  if (binInsideMask((iAngleA-iAngleB+nAngles+1) % nAngles,iSliceA,iAngleB,iSliceB) == 0) {</span>
00098 <span class="comment">                      binInsideMask((iAngleA-iAngleB+nAngles+1) % nAngles,iSliceA,iAngleB,iSliceB) = 2;</span>
00099 <span class="comment">                  }</span>
00100 <span class="comment">                  if (binInsideMask((iAngleA-iAngleB+nAngles+2) % nAngles,iSliceA,iAngleB,iSliceB) == 0) {</span>
00101 <span class="comment">                      binInsideMask((iAngleA-iAngleB+nAngles+2) % nAngles,iSliceA,iAngleB,iSliceB) = 3;</span>
00102 <span class="comment">                  }</span>
00103 <span class="comment">                  if (binInsideMask((iAngleA-iAngleB+nAngles+3) % nAngles,iSliceA,iAngleB,iSliceB) == 0) {</span>
00104 <span class="comment">                      binInsideMask((iAngleA-iAngleB+nAngles+3) % nAngles,iSliceA,iAngleB,iSliceB) = 4;</span>
00105 <span class="comment">                  }</span>
00106 <span class="comment">                  flag = 0;</span>
00107 <span class="comment">               }</span>
00108 <span class="comment">            }</span>
00109 <span class="comment">         }</span>
00110 <span class="comment">      }</span>
00111 <span class="comment">   }</span>
00112 <span class="comment">*/</span>                              
00113    <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
00114          status-&gt;printMemInfo();
00115    }
00116 <span class="comment">//TESTING</span>
00117 <span class="comment">//if(status-&gt;proc == 0){</span>
00118 <span class="comment">//  cout&lt;&lt;"TEST RUN EXITING."&lt;&lt;endl;</span>
00119 <span class="comment">//  Utilities::cleanUp(Constant::UNKNOWN);</span>
00120 <span class="comment">//}</span>
00121 
00122    xtalDelays.init(scannerParams-&gt;dtctPerBlock*scannerParams-&gt;dtctPerBlock*scannerParams-&gt;nLayer);
00123    xtalDelays = 0.0;
00124         
00125    blockSingles.init(scannerParams-&gt;nBlock);
00126    blockSingles = 0.0;
00127         
00128    blockSingles2.init(scannerParams-&gt;nBlock);
00129    blockSingles2 = 0.0;
00130         
00131    nblockSingles.init(scannerParams-&gt;nBlock);
00132    nblockSingles = 0;
00133         
00134    layerDelays.init(scannerParams-&gt;nLayer,scannerParams-&gt;nLayer);
00135    layerDelays = 0.0;
00136         
00137    tau.init(scannerParams-&gt;nLayer,scannerParams-&gt;nLayer);
00138    tau = 0.0;
00139     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
00140           status-&gt;printMemInfo();
00141     }
00142 
00143 }
00144 
00145 <span class="comment">/*******************************************************</span>
00146 <span class="comment"></span>
00147 <span class="comment">Compute dimensions of .sinograms. from scatter params</span>
00148 <span class="comment"></span>
00149 <span class="comment">Set up arrays for binning delays, prompts and scatter</span>
00150 <span class="comment"></span>
00151 <span class="comment">Create mask indicating which bins intersect the mu map</span>
00152 <span class="comment"></span>
00153 <span class="comment">*******************************************************/</span> 
00154 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::isInsideMuMap(coordIndex &amp;point1, coordIndex &amp;point2, <a class="code" href="classImage.html">Image</a> &amp;muImage) {
00155 
00156         Params &amp;params = *Params::getInstance();
00157         Status *status = Status::getStatus();
00158         
00159         <span class="keywordtype">int</span> debug = params.modelBasedScatter.verbosity;
00160         <span class="comment">// Compute ray sum for a given scatter point and end point pair and an image volume</span>
00161   
00162 <span class="comment">//      float muMaskThreshold = params-&gt;modelBasedScatter.muMaskThreshold;</span>
00163 <span class="keywordtype">float</span> muMaskThreshold = 0.005;
00164 
00165         <span class="keywordtype">int</span> jxmax = params.geometry.nX-1;
00166         <span class="keywordtype">int</span> jymax = params.geometry.nY-1;
00167         <span class="keywordtype">int</span> jzmax = params.geometry.nZ-1;
00168 
00169 <span class="comment">//if(status-&gt;proc == 0) cout&lt;&lt;"jxmax,jymax,jzmax: "&lt;&lt;jxmax&lt;&lt;" "&lt;&lt;jymax&lt;&lt;" "&lt;&lt;jzmax&lt;&lt;endl;</span>
00170 
00171         <span class="comment">// Get the image indices corresponding to the point locations</span>
00172 
00173         <span class="keywordtype">float</span> x1 = point1.x;
00174         <span class="keywordtype">float</span> y1 = point1.y;
00175         <span class="keywordtype">float</span> z1 = point1.z;
00176         <span class="keywordtype">float</span> x2 = point2.x;
00177         <span class="keywordtype">float</span> y2 = point2.y;
00178         <span class="keywordtype">float</span> z2 = point2.z;
00179 
00180 <span class="comment">//if(status-&gt;proc == 0) cout&lt;&lt;"x1,y1,z1: "&lt;&lt;x1&lt;&lt;" "&lt;&lt;y1&lt;&lt;" "&lt;&lt;z1&lt;&lt;endl;</span>
00181 <span class="comment">//if(status-&gt;proc == 0) cout&lt;&lt;"x2,y2,z2: "&lt;&lt;x2&lt;&lt;" "&lt;&lt;y2&lt;&lt;" "&lt;&lt;z2&lt;&lt;endl;</span>
00182         
00183         imgIndex pointIndex1;
00184         imgIndex pointIndex2;
00185         <span class="keywordflow">if</span> (!convertCoordinatesToImageIndices(point1, pointIndex1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00186         <span class="keywordflow">if</span> (!convertCoordinatesToImageIndices(point2, pointIndex2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00187         
00188         <span class="keywordtype">float</span> jx1 = pointIndex1.x;
00189         <span class="keywordtype">float</span> jy1 = pointIndex1.y;
00190         <span class="keywordtype">float</span> jz1 = pointIndex1.z;
00191         <span class="keywordtype">float</span> jx2 = pointIndex2.x;
00192         <span class="keywordtype">float</span> jy2 = pointIndex2.y;
00193         <span class="keywordtype">float</span> jz2 = pointIndex2.z;
00194 <span class="comment">//if(status-&gt;proc == 0) cout&lt;&lt;"jx1,jy1,jz1: "&lt;&lt;jx1&lt;&lt;" "&lt;&lt;jy1&lt;&lt;" "&lt;&lt;jz1&lt;&lt;endl;</span>
00195 <span class="comment">//if(status-&gt;proc == 0) cout&lt;&lt;"jx2,jy2,jz2: "&lt;&lt;jx2&lt;&lt;" "&lt;&lt;jy2&lt;&lt;" "&lt;&lt;jz2&lt;&lt;endl;</span>
00196 <span class="comment">//</span>
00197 <span class="comment">//      ; Compute the direction cosines (l,m,n) for the ray connecting the two locations</span>
00198 <span class="comment">//</span>
00199         <span class="keywordtype">float</span> d = sqrt( POW2(x1-x2) + POW2(y1-y2) + POW2(z1-z2) );
00200         <span class="keywordtype">float</span> l = (x2 - x1) / d;
00201         <span class="keywordtype">float</span> m = (y2 - y1) / d;
00202         <span class="keywordtype">float</span> n = (z2 - z1) / d;
00203 <span class="comment">//</span>
00204 <span class="comment">//      ; Begin the ray tracing </span>
00205 <span class="comment">//</span>
00206         <span class="keywordtype">float</span> delta = 1.0; <span class="comment">//distance to step in ray sum</span>
00207         <span class="keywordtype">float</span> i = 0.0;
00208         <span class="keywordtype">float</span> x = x1;
00209         <span class="keywordtype">float</span> y = y1;
00210         <span class="keywordtype">float</span> z = z1;
00211         <span class="keywordtype">int</span> jx = jx1;
00212         <span class="keywordtype">int</span> jy = jy1;
00213         <span class="keywordtype">int</span> jz = jz1;
00214         
00215         <span class="keywordtype">float</span> distance1 = POW2(x-x2) + POW2(y-y2) + POW2(z-z2);
00216         <span class="keywordtype">float</span> distance2 = 0.0;
00217         coordIndex point;
00218         imgIndex index;
00219 
00220         <span class="keywordflow">while</span> ((jx != jx2) || (jy != jy2) || (jz != jz2)) {
00221 
00222 <span class="comment">//if(status-&gt;proc == 0) cout&lt;&lt;"jx,jy,jz="&lt;&lt;jx&lt;&lt;","&lt;&lt;jy&lt;&lt;","&lt;&lt;jz&lt;&lt;endl;</span>
00223 
00224                 <span class="keywordflow">if</span> ((jx &gt;= 0 &amp;&amp; jx &lt;= jxmax) &amp;&amp; (jy &gt;= 0 &amp;&amp; jy &lt;= jymax) &amp;&amp; (jz &gt;= 0 &amp;&amp; jz &lt;= jzmax)) {
00225 
00226 <span class="comment">//if(status-&gt;proc == 0) cout&lt;&lt;"muImage("&lt;&lt;jx&lt;&lt;","&lt;&lt;jy&lt;&lt;","&lt;&lt;jz&lt;&lt;") = "&lt;&lt;muImage(jx,jy,jz)&lt;&lt;"    "&lt;&lt;muMaskThreshold&lt;&lt;endl;</span>
00227 
00228                         <span class="keywordflow">if</span> (muImage(jx,jy,jz) &gt; muMaskThreshold) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00229                 }
00230                 i += 1.0;
00231                 x = x1 + i*l*delta;
00232                 y = y1 + i*m*delta;
00233                 z = z1 + i*n*delta;
00234 
00235                 distance2 = POW2(x-x2) + POW2(y-y2) + POW2(z-z2);
00236                 <span class="keywordflow">if</span> (distance2 &gt; distance1) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00237                 distance1 = distance2;
00238 
00239                 point.x = x;
00240                 point.y = y;
00241                 point.z = z;
00242 
00243                 <span class="keywordflow">if</span> (!convertCoordinatesToImageIndices(point, index)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00244                 
00245                 jx = index.x;
00246                 jy = index.y;
00247                 jz = index.z;
00248                 
00249         }
00250         <span class="keywordflow">return</span> <span class="keyword">false</span>; 
00251 }
00252 
00253 <span class="comment">/*</span>
00254 <span class="comment">//===============================================================================</span>
00255 <span class="comment">//+</span>
00256 <span class="comment">//       NAME</span>
00257 <span class="comment">//               init</span>
00258 <span class="comment">//</span>
00259 <span class="comment">//       SYNOPSIS</span>
00260 <span class="comment">//               init()</span>
00261 <span class="comment">//</span>
00262 <span class="comment">//       INPUT</span>
00263 <span class="comment">//               none</span>
00264 <span class="comment">//</span>
00265 <span class="comment">//       OUTPUT</span>
00266 <span class="comment">//               frameInfo - structure containing frame-specific info</span>
00267 <span class="comment">//               house - structure containing "house" data</span>
00268 <span class="comment">//               params - structure containing all the various parameter values</span>
00269 <span class="comment">//               scanner - structure describing the PET scanner hardware</span>
00270 <span class="comment">//               status - structure containing recon status variables </span>
00271 <span class="comment">//               errMsg - informational message for error handler</span>
00272 <span class="comment">//</span>
00273 <span class="comment">//       DESCRIPTION</span>
00274 <span class="comment">//               Perform the initialization needed to begin the reconstruction</span>
00275 <span class="comment">//</span>
00276 <span class="comment">//       HISTORY</span>
00277 <span class="comment">//               03/02/04 - st - Porting it to C++</span>
00278 <span class="comment">//               01/01/04 - cb - original code validated</span>
00279 <span class="comment">//-</span>
00280 <span class="comment">//===============================================================================</span>
00281 <span class="comment">*/</span>
00282 
00283 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::init(<a class="code" href="classImage.html">Image</a> &amp;muImage) {
00284 
00285         checkSum = <span class="keyword">sizeof</span>(ModelBasedScatterCorrection);
00286 
00287         Status *status = Status::getStatus();
00288         <span class="keywordflow">if</span>(status-&gt;proc == 0) {
00289                 cout &lt;&lt; <span class="stringliteral">"In ModelBasedScatter init\n"</span>;
00290                 cout.flush();
00291         }
00292         this-&gt;molar = <a class="code" href="classMOLAR.html#e0">MOLAR::getInstance</a>();
00293         this-&gt;params = Params::getInstance();
00294         this-&gt;house = molar-&gt;getHouse();
00295 
00296         this-&gt;scannerParams = <a class="code" href="classHRRTScannerParams.html#e0">HRRTScannerParams::getInstance</a>();
00297     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
00298           status-&gt;printMemInfo();
00299     }
00300 
00301 
00302         <span class="keywordflow">if</span>(!setupStructs()) {
00303                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00304         }
00305 
00306         <span class="comment">// Setup scanner specific parameters</span>
00307         <span class="keywordflow">if</span>(!setupScanner()) {
00308                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00309         }
00310 
00311         <span class="comment">// Compute scatter computation endpoint locations - a structure of (x,y,z) coordinates</span>
00312 
00313         <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.enable) {
00314                 <span class="keywordflow">if</span> (!defineEndPoints()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00315         }
00316         
00317 <span class="preprocessor">#ifdef SCATTER_DEBUG</span>
00318 <span class="preprocessor"></span>        validateEndPoints();
00319 
00320         randomsScatterPrep(0,1.);
00321 <span class="preprocessor">#endif </span><span class="comment">/* SCATTER_DEBUG */</span>
00322 
00323         <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt; 5) {
00324                 LORCoords1 = <span class="keyword">new</span> DList&lt;coordIndex&gt;;
00325                 LORCoords2 = <span class="keyword">new</span> DList&lt;coordIndex&gt;;
00326                 LORIntCoords1 = <span class="keyword">new</span> DList&lt;coordIndex&gt;;
00327                 LORIntCoords2 = <span class="keyword">new</span> DList&lt;coordIndex&gt;;
00328                 endPointCoords1 = <span class="keyword">new</span> DList&lt;coordIndex&gt;;
00329                 endPointCoords2 = <span class="keyword">new</span> DList&lt;coordIndex&gt;;
00330         }
00331 
00332         randomsScatterInit(muImage);
00333 
00334         <span class="comment">//Init the Statistics struct</span>
00335         eventStats.nTimeTags = eventStats.nSingleTags = eventStats.nEvents = eventStats.nNonEvents = 0; 
00336         eventStats.binnedPrompts = eventStats.binnedDelays = 0;
00337 
00338 
00339         <span class="comment">//Sentry scatter point - hoping that we dont have a scatter point at the origin - shanta ?</span>
00340     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
00341           status-&gt;printMemInfo();
00342     }
00343 
00344         sentryPoint.x = 0; sentryPoint.y=0 ; sentryPoint.z=0;
00345         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00346 }
00347 
00379 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::randomsScatterPrep(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> *b, <span class="keywordtype">float</span> sing_fix) {
00380   <span class="comment">//check if the pointer initialized when use it</span>
00381   <span class="keywordflow">if</span>(!checkValid()){
00382     cout&lt;&lt;<span class="stringliteral">"Error in use of ModelBasedScatterCorrection"</span>
00383         &lt;&lt;<span class="stringliteral">"Programmer make sure call the getInstance"</span>
00384         &lt;&lt;<span class="stringliteral">"Program aborted"</span>&lt;&lt;endl;
00385     cout.flush();
00386     <a class="code" href="classUtilities.html#e8">Utilities::cleanUp</a>(Constant::POINTERERROR);
00387   }
00388         Params *params = Params::getInstance();
00389         Status *status = Status::getStatus();
00390 
00391         <a class="code" href="structCrystalID.html">CrystalID</a> e1, e2;
00392         <a class="code" href="classEventPacket.html">EventPacket</a> event;
00393 
00394         <span class="keywordflow">if</span>(house-&gt;isTimeTag(b)) {
00395                 ++eventStats.nTimeTags;
00396                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00397         }
00398         <span class="keywordflow">if</span>(house-&gt;isSinglesTag(b)) {
00399                 ++eventStats.nSingleTags;
00400                 processSinglesTag(b, sing_fix);
00401                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00402         }
00403         
00404         <span class="keywordflow">if</span> (house-&gt;isEvent(b)){ <span class="comment">//an event</span>
00405         
00406                 ++eventStats.nEvents;
00407                 <span class="keywordflow">if</span> (house-&gt;processEvent(b,e1,e2)) { <span class="comment">//decode the bits</span>
00408                    <span class="comment">//2006-02-20 moved summing of xtalDelays (used to determine apparent tau) abopve the point where</span>
00409                    <span class="comment">// we reject events if outside the FOV  </span>
00410                    <span class="keywordflow">if</span> (e2.<a class="code" href="structCrystalID.html#o7">tag</a> ==0) { <span class="comment">//a delay</span>
00411                      <span class="comment">//tally up delays crystal by crystal for a 'generic block'</span>
00412                      <span class="keywordtype">int</span> nDetPerBlock = scannerParams-&gt;dtctPerBlock;
00413                      <span class="keywordtype">int</span> xtal1 = (e1.<a class="code" href="structCrystalID.html#o0">dtct</a> % nDetPerBlock) + (e1.<a class="code" href="structCrystalID.html#o1">ring</a> % nDetPerBlock)*nDetPerBlock + e1.<a class="code" href="structCrystalID.html#o3">layer</a>*nDetPerBlock*nDetPerBlock;
00414                      <span class="keywordtype">int</span> xtal2 = (e2.<a class="code" href="structCrystalID.html#o0">dtct</a> % nDetPerBlock) + (e2.<a class="code" href="structCrystalID.html#o1">ring</a> % nDetPerBlock)*nDetPerBlock + e2.<a class="code" href="structCrystalID.html#o3">layer</a>*nDetPerBlock*nDetPerBlock;
00415 
00416                      xtalDelays[xtal1]++;
00417                      xtalDelays[xtal2]++;
00418 
00419                      layerDelays(e1.<a class="code" href="structCrystalID.html#o3">layer</a>,e2.<a class="code" href="structCrystalID.html#o3">layer</a>)++;
00420                    }
00421                    <span class="comment">//house-&gt;getEventCoordinates(e1,e2,event); altered 2006-02-02</span>
00422                    <span class="keywordflow">if</span> (house-&gt;calculateEventParams(e1,e2,event,0)) { <span class="comment">//reject out of FOV events</span>
00423 
00424                       coordIndex A,B;
00425                       A.x = event.<a class="code" href="classEventPacket.html#o12">x1</a>, A.y = event.<a class="code" href="classEventPacket.html#o13">y1</a>, A.z = event.<a class="code" href="classEventPacket.html#o14">z1</a>; 
00426                       B.x = event.<a class="code" href="classEventPacket.html#o15">x2</a>, B.y = event.<a class="code" href="classEventPacket.html#o16">y2</a>, B.z = event.<a class="code" href="classEventPacket.html#o17">z2</a>; 
00427 
00428                       neighborIndex neighborlist;
00429 
00430                       <span class="keywordtype">int</span> iAngleA = 0;
00431                       <span class="keywordtype">int</span> iAngleB = 0;
00432                       <span class="keywordtype">int</span> izA = 0;
00433                       <span class="keywordtype">int</span> izB = 0;
00434                 
00435                       <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.enable) {
00436                           <span class="keywordflow">if</span> (!getNearestEndPoints(A, B, neighborlist)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00437                           iAngleA = neighborlist.iAngleA[2];
00438                           iAngleB = neighborlist.iAngleB[2];
00439                           izA = neighborlist.izA[2];
00440                           izB = neighborlist.izB[2];
00441 
00442                           <span class="keywordflow">if</span>(izA &lt; 0 || izA &gt;= endPointList.nSlices || 
00443                              izB &lt; 0 || izB &gt;= endPointList.nSlices || 
00444                              iAngleA &lt; 0 || iAngleA &gt;= endPointList.nAngles || 
00445                              iAngleB &lt; 0 || iAngleB &gt;= endPointList.nAngles) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00446 
00447                           <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt;= 5) {
00448                              cout &lt;&lt; <span class="stringliteral">"Event Coords: x1: "</span>&lt;&lt;A.x&lt;&lt;<span class="stringliteral">" y1: "</span>&lt;&lt;A.y&lt;&lt;<span class="stringliteral">" z1: "</span>&lt;&lt;A.z&lt;&lt;<span class="stringliteral">"\n"</span>;
00449                              cout &lt;&lt; <span class="stringliteral">"Event Coords: x2: "</span>&lt;&lt;B.x&lt;&lt;<span class="stringliteral">" y2: "</span>&lt;&lt;B.y&lt;&lt;<span class="stringliteral">" z2: "</span>&lt;&lt;B.z&lt;&lt;<span class="stringliteral">"\n"</span>;
00450                              cout &lt;&lt; <span class="stringliteral">"EndPoint Coords: x1: "</span>&lt;&lt;endPointList.x(iAngleA, izA)
00451                              &lt;&lt;<span class="stringliteral">" y1: "</span>&lt;&lt;endPointList.y(iAngleA, izA)
00452                              &lt;&lt;<span class="stringliteral">" z1: "</span>&lt;&lt;endPointList.z(iAngleA, izA)&lt;&lt;<span class="stringliteral">"\n"</span>;
00453                              cout &lt;&lt; <span class="stringliteral">"EndPoint Coords: x2: "</span>&lt;&lt;endPointList.x(iAngleB, izB)
00454                              &lt;&lt;<span class="stringliteral">" y2: "</span>&lt;&lt;endPointList.y(iAngleB, izB)
00455                              &lt;&lt;<span class="stringliteral">" z2: "</span>&lt;&lt;endPointList.z(iAngleB, izB)&lt;&lt;<span class="stringliteral">"\n"</span>;
00456                              cout &lt;&lt; <span class="stringliteral">"Neighbor Coords: iAngleA: "</span>&lt;&lt;iAngleA&lt;&lt;<span class="stringliteral">" iAngleB: "</span>&lt;&lt;iAngleB&lt;&lt;<span class="stringliteral">"\n"</span>;
00457                              cout &lt;&lt; <span class="stringliteral">"Neighbor Coords: izA: "</span>&lt;&lt;izA&lt;&lt;<span class="stringliteral">" izB: "</span>&lt;&lt;izB&lt;&lt;<span class="stringliteral">"\n"</span>;
00458                           }
00459 
00460                       }
00461                       <span class="keywordflow">if</span> (e2.<a class="code" href="structCrystalID.html#o7">tag</a> ==1) { <span class="comment">//a real event or prompt</span>
00462                           eventStats.binnedPrompts++;
00463                           <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.enable) binPrompts(iAngleA,izA,iAngleB,izB)++;<span class="comment">// += 0.5;  </span>
00464                           <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.enable) binPrompts(iAngleB,izB,iAngleA,izA)++;<span class="comment">// += 0.5;  </span>
00465                       } <span class="keywordflow">else</span>{<span class="comment">//a random</span>
00466                           eventStats.binnedDelays++;
00467                           <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.enable) binDelays(iAngleA,izA,iAngleB,izB)++;<span class="comment">// += 0.5;  </span>
00468                           <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.enable) binDelays(iAngleB,izB,iAngleA,izA)++;<span class="comment">// += 0.5;  </span>
00469 
00470                         
00471                      }
00472                 } <span class="comment">//calculateEventParams</span>
00473            } <span class="comment">//processEvent</span>
00474         } <span class="keywordflow">else</span>{  <span class="comment">//nonevent, continue reading</span>
00475         
00476                 ++eventStats.nNonEvents;
00477    <span class="comment">//                   processNonEvent(b); //decode the bits</span>
00478         }
00479         
00480         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00481 }
00482 
00483 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::binRandomizedEvent(<a class="code" href="classEventPacket.html">EventPacket</a> &amp;event) {
00484         coordIndex A,B;
00485         A.x = event.<a class="code" href="classEventPacket.html#o12">x1</a>, A.y = event.<a class="code" href="classEventPacket.html#o13">y1</a>, A.z = event.<a class="code" href="classEventPacket.html#o14">z1</a>; 
00486         B.x = event.<a class="code" href="classEventPacket.html#o15">x2</a>, B.y = event.<a class="code" href="classEventPacket.html#o16">y2</a>, B.z = event.<a class="code" href="classEventPacket.html#o17">z2</a>; 
00487 
00488         neighborIndex neighborlist;
00489 
00490         <span class="keywordtype">int</span> iAngleA = 0;
00491         <span class="keywordtype">int</span> iAngleB = 0;
00492         <span class="keywordtype">int</span> izA = 0;
00493         <span class="keywordtype">int</span> izB = 0;
00494                 
00495         <span class="keywordflow">if</span> (!getNearestEndPoints(A, B, neighborlist)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00496         iAngleA = neighborlist.iAngleA[2];
00497         iAngleB = neighborlist.iAngleB[2];
00498         izA = neighborlist.izA[2];
00499         izB = neighborlist.izB[2];
00500 
00501         <span class="keywordflow">if</span>(izA &lt; 0 || izA &gt;= endPointList.nSlices || 
00502                 izB &lt; 0 || izB &gt;= endPointList.nSlices || 
00503                 iAngleA &lt; 0 || iAngleA &gt;= endPointList.nAngles || 
00504                 iAngleB &lt; 0 || iAngleB &gt;= endPointList.nAngles) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00505         <span class="comment">// 2002-02-27 at this point, we began to institute nonuniform random sampling</span>
00506         <span class="comment">// for Q calculation to help the stats. We do this by sampling the front layer 3 times more</span>
00507         <span class="comment">// often than the back layer (see HRRTHouseEvent.cpp). We keep the final answer correct</span>
00508         <span class="comment">// by scaling the livetime_decay term so the mean value of Q does not change.</span>
00509         <span class="comment">// This should *by luck) fix this calculation as well</span>
00510         binRandomized(iAngleA,izA,iAngleB,izB) += event.<a class="code" href="classEventPacket.html#o9">norm</a> * event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>;
00511         binRandomized(iAngleB,izB,iAngleA,izA) += event.<a class="code" href="classEventPacket.html#o9">norm</a> * event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>;
00512 
00513         <span class="keywordflow">if</span>(( event.<a class="code" href="classEventPacket.html#o9">norm</a> * event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>) &gt; 1.0) {
00514                 cout&lt;&lt;<span class="stringliteral">"binRandomized("</span>&lt;&lt;iAngleA&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;izA&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;iAngleB&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;izB&lt;&lt;<span class="stringliteral">" = "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o9">norm</a>&lt;&lt;<span class="stringliteral">" * "</span>&lt;&lt;event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>&lt;&lt;<span class="stringliteral">"\n"</span>;
00515         }
00516         
00517         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00518 
00519 }
00520 
00521 <span class="comment">//process the singles tag</span>
00522 <span class="keywordtype">void</span> ModelBasedScatterCorrection::processSinglesTag(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> *b, <span class="keywordtype">float</span> sing_fix)
00523 {
00524   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> b2 = b[2];
00525   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> b0 = b[0];
00526   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> block = (b[2] &amp; 0x1ff8) &gt;&gt;3; <span class="comment">//block number</span>
00527   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> countrates = ((b2 &amp; 0x7)&lt;&lt;16) + b0; <span class="comment">//counter rates</span>
00528   countrates *= sing_fix;       <span class="comment">// fix from stuck singles rates</span>
00529   blockSingles(block) += countrates;
00530   blockSingles2(block) += POW2(countrates);
00531   nblockSingles(block) ++;      <span class="comment">// number of measurements</span>
00532 
00533 }
00534 
00560 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::randomsScatterProc() {
00561 
00562   <span class="comment">//check if the pointer initialized when use it</span>
00563   <span class="keywordflow">if</span>(!checkValid()){
00564     cout&lt;&lt;<span class="stringliteral">"Error in use of ModelBasedScatterCorrection"</span>
00565         &lt;&lt;<span class="stringliteral">"Programmer make sure call the getInstance"</span>
00566         &lt;&lt;<span class="stringliteral">"Program aborted"</span>&lt;&lt;endl;
00567     cout.flush();
00568     <a class="code" href="classUtilities.html#e8">Utilities::cleanUp</a>(Constant::POINTERERROR);
00569   }
00570         Status *status = Status::getStatus();
00571     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
00572           status-&gt;printMemInfo();
00573     }
00574 
00575   <span class="comment">//Outputing the eventStats to check if randomsScatterPrep went through fine</span>
00576 <span class="keywordflow">if</span>((params-&gt;randoms.verbosity &gt;= 2 || params-&gt;modelBasedScatter.verbosity &gt;= 2) &amp;&amp; status-&gt;proc == 0) {
00577   cout &lt;&lt; <span class="stringliteral">"Event Statistics collected by ModelBasedScatterCorrection::randomsScatterPrep\n"</span>;
00578   cout &lt;&lt; <span class="stringliteral">"No. of TimeTags:"</span>&lt;&lt;eventStats.nTimeTags&lt;&lt;<span class="stringliteral">"\n"</span>;
00579   cout &lt;&lt; <span class="stringliteral">"No. of SinglesTags:"</span>&lt;&lt;eventStats.nSingleTags&lt;&lt;<span class="stringliteral">"\n"</span>;
00580   cout &lt;&lt; <span class="stringliteral">"No. of Events:"</span>&lt;&lt;eventStats.nEvents&lt;&lt;<span class="stringliteral">"\n"</span>;
00581   cout &lt;&lt; <span class="stringliteral">"No. of NonEvents:"</span>&lt;&lt;eventStats.nNonEvents&lt;&lt;<span class="stringliteral">"\n"</span>;
00582   cout &lt;&lt; <span class="stringliteral">"No. of Prompts Binned:"</span>&lt;&lt;eventStats.binnedPrompts&lt;&lt;<span class="stringliteral">"\n"</span>;
00583   cout &lt;&lt; <span class="stringliteral">"No. of Delays Binned:"</span>&lt;&lt;eventStats.binnedDelays&lt;&lt;<span class="stringliteral">"\n"</span>;
00584   cout.flush();
00585 }
00586 <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.enable) {
00587    <span class="keywordtype">float</span> sumBinRandomized1 = 0.0,sumBinRandomized2 = 0.0;
00588    <span class="comment">//To account for the undersampling scale it up </span>
00589    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i4=0 ; i4&lt; endPointList.nSlices ; i4++) {
00590      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i3=0 ; i3 &lt; endPointList.nAngles ; i3++) {
00591        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i2=0; i2 &lt; endPointList.nSlices ; i2++) {
00592          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i1=0 ; i1 &lt; endPointList.nAngles ; i1++) {
00593                 sumBinRandomized1 += binRandomized(i1,i2,i3,i4);
00594                 binRandomized(i1,i2,i3,i4) *= ((<span class="keywordtype">float</span>) house-&gt;getTotalPossibleEvents() /
00595                         ((<span class="keywordtype">float</span>) house-&gt;getAcceptedEvents() + (<span class="keywordtype">float</span>) house-&gt;getRejectedEvents()));
00596                 sumBinRandomized2 += binRandomized(i1,i2,i3,i4);
00597          }
00598        }
00599      }
00600    }
00601    
00602    <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt; 2 &amp;&amp; status-&gt;proc == 0) {
00603        cout&lt;&lt;<span class="stringliteral">"Is binRandomized sum - before scaling : "</span>&lt;&lt;sumBinRandomized1&lt;&lt;<span class="stringliteral">" = house-&gt;getTotalPossibleEvents() :"</span>
00604            &lt;&lt;house-&gt;getTotalPossibleEvents()&lt;&lt;endl;
00605        cout&lt;&lt;<span class="stringliteral">"Is binRandomized sum - after scaling  : "</span>&lt;&lt;sumBinRandomized2&lt;&lt;<span class="stringliteral">" = house-&gt;getTotalPossibleEvents() :"</span>
00606            &lt;&lt;house-&gt;getTotalPossibleEvents()&lt;&lt;endl;
00607    }
00608                                    
00609 
00610   <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt; 5 &amp;&amp; status-&gt;proc == 0) {
00611 
00612      ofstream coords;
00613 
00614      coords.open(<span class="stringliteral">"Coords.raw"</span>, ios::out);
00615 
00616      coords &lt;&lt; <span class="stringliteral">"LOR-e1 LOR-e2 LORINT-e1 LORINT-e2 EP-e1 EP-e2\n"</span>;
00617 
00618      <span class="keywordflow">if</span>(!LORCoords1-&gt;isEmpty() &amp;&amp; !LORCoords2-&gt;isEmpty() &amp;&amp;
00619        !LORIntCoords1-&gt;isEmpty() &amp;&amp; !LORIntCoords2-&gt;isEmpty() &amp;&amp;
00620        !endPointCoords1-&gt;isEmpty() &amp;&amp; !endPointCoords2-&gt;isEmpty()) {
00621          coordIndex tmp;
00622          LORCoords1-&gt;getFirst(tmp);
00623          coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">" "</span>;
00624          LORCoords2-&gt;getFirst(tmp);
00625          coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">" "</span>;
00626          LORIntCoords1-&gt;getFirst(tmp);
00627          coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">" "</span>;
00628          LORIntCoords2-&gt;getFirst(tmp);
00629          coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">" "</span>;
00630          endPointCoords1-&gt;getFirst(tmp);
00631          coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">" "</span>;
00632          endPointCoords2-&gt;getFirst(tmp);
00633          coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">"\n"</span>;
00634          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i &lt; endPointCoords1-&gt;count ; i++) {
00635             LORCoords1-&gt;getNext(tmp);
00636             coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">" "</span>;
00637             LORCoords2-&gt;getNext(tmp);
00638             coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">" "</span>;
00639             LORIntCoords1-&gt;getNext(tmp);
00640             coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">" "</span>;
00641             LORIntCoords2-&gt;getNext(tmp);
00642             coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">" "</span>;
00643             endPointCoords1-&gt;getNext(tmp);
00644             coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">" "</span>;
00645             endPointCoords2-&gt;getNext(tmp);
00646             coords &lt;&lt;tmp.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;tmp.z&lt;&lt;<span class="stringliteral">"\n"</span>;
00647          }
00648      }
00649      coords.close();
00650   } <span class="comment">// DEBUG &gt; 5</span>
00651   <span class="comment">//Output the binDelays and binPrompts</span>
00652   <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt;= 3 &amp;&amp; status-&gt;proc == 0) {
00653 
00654    <span class="keywordtype">int</span> arrSize =  POW2(endPointList.nSlices)*POW2(endPointList.nAngles)*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>);
00655   <span class="keywordtype">int</span> n=0;
00656   <span class="keywordtype">char</span> tmpbin[2];
00657    ofstream bd;
00658    bd.open(<span class="stringliteral">"BinDelays.raw"</span>, ios::out | ios::binary);
00659    <span class="keywordtype">int</span> m=0;
00660    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i4=0 ; i4&lt; endPointList.nSlices ; i4++) {
00661      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i3=0 ; i3 &lt; endPointList.nAngles ; i3++) {
00662        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i2=0; i2 &lt; endPointList.nSlices ; i2++) {
00663          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i1=0 ; i1 &lt; endPointList.nAngles ; i1++) {
00664            <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> c = binDelays(i1,i2,i3,i4);
00665            tmpbin[m] = c;
00666            tmpbin[m+1] = c &gt;&gt; 8;
00667            bd.write(tmpbin, 2);
00668          }
00669        }
00670      }
00671    }
00672    bd.close();
00673    ofstream bp;
00674    bp.open(<span class="stringliteral">"BinPrompts.raw"</span>, ios::out | ios::binary);
00675    m=0;
00676    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i4=0 ; i4&lt; endPointList.nSlices ; i4++) {
00677      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i3=0 ; i3 &lt; endPointList.nAngles ; i3++) {
00678        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i2=0; i2 &lt; endPointList.nSlices ; i2++) {
00679          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i1=0 ; i1 &lt; endPointList.nAngles ; i1++) {
00680             <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> c = binPrompts(i1,i2,i3,i4);
00681             tmpbin[m] = c;
00682             tmpbin[m+1] = c &gt;&gt; 8;
00683             bp.write(tmpbin, 2);
00684          }
00685        }
00686      }
00687    }
00688    bp.close();
00689    ofstream bre;
00690    bre.open(<span class="stringliteral">"BinRandomizedEvents.raw"</span>, ios::out | ios::binary);
00691    m=0;
00692    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i4=0 ; i4&lt; endPointList.nSlices ; i4++) {
00693      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i3=0 ; i3 &lt; endPointList.nAngles ; i3++) {
00694        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i2=0; i2 &lt; endPointList.nSlices ; i2++) {
00695          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i1=0 ; i1 &lt; endPointList.nAngles ; i1++) {
00696             <span class="keywordtype">int</span> c = *(<span class="keywordtype">int</span> *) &amp;binRandomized(i1,i2,i3,i4);
00697             tmpbin[m] = c;
00698             tmpbin[m+1] = c &gt;&gt; 8;
00699             tmpbin[m+2] = c &gt;&gt; 16;
00700             tmpbin[m+3] = c &gt;&gt; 24;
00701             bre.write(tmpbin, 4);
00702          }
00703        }
00704      }
00705    }
00706    bre.close();
00707    ofstream bm;
00708    bm.open(<span class="stringliteral">"BinInsideMask.raw"</span>, ios::out | ios::binary);
00709    m=0;
00710    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i4=0 ; i4&lt; endPointList.nSlices ; i4++) {
00711      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i3=0 ; i3 &lt; endPointList.nAngles ; i3++) {
00712        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i2=0; i2 &lt; endPointList.nSlices ; i2++) {
00713          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i1=0 ; i1 &lt; endPointList.nAngles ; i1++) {
00714             <span class="keywordtype">char</span> c2 = binInsideMask(i1,i2,i3,i4);
00715             bm.write(&amp;c2, 1);
00716          }
00717        }
00718      }
00719    }
00720    bm.close();
00721   } <span class="comment">/* debug */</span>
00722 } <span class="comment">// if scatter.enabled </span>
00723   <span class="keywordtype">int</span> nLayer = scannerParams-&gt;nLayer;
00724   <span class="keywordtype">int</span> nPanel = scannerParams-&gt;nBank; 
00725   <span class="keywordtype">int</span> nDet   = scannerParams-&gt;nDtct;
00726   <span class="keywordtype">int</span> nRing  = scannerParams-&gt;nRing;
00727   <span class="keywordtype">int</span> nBlock = scannerParams-&gt;nBlock; 
00728   <span class="keywordtype">int</span> nDetPerBlock  = scannerParams-&gt;dtctPerBlock; 
00729   <span class="keywordtype">int</span> nXtalPerLayer = nDetPerBlock*nDetPerBlock;
00730   <span class="keywordtype">int</span> nXtalPerBlock = nDetPerBlock*nDetPerBlock*nLayer;
00731 
00733   <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> panelSingles;
00734   panelSingles.<a class="code" href="classArray1D.html#a8">init</a>(nPanel);
00735   panelSingles = 0.0;
00736     
00737   <span class="keywordtype">float</span> avgBlockSingles = 0.0;
00738   <span class="keywordtype">float</span> avgBlockSingles2 = 0.0; <span class="comment">// average block singles squared</span>
00739   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ib = 0; ib &lt;= nBlock-1; ib++) {
00740     blockSingles(ib) /= nblockSingles(ib);      <span class="comment">// average block singles over the frame</span>
00741     blockSingles2(ib) /= nblockSingles(ib);     <span class="comment">// average block singles^2 over the frame</span>
00742     panelSingles(ib/(nBlock/nPanel)) += blockSingles(ib);
00743     avgBlockSingles += blockSingles(ib)/nBlock;
00744     avgBlockSingles2 += blockSingles2(ib)/nBlock;
00745   }
00746     
00747   <span class="keywordtype">float</span> singlesSum = 0.0;
00748   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ip1 = 0; ip1 &lt;= nPanel-1; ip1++) {
00749     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ip2 = 0; ip2 &lt;= nPanel-1; ip2++) {
00750       <span class="keywordflow">if</span> ((ip1-ip2+nPanel) % nPanel != 0 &amp;&amp; (ip1-ip2+nPanel) % nPanel != 1 &amp;&amp; (ip1-ip2+nPanel) % nPanel != 7 ) {
00751         singlesSum += panelSingles(ip1)*panelSingles(ip2);
00752       }
00753     }
00754   }
00755   singlesSum /= 2.0;    <span class="comment">// each panel pair counted twice</span>
00756 
00757     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
00758           status-&gt;printMemInfo();
00759     }
00760 
00763   <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> delaysLayerSum;
00764   delaysLayerSum.<a class="code" href="classArray1D.html#a8">init</a>(nLayer);
00765   delaysLayerSum = 0.0;
00766      
00767   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;             i &lt;=   nXtalPerLayer-1; i++) delaysLayerSum(0) += xtalDelays(i);
00768   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = nXtalPerLayer; i &lt;= 2*nXtalPerLayer-1; i++) delaysLayerSum(1) += xtalDelays(i);
00769     
00770   <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> delaysLayerEff;
00771   delaysLayerEff.<a class="code" href="classArray1D.html#a8">init</a>(nLayer);
00772   delaysLayerEff = 0.0;
00773 
00774   <span class="keywordtype">float</span> totalBlockDelays  = (delaysLayerSum(0)+delaysLayerSum(1))/2.0;  <span class="comment">// each delay was counted twice</span>
00775   delaysLayerEff(0) = delaysLayerSum(0)/totalBlockDelays;  <span class="comment">// relative efficiency</span>
00776   delaysLayerEff(1) = delaysLayerSum(1)/totalBlockDelays;
00777 
00778 
00781   <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> normLayerSum;
00782   normLayerSum.<a class="code" href="classArray1D.html#a8">init</a>(nLayer);
00783   normLayerSum = 0.0;
00784   <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> offsetNormLayerSum;
00785   offsetNormLayerSum.<a class="code" href="classArray1D.html#a8">init</a>(nLayer);
00786   offsetNormLayerSum = 0.0;
00787      
00788   <span class="keywordtype">float</span> normSingles = params-&gt;normalization.normSinglesRate;
00789   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ring = 0;ring &lt;= nRing-1;ring += nDetPerBlock) {
00790     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> panel = 0;panel &lt;= nPanel-1;panel++) {
00791       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> det = 0;det &lt;= nDet-1;det += nDetPerBlock) {
00792         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> layer = 0; layer &lt;= nLayer-1; layer++) {
00793           normLayerSum(layer) += house-&gt;getSen(det,layer,panel,ring,0); <span class="comment">//at 0 singles rate</span>
00794           offsetNormLayerSum(layer) += house-&gt;getSen(det,layer,panel,ring,avgBlockSingles);     <span class="comment">// at average singles rate</span>
00795         }
00796       }
00797     }
00798   }
00799 
00800   <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> normLayerEff;
00801   normLayerEff.<a class="code" href="classArray1D.html#a8">init</a>(nLayer);
00802   normLayerEff = 0.0;
00803   <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> offsetNormLayerEff;
00804   offsetNormLayerEff.<a class="code" href="classArray1D.html#a8">init</a>(nLayer);
00805   offsetNormLayerEff = 0.0;
00806      
00807   <span class="keywordtype">float</span> totalNorm = normLayerSum(0)+normLayerSum(1);
00808   normLayerEff(0) = 2.0*normLayerSum(0)/totalNorm;
00809   normLayerEff(1) = 2.0*normLayerSum(1)/totalNorm;
00810   <span class="keywordtype">float</span> totalOffsetNorm = offsetNormLayerSum(0)+offsetNormLayerSum(1);
00811   offsetNormLayerEff(0) = 2.0*offsetNormLayerSum(0)/totalOffsetNorm;
00812   offsetNormLayerEff(1) = 2.0*offsetNormLayerSum(1)/totalOffsetNorm;
00813 
00814   <a class="code" href="classFrameInfo.html">FrameInfo</a> *fi = FrameInfo::getInstance();
00815   <span class="keywordtype">float</span> avgTau = 0.0;
00816   <span class="keywordtype">float</span> modelTau = 0.0;
00817   <span class="keywordtype">float</span> randomsTau = 0.0;
00818 
00821   <span class="keywordflow">if</span>(params-&gt;randoms.enable) {
00822         avgTau = totalBlockDelays / (2.0*singlesSum*fi-&gt;<a class="code" href="classFrameInfo.html#o3">Duration</a>/1000.);  
00823         modelTau = (2.97046852 - 0.00000555*avgBlockSingles) * 1.0e-9;
00824         <span class="keywordflow">if</span>(params-&gt;randoms.randomsType == 0) randomsTau = params-&gt;randoms.tau;
00825         <span class="keywordflow">if</span>(params-&gt;randoms.randomsType == 1) randomsTau = avgTau;
00826         <span class="keywordflow">if</span>(params-&gt;randoms.randomsType == 2) randomsTau = modelTau;
00827   }
00828     
00829 <span class="comment">//Calculate the delays efficiencies based on layer</span>
00830 
00831   <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> delaysEff;
00832   delaysEff.<a class="code" href="classArray1D.html#a8">init</a>(nXtalPerBlock);
00833   delaysEff = 0.0;
00834 
00835   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt;= nXtalPerBlock-1; i++) delaysEff(i) = nXtalPerBlock * xtalDelays(i) / totalBlockDelays;
00836     
00837   <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt;= 3 &amp;&amp; status-&gt;proc == 0) {
00838    ofstream fDelaysEff(<span class="stringliteral">"DelaysEff.txt"</span>);
00839    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> xtal=0; xtal &lt;= nXtalPerBlock-1; xtal++) fDelaysEff&lt;&lt;delaysEff(xtal)&lt;&lt;endl;
00840   }
00841   <span class="keywordtype">float</span> totalDelays = layerDelays(0,0) +layerDelays(0,1) +layerDelays(1,0) +layerDelays(1,1);
00842   <span class="keywordflow">if</span>((params-&gt;randoms.verbosity &gt;= 3 || params-&gt;modelBasedScatter.verbosity &gt;= 3) &amp;&amp; status-&gt;proc == 0) { 
00843     cout&lt;&lt;<span class="stringliteral">"eff: delaysLayerEff(0)=     "</span>&lt;&lt;delaysLayerEff(0)&lt;&lt;    <span class="stringliteral">"     delaysLayerEff(1)=     "</span>&lt;&lt;delaysLayerEff(1)&lt;&lt;endl; 
00844     cout&lt;&lt;<span class="stringliteral">"eff: offsetNormLayerEff(0)= "</span>&lt;&lt;offsetNormLayerEff(0)&lt;&lt;<span class="stringliteral">"     offsetNormLayerEff(1)= "</span>&lt;&lt;offsetNormLayerEff(1)&lt;&lt;endl; 
00845     cout&lt;&lt;<span class="stringliteral">"eff: norm0LayerEff(0)=      "</span>&lt;&lt;normLayerEff(0)&lt;&lt;      <span class="stringliteral">"     norm0LayerEff(1)=      "</span>&lt;&lt;normLayerEff(1)&lt;&lt;endl; 
00846     cout&lt;&lt;<span class="stringliteral">"eff: measuredEffOffset (from 0-rate)=    "</span>&lt;&lt;delaysLayerEff(1)-normLayerEff(1)&lt;&lt;endl; 
00847     cout&lt;&lt;<span class="stringliteral">"eff: computedEffOffset=    "</span>&lt;&lt;params-&gt;normalization.effOffset*avgBlockSingles&lt;&lt;endl; 
00848     cout&lt;&lt;<span class="stringliteral">"eff:         using avgBlockSingles = "</span>&lt;&lt;params-&gt;normalization.effOffset*avgBlockSingles&lt;&lt;endl; 
00849     cout&lt;&lt;<span class="stringliteral">"eff:         using normSingles =     "</span>&lt;&lt;params-&gt;normalization.effOffset*normSingles&lt;&lt;endl; 
00850     cout&lt;&lt;<span class="stringliteral">"eff:         using block-norm =      "</span>&lt;&lt;params-&gt;normalization.effOffset*(avgBlockSingles-normSingles)&lt;&lt;endl; 
00851     cout&lt;&lt;<span class="stringliteral">"eff: avgBlockSingles:   "</span>&lt;&lt;avgBlockSingles&lt;&lt;endl;
00852     cout&lt;&lt;<span class="stringliteral">"tau: type               "</span>&lt;&lt;params-&gt;randoms.randomsType&lt;&lt;<span class="stringliteral">"  (0=fixed, 1=computed, 2=modeled) "</span>&lt;&lt;endl; 
00853     cout&lt;&lt;<span class="stringliteral">"tau: tau actually used  "</span>&lt;&lt;randomsTau&lt;&lt;endl; 
00854     cout&lt;&lt;<span class="stringliteral">"tau: fixed tau (param)  "</span>&lt;&lt;params-&gt;randoms.tau&lt;&lt;endl; 
00855     cout&lt;&lt;<span class="stringliteral">"tau: computed tau       "</span>&lt;&lt;avgTau&lt;&lt;endl; 
00856     cout&lt;&lt;<span class="stringliteral">"tau: modeled tau        "</span>&lt;&lt;modelTau&lt;&lt;endl; 
00857     cout&lt;&lt;<span class="stringliteral">"tau: avgBlockSingles:   "</span>&lt;&lt;avgBlockSingles&lt;&lt;endl;
00858     cout&lt;&lt;<span class="stringliteral">"tau: avgBlockSingles2 (not used yet):   "</span>&lt;&lt;avgBlockSingles2&lt;&lt;endl;
00859     cout&lt;&lt;<span class="stringliteral">"tau: discrepancy(avgBlockSingle2 / (averageBlockSingle^2):   "</span>&lt;&lt;
00860                 avgBlockSingles2/POW2(avgBlockSingles)&lt;&lt;endl;
00861     cout&lt;&lt;<span class="stringliteral">"tau: totalBlockDelays:  "</span>&lt;&lt;totalBlockDelays&lt;&lt;endl;
00862     cout&lt;&lt;<span class="stringliteral">"tau: layerDelays:       Total="</span>&lt;&lt;totalDelays&lt;&lt;
00863                              <span class="stringliteral">"       (0,0)="</span>&lt;&lt;layerDelays(0,0)&lt;&lt; 
00864                              <span class="stringliteral">"       (0,1)="</span>&lt;&lt;layerDelays(0,1)&lt;&lt; 
00865                              <span class="stringliteral">"       (1,0)="</span>&lt;&lt;layerDelays(1,0)&lt;&lt;
00866                              <span class="stringliteral">"       (1,1)="</span>&lt;&lt;layerDelays(1,1)&lt;&lt;endl;
00867     cout&lt;&lt;<span class="stringliteral">"tau: duration:          "</span>&lt;&lt;fi-&gt;<a class="code" href="classFrameInfo.html#o3">Duration</a>/1000.&lt;&lt;endl;
00868   }
00869 
00870   <span class="comment">//Calculating the Randoms Fraction from delays</span>
00871 
00872   <span class="keywordtype">double</span> promptsSum=0., delaysSum=0.;
00873   <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.enable) {
00874           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i4=0 ; i4&lt; endPointList.nSlices ; i4++) {
00875             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i3=0 ; i3 &lt; endPointList.nAngles ; i3++) {
00876               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i2=0; i2 &lt; endPointList.nSlices ; i2++) {
00877                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i1=0 ; i1 &lt; endPointList.nAngles ; i1++) {
00878                    <span class="keywordflow">if</span>(binInsideMask(i1,i2,i3,i4)) {
00879                        promptsSum += binPrompts(i1,i2,i3,i4);
00880                        delaysSum += binDelays(i1,i2,i3,i4);
00881                    } 
00882                 }
00883              }
00884            }
00885          }
00886   }
00887   <span class="keywordflow">if</span>(status-&gt;proc == 0) {
00888 
00889     fi-&gt;<a class="code" href="classFrameInfo.html#o31">measuredEffOffset</a>  = delaysLayerEff(1)-normLayerEff(1);
00890     <span class="comment">//fi-&gt;computedEffOffset  = params-&gt;normalization.effOffset*(avgBlockSingles-normSingles);</span>
00891     fi-&gt;<a class="code" href="classFrameInfo.html#o32">computedEffOffset</a>  = params-&gt;normalization.effOffset*avgBlockSingles;
00892     fi-&gt;<a class="code" href="classFrameInfo.html#o25">randomsType</a>        = params-&gt;randoms.randomsType;
00893     fi-&gt;<a class="code" href="classFrameInfo.html#o26">randomsTau</a>         = randomsTau;
00894     fi-&gt;<a class="code" href="classFrameInfo.html#o27">randomsTauFixed</a>    = params-&gt;randoms.tau;
00895     fi-&gt;<a class="code" href="classFrameInfo.html#o28">randomsTauComputed</a> = avgTau;
00896     fi-&gt;<a class="code" href="classFrameInfo.html#o29">randomsTauModel</a>    = modelTau;
00897     fi-&gt;<a class="code" href="classFrameInfo.html#o30">avgBlockSingles</a>    = avgBlockSingles;
00898         
00899         <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.enable) {
00900             fi-&gt;<a class="code" href="classFrameInfo.html#o18">randomsFractionDelays</a> = static_cast&lt;float&gt;(delaysSum / promptsSum);
00901         } <span class="keywordflow">else</span> {
00902             fi-&gt;<a class="code" href="classFrameInfo.html#o18">randomsFractionDelays</a> = 0.0;
00903         }
00904 
00905 
00906     fi-&gt;<a class="code" href="classFrameInfo.html#a0">writeFrameInfo</a>();
00907   }
00908 
00917     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
00918           status-&gt;printMemInfo();
00919     }
00920 
00921   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00922 } 
00923 
00924 
00952 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::setupStructs() {
00953         axial.dimension = 21;   
00954         azimuthal.dimension = 21;       
00955         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00956 }
00957 
00958 <span class="comment">/*</span>
00959 <span class="comment">//===============================================================================</span>
00960 <span class="comment">//+</span>
00961 <span class="comment">//       NAME</span>
00962 <span class="comment">//               setupScanner </span>
00963 <span class="comment">//</span>
00964 <span class="comment">//       SYNOPSIS</span>
00965 <span class="comment">//               setupScanner(params, scanner)</span>
00966 <span class="comment">//</span>
00967 <span class="comment">//       INPUT</span>
00968 <span class="comment">//               params - structure containing all the various parameter values</span>
00969 <span class="comment">//</span>
00970 <span class="comment">//       OUTPUT</span>
00971 <span class="comment">//               scanner - structure describing the PET scanner hardware</span>
00972 <span class="comment">//               errMsg - informational message for error handler</span>
00973 <span class="comment">//</span>
00974 <span class="comment">//       DESCRIPTION</span>
00975 <span class="comment">//               Compute the locations and orientations of the scanner components</span>
00976 <span class="comment">//</span>
00977 <span class="comment">//       HISTORY</span>
00978 <span class="comment">//               03/02/04 - st - Porting it to C++</span>
00979 <span class="comment">//               01/01/04 - cb - original code validated</span>
00980 <span class="comment">//-</span>
00981 <span class="comment">//===============================================================================</span>
00982 <span class="comment">*/</span>
00983 
00984 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::setupScanner() {
00985 
00986         <span class="comment">/* Compute scanner locations</span>
00987 <span class="comment">        */</span>
00988         <span class="comment">//if (scanner.type.indexOf('HRRT') != string::npos) {</span>
00989         
00990                 <span class="keywordtype">float</span> sq2 = 1.0 / sqrt(2.0);
00991                 <span class="keywordtype">float</span> W = scannerParams-&gt;bankWidth; <span class="comment">//*** Extra parameter</span>
00992                 <span class="keywordtype">float</span> D = scannerParams-&gt;panelSeparation; <span class="comment">// **** Difference between ringDiameter=469.0 and diameter=499.0 ? </span>
00993                 <span class="keywordtype">float</span> L = scannerParams-&gt;bankLength;
00994                 <span class="keywordtype">float</span> A = D * sq2; <span class="comment">//to get center coordinate for angled bank</span>
00995 
00996                 <span class="comment">// bank 0</span>
00997                 scanner.bank[0].x.init(3) ; scanner.bank[0].y.init(3) ; scanner.bank[0].z.init(3); 
00998                 scanner.bank[0].q.x =  0.0 ;  scanner.bank[0].q.y =  0.0 ;  scanner.bank[0].q.z =  1.0; <span class="comment">// axial vector</span>
00999                 scanner.bank[0].r.x = -1.0 ;  scanner.bank[0].r.y =  0.0 ;  scanner.bank[0].r.z =  0.0; <span class="comment">// azimuthal vector</span>
01000                 scanner.bank[0].s.x =  0.0 ;  scanner.bank[0].s.y = -1.0 ;  scanner.bank[0].s.z =  0.0; <span class="comment">// normal vector</span>
01001                 scanner.bank[0].x(0) =  W  ;  scanner.bank[0].y(0) =  D  ;  scanner.bank[0].z(0) =  L;
01002                 scanner.bank[0].x(1) =  W  ;  scanner.bank[0].y(1) =  D  ;  scanner.bank[0].z(1) = -L;
01003                 scanner.bank[0].x(2) = -W  ;  scanner.bank[0].y(2) =  D  ;  scanner.bank[0].z(2) = -L;
01004 
01005                 <span class="comment">// bank 1</span>
01006                 scanner.bank[1].x.init(3) ; scanner.bank[1].y.init(3) ; scanner.bank[1].z.init(3); 
01007                 scanner.bank[1].q.x =  0.0 ;  scanner.bank[1].q.y =  0.0 ;  scanner.bank[1].q.z =  1.0; <span class="comment">// axial vector</span>
01008                 scanner.bank[1].r.x = -sq2 ;  scanner.bank[1].r.y = -sq2 ;  scanner.bank[1].r.z =  0.0; <span class="comment">// azimuthal vector</span>
01009                 scanner.bank[1].s.x =  sq2 ;  scanner.bank[1].s.y = -sq2 ;  scanner.bank[1].s.z =  0.0; <span class="comment">// normal vector</span>
01010                 scanner.bank[1].x(0) = -W  ;  scanner.bank[1].y(0) =  D  ;  scanner.bank[1].z(0) =  L;
01011                 scanner.bank[1].x(1) = -W  ;  scanner.bank[1].y(1) =  D  ;  scanner.bank[1].z(1) = -L;
01012                 scanner.bank[1].x(2) = -D  ;  scanner.bank[1].y(2) =  W  ;  scanner.bank[1].z(2) = -L;
01013 
01014                 <span class="comment">// bank 2</span>
01015                 scanner.bank[2].x.init(3) ; scanner.bank[2].y.init(3) ; scanner.bank[2].z.init(3); 
01016                 scanner.bank[2].q.x =  0.0 ;  scanner.bank[2].q.y =  0.0 ;  scanner.bank[2].q.z =  1.0; <span class="comment">// axial vector</span>
01017                 scanner.bank[2].r.x =  0.0 ;  scanner.bank[2].r.y = -1.0 ;  scanner.bank[2].r.z =  0.0; <span class="comment">// azimuthal vector</span>
01018                 scanner.bank[2].s.x =  1.0 ;  scanner.bank[2].s.y =  0.0 ;  scanner.bank[2].s.z =  0.0; <span class="comment">// normal vector</span>
01019                 scanner.bank[2].x(0) = -D  ;  scanner.bank[2].y(0) =  W  ;  scanner.bank[2].z(0) =  L;
01020                 scanner.bank[2].x(1) = -D  ;  scanner.bank[2].y(1) =  W  ;  scanner.bank[2].z(1) = -L;
01021                 scanner.bank[2].x(2) = -D  ;  scanner.bank[2].y(2) = -W  ;  scanner.bank[2].z(2) = -L;
01022 
01023                 <span class="comment">// bank 3</span>
01024                 scanner.bank[3].x.init(3) ; scanner.bank[3].y.init(3) ; scanner.bank[3].z.init(3); 
01025                 scanner.bank[3].q.x =  0.0 ;  scanner.bank[3].q.y =  0.0 ;  scanner.bank[3].q.z =  1.0; <span class="comment">// axial vector</span>
01026                 scanner.bank[3].r.x =  sq2 ;  scanner.bank[3].r.y = -sq2 ;  scanner.bank[3].r.z =  0.0; <span class="comment">// azimuthal vector</span>
01027                 scanner.bank[3].s.x =  sq2 ;  scanner.bank[3].s.y =  sq2 ;  scanner.bank[3].s.z =  0.0; <span class="comment">// normal vector</span>
01028                 scanner.bank[3].x(0) = -D  ;  scanner.bank[3].y(0) = -W  ;  scanner.bank[3].z(0) =  L;
01029                 scanner.bank[3].x(1) = -D  ;  scanner.bank[3].y(1) = -W  ;  scanner.bank[3].z(1) = -L;
01030                 scanner.bank[3].x(2) = -W  ;  scanner.bank[3].y(2) = -D  ;  scanner.bank[3].z(2) = -L;
01031 
01032                 <span class="comment">// bank 4</span>
01033                 scanner.bank[4].x.init(3) ; scanner.bank[4].y.init(3) ; scanner.bank[4].z.init(3); 
01034                 scanner.bank[4].q.x =  0.0 ;  scanner.bank[4].q.y =  0.0 ;  scanner.bank[4].q.z =  1.0; <span class="comment">// axial vector</span>
01035                 scanner.bank[4].r.x =  1.0 ;  scanner.bank[4].r.y =  0.0 ;  scanner.bank[4].r.z =  0.0; <span class="comment">// azimuthal vector</span>
01036                 scanner.bank[4].s.x =  0.0 ;  scanner.bank[4].s.y =  1.0 ;  scanner.bank[4].s.z =  0.0; <span class="comment">// normal vector</span>
01037                 scanner.bank[4].x(0) = -W  ;  scanner.bank[4].y(0) = -D  ;  scanner.bank[4].z(0) =  L;
01038                 scanner.bank[4].x(1) = -W  ;  scanner.bank[4].y(1) = -D  ;  scanner.bank[4].z(1) = -L;
01039                 scanner.bank[4].x(2) =  W  ;  scanner.bank[4].y(2) = -D  ;  scanner.bank[4].z(2) = -L;
01040 
01041                 <span class="comment">// bank 5</span>
01042                 scanner.bank[5].x.init(3) ; scanner.bank[5].y.init(3) ; scanner.bank[5].z.init(3); 
01043                 scanner.bank[5].q.x =  0.0 ;  scanner.bank[5].q.y =  0.0 ;  scanner.bank[5].q.z =  1.0; <span class="comment">// axial vector</span>
01044                 scanner.bank[5].r.x =  sq2 ;  scanner.bank[5].r.y =  sq2 ;  scanner.bank[5].r.z =  0.0; <span class="comment">// azimuthal vector</span>
01045                 scanner.bank[5].s.x = -sq2 ;  scanner.bank[5].s.y =  sq2 ;  scanner.bank[5].s.z =  0.0; <span class="comment">// normal vector</span>
01046                 scanner.bank[5].x(0) =  W  ;  scanner.bank[5].y(0) = -D  ;  scanner.bank[5].z(0) =  L;
01047                 scanner.bank[5].x(1) =  W  ;  scanner.bank[5].y(1) = -D  ;  scanner.bank[5].z(1) = -L;
01048                 scanner.bank[5].x(2) =  D  ;  scanner.bank[5].y(2) = -W  ;  scanner.bank[5].z(2) = -L;
01049 
01050                 <span class="comment">// bank 6</span>
01051                 scanner.bank[6].x.init(3) ; scanner.bank[6].y.init(3) ; scanner.bank[6].z.init(3); 
01052                 scanner.bank[6].q.x =  0.0 ;  scanner.bank[6].q.y =  0.0 ;  scanner.bank[6].q.z =  1.0; <span class="comment">// axial vector</span>
01053                 scanner.bank[6].r.x =  0.0 ;  scanner.bank[6].r.y =  1.0 ;  scanner.bank[6].r.z =  0.0; <span class="comment">// azimuthal vector</span>
01054                 scanner.bank[6].s.x = -1.0 ;  scanner.bank[6].s.y =  0.0 ;  scanner.bank[6].s.z =  0.0; <span class="comment">// normal vector</span>
01055                 scanner.bank[6].x(0) =  D  ;  scanner.bank[6].y(0) = -W  ;  scanner.bank[6].z(0) =  L;
01056                 scanner.bank[6].x(1) =  D  ;  scanner.bank[6].y(1) = -W  ;  scanner.bank[6].z(1) = -L;
01057                 scanner.bank[6].x(2) =  D  ;  scanner.bank[6].y(2) =  W  ;  scanner.bank[6].z(2) = -L;
01058 
01059                 <span class="comment">// bank 7</span>
01060                 scanner.bank[7].x.init(3) ; scanner.bank[7].y.init(3) ; scanner.bank[7].z.init(3); 
01061                 scanner.bank[7].q.x =  0.0 ;  scanner.bank[7].q.y =  0.0 ;  scanner.bank[7].q.z =  1.0; <span class="comment">// axial vector</span>
01062                 scanner.bank[7].r.x = -sq2 ;  scanner.bank[7].r.y =  sq2 ;  scanner.bank[7].r.z =  0.0; <span class="comment">// azimuthal vector</span>
01063                 scanner.bank[7].s.x = -sq2 ;  scanner.bank[7].s.y = -sq2 ;  scanner.bank[7].s.z =  0.0; <span class="comment">// normal vector</span>
01064                 scanner.bank[7].x(0) =  D  ;  scanner.bank[7].y(0) =  W  ;  scanner.bank[7].z(0) =  L;
01065                 scanner.bank[7].x(1) =  D  ;  scanner.bank[7].y(1) =  W  ;  scanner.bank[7].z(1) = -L;
01066                 scanner.bank[7].x(2) =  W  ;  scanner.bank[7].y(2) =  D  ;  scanner.bank[7].z(2) = -L;
01067 
01068                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0 ; i &lt; NBANKS; i++)
01069                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0 ; j &lt; DIMENSIONS; j++) {
01070                         scanner.bank[i].x(j) = 0.5*scanner.bank[i].x(j);  
01071                         scanner.bank[i].y(j) = 0.5*scanner.bank[i].y(j);  
01072                         scanner.bank[i].z(j) = 0.5*scanner.bank[i].z(j);
01073                 }
01074 
01075         <span class="comment">//} // End of HRRT Scanner Bank endpoint definitions</span>
01076 
01077         <span class="keywordflow">return</span> <span class="keyword">true</span>;
01078 }
01079 
01109   <span class="keywordtype">bool</span> ModelBasedScatterCorrection::getNearestEndPoints(coordIndex &amp;A, coordIndex &amp;B,
01110          neighborIndex &amp;neighborList) {
01111 
01112   coordIntersectionIndex intersection;
01113 
01114   
01115 <span class="comment">// Find intersection with scatter cylinder</span>
01116 <span class="comment">//</span>
01117   <span class="keywordflow">if</span> (!getCylinderIntersection(endPointList.radius, A, B, intersection)) { 
01118      <span class="keywordflow">return</span> <span class="keyword">false</span>;
01119   }
01120 
01121 <span class="comment">// Find neighbors for the intersections</span>
01122   <span class="keywordtype">int</span> nAngles = static_cast&lt;int&gt; (endPointList.nAngles);
01123 
01124   <span class="keywordtype">float</span> LORAzimuthalAngleA = intersection.angle[0];
01125   <span class="keywordtype">int</span> iAngleA  = round(LORAzimuthalAngleA / endPointList.angleStep);
01126   <span class="keywordtype">int</span> iAngleA1 = floor(LORAzimuthalAngleA / endPointList.angleStep);
01127   <span class="keywordtype">int</span> iAngleA2 = ceil(LORAzimuthalAngleA  / endPointList.angleStep); 
01128   iAngleA  = (iAngleA +nAngles) % nAngles;
01129   iAngleA1 = (iAngleA1+nAngles) % nAngles;
01130   iAngleA2 = (iAngleA2+nAngles) % nAngles;
01131 
01132 
01133   <span class="keywordtype">float</span> LORAzimuthalAngleB = intersection.angle[1];
01134   <span class="keywordtype">int</span> iAngleB  = round(LORAzimuthalAngleB / endPointList.angleStep);
01135   <span class="keywordtype">int</span> iAngleB1 = floor(LORAzimuthalAngleB / endPointList.angleStep);
01136   <span class="keywordtype">int</span> iAngleB2 = ceil(LORAzimuthalAngleB  / endPointList.angleStep); 
01137   iAngleB  = (iAngleB +nAngles) % nAngles;
01138   iAngleB1 = (iAngleB1+nAngles) % nAngles;
01139   iAngleB2 = (iAngleB2+nAngles) % nAngles;
01140 
01141   <span class="comment">// RC 2006-05-10 are the maxOfNums here correct - I think not.</span>
01142   <span class="keywordtype">float</span> LORZA = intersection.z[0];                                         
01143   LORZA = (LORZA-endPointList.z(0,0));
01144   <span class="keywordtype">int</span> izA  = maxOfNum(0,round(LORZA / endPointList.sliceThickness));
01145   <span class="keywordtype">int</span> izA1 = maxOfNum(0,floor(LORZA / endPointList.sliceThickness));
01146   <span class="keywordtype">int</span> izA2 = maxOfNum(0,ceil(LORZA  / endPointList.sliceThickness)); 
01147 
01148   <span class="keywordtype">float</span> LORZB = intersection.z[1];                                 
01149   LORZB = (LORZB-endPointList.z(0,0));
01150   <span class="keywordtype">int</span> izB  = maxOfNum(0,round(LORZB / endPointList.sliceThickness));
01151   <span class="keywordtype">int</span> izB1 = maxOfNum(0,floor(LORZB / endPointList.sliceThickness));
01152   <span class="keywordtype">int</span> izB2 = maxOfNum(0,ceil(LORZB  / endPointList.sliceThickness)); 
01153   
01154 <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt; 5) {
01155   <span class="keywordflow">if</span>(iAngleA &lt; endPointList.nAngles &amp;&amp; iAngleA &gt;= 0 &amp;&amp;
01156      iAngleB &lt; endPointList.nAngles &amp;&amp; iAngleB &gt;= 0 &amp;&amp; 
01157      izA &lt; endPointList.nSlices &amp;&amp; izA &gt;= 0 &amp;&amp;
01158      izB &lt; endPointList.nSlices &amp;&amp; izB &gt;= 0) {
01159     LORCoords1-&gt;add(A);
01160     LORCoords2-&gt;add(B);
01161     coordIndex tmp;
01162     tmp.x = intersection.x[0];
01163     tmp.y = intersection.y[0];
01164     tmp.z = intersection.z[0];
01165     LORIntCoords1-&gt;add(tmp);
01166     tmp.x = intersection.x[1];
01167     tmp.y = intersection.y[1];
01168     tmp.z = intersection.z[1];
01169     LORIntCoords2-&gt;add(tmp);
01170 
01171     tmp.x = endPointList.x(iAngleA,izA);
01172     tmp.y = endPointList.y(iAngleA,izA);
01173     tmp.z = endPointList.z(iAngleA,izA);
01174     endPointCoords1-&gt;add(tmp);
01175     tmp.x = endPointList.x(iAngleB,izB);
01176     tmp.y = endPointList.y(iAngleB,izB);
01177     tmp.z = endPointList.z(iAngleB,izB);
01178     endPointCoords2-&gt;add(tmp);
01179   }
01180 } <span class="comment">/* verbosity */</span>
01181 
01182  neighborList.iAngleA[0] = iAngleA1;
01183  neighborList.iAngleA[1] = iAngleA2;
01184  neighborList.iAngleA[2] = iAngleA;
01185  neighborList.izA[0] = izA1;
01186  neighborList.izA[1] = izA2;
01187  neighborList.izA[2] = izA;
01188  neighborList.iAngleB[0] = iAngleB1;
01189  neighborList.iAngleB[1] = iAngleB2;
01190  neighborList.iAngleB[2] = iAngleB;
01191  neighborList.izB[0] = izB1;
01192  neighborList.izB[1] = izB2;
01193  neighborList.izB[2] = izB;
01194 
01195         
01196         <span class="keywordflow">return</span> <span class="keyword">true</span>;
01197   
01198 }
01199 
01200 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::simulate(<a class="code" href="classImage.html">Image</a> &amp;mu, <a class="code" href="classImage.html">Image</a> &amp;lambda, <a class="code" href="classEventList.html">EventList</a> &amp;eventList) {
01201         <span class="keywordflow">return</span> <span class="keyword">true</span>;
01202 }
01203   
01204 <span class="comment">/*;===============================================================================</span>
01205 <span class="comment">//+</span>
01206 <span class="comment">//       NAME</span>
01207 <span class="comment">//               update </span>
01208 <span class="comment">//</span>
01209 <span class="comment">//       SYNOPSIS</span>
01210 <span class="comment">//               update(status, muImage, currentLambda,</span>
01211 <span class="comment">//                  eventList) </span>
01212 <span class="comment">//</span>
01213 <span class="comment">//       INPUT</span>
01214 <span class="comment">//               status - structure containing recon status variables </span>
01215 <span class="comment">//               muImage - array containing the attenuation coefficient map</span>
01216 <span class="comment">//               currentLambda - array containing the current image estimate</span>
01217 <span class="comment">//               eventList - list of detection events to be processed</span>
01218 <span class="comment">//</span>
01219 <span class="comment">//       OUTPUT</span>
01220 <span class="comment">//               eventList - modified list of detection events </span>
01221 <span class="comment">//</span>
01222 <span class="comment">//       DESCRIPTION</span>
01223 <span class="comment">//               This is the master routine for the scatter correction.</span>
01224 <span class="comment">//</span>
01225 <span class="comment">//       HISTORY</span>
01226 <span class="comment">//               03/02/04 - st - Porting it to C++</span>
01227 <span class="comment">//               01/01/04 - cb - original code validated</span>
01228 <span class="comment">//-</span>
01229 <span class="comment">//===============================================================================*/</span>
01230 
01231 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::update(<a class="code" href="classImage.html">Image</a> &amp;mu, <a class="code" href="classImage.html">Image</a> &amp;lambda, <a class="code" href="classEventList.html">EventList</a> &amp;eventList) {
01232 
01233         Status *status = Status::getStatus();
01234         <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt; 2 &amp;&amp; status-&gt;proc == 0) {
01235           cout &lt;&lt; <span class="stringliteral">"Inside ModelBasedScatterCorrection::update  proc="</span>&lt;&lt;status-&gt;proc&lt;&lt;
01236                 <span class="stringliteral">" iter="</span>&lt;&lt;status-&gt;iter&lt;&lt;<span class="stringliteral">":"</span>&lt;&lt;status-&gt;subset&lt;&lt;endl;
01237         }
01238 <span class="preprocessor">#ifdef SCATTER_DEBUG</span>
01239 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(status-&gt;proc == 0) {
01240                 stringstream muFile;
01241                 muFile&lt;&lt;<span class="stringliteral">"Mu_Map-iter-"</span>&lt;&lt;status-&gt;iter&lt;&lt;<span class="stringliteral">".hdr"</span>;
01242                 mu.<a class="code" href="classImage.html#a8">write</a>(muFile.str(), params-&gt;extensions);
01243 
01244                 stringstream lamdaFile;
01245                 lamdaFile&lt;&lt;<span class="stringliteral">"lambda-iter-"</span>&lt;&lt;status-&gt;iter&lt;&lt;<span class="stringliteral">".hdr"</span>;
01246                 lambda.<a class="code" href="classImage.html#a8">write</a>(lamdaFile.str(), params-&gt;extensions);
01247         }
01248 <span class="preprocessor">#endif //SCATTER_DEBUG</span>
01249 <span class="preprocessor"></span>        <span class="comment">// Decide if an update is necessary. If it is, then set samplingFactor </span>
01250         <span class="keywordtype">float</span> samplingFactor  = -1.0;
01251         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0 ; i &lt; SCATTER_UPDATE_ARR_LEN ; i++) {
01252                 stringstream updateIter;
01253                 updateIter&lt;&lt;status-&gt;iter&lt;&lt;<span class="stringliteral">":"</span>&lt;&lt;status-&gt;subset;
01254                 <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.updateIteration[i].compare(updateIter.str()) == 0) {
01255                         samplingFactor  = params-&gt;modelBasedScatter.updateSamplingFactor[i];
01256                         <span class="keywordflow">break</span>;
01257                 }
01258         } 
01259         <span class="comment">// Update not required</span>
01260         <span class="keywordflow">if</span>(samplingFactor &lt;= 0) { <span class="comment">//Can samplingfactor be 0</span>
01261                 <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt; 2 &amp;&amp; status-&gt;proc == 0) {
01262                         cout &lt;&lt; <span class="stringliteral">"No scatter update required for iteration "</span>&lt;&lt;status-&gt;iter&lt;&lt;<span class="stringliteral">":"</span>&lt;&lt;status-&gt;subset&lt;&lt;endl;
01263                 }
01264                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
01265         }       
01266         <span class="keywordflow">if</span>(status-&gt;proc == 0) cout &lt;&lt; <span class="stringliteral">"Scatter update at iteration #: "</span>&lt;&lt;status-&gt;iter&lt;&lt;<span class="stringliteral">":"</span>&lt;&lt;status-&gt;subset&lt;&lt;<span class="stringliteral">" sampling factor being :"</span>&lt;&lt;samplingFactor&lt;&lt;<span class="stringliteral">"\n"</span>;
01267         
01268         <span class="comment">// Perform Update</span>
01269         <span class="keywordflow">if</span>(!updateScatter(samplingFactor,mu,lambda,eventList)) {
01270                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
01271         }
01272         <span class="keywordflow">return</span> <span class="keyword">true</span>;
01273         
01274 }
01275 
01276 <span class="comment">/*;===============================================================================</span>
01277 <span class="comment">//+</span>
01278 <span class="comment">//       NAME</span>
01279 <span class="comment">//               updateScatter </span>
01280 <span class="comment">//</span>
01281 <span class="comment">//       SYNOPSIS</span>
01282 <span class="comment">//               updateScatter(frameInfo, house, params, scanner, status,</span>
01283 <span class="comment">//                  samplingFactor, muImage, emissionImage, eventList)</span>
01284 <span class="comment">//</span>
01285 <span class="comment">//       INPUT</span>
01286 <span class="comment">//               frameInfo - structure containing frame-specific info</span>
01287 <span class="comment">//               house - structure containing "house" data</span>
01288 <span class="comment">//               params - structure containing all the various parameter values</span>
01289 <span class="comment">//               scanner - structure describing the PET scanner hardware</span>
01290 <span class="comment">//               status - structure containing recon status variables </span>
01291 <span class="comment">//               samplingFactor - a multiplicative factor that allows for more</span>
01292 <span class="comment">//                  coarse spatial sampling without changing the ultimate desired</span>
01293 <span class="comment">//                  sampling (params-&gt;modelBasedScatter.endPointAxialStep, </span>
01294 <span class="comment">//                  params-&gt;modelBasedScatter.endPointAzimuthalStep, </span>
01295 <span class="comment">//                  params-&gt;modelBasedScatter.scatterPointAxialStep and</span>
01296 <span class="comment">//                  params-&gt;modelBasedScatter.scatterPointAzimuthalStep)</span>
01297 <span class="comment">//               muImage - array containing the attenuation coefficient map</span>
01298 <span class="comment">//               emissionImage - array containing the current image estimate</span>
01299 <span class="comment">//               eventList - list of detection events to be processed</span>
01300 <span class="comment">//</span>
01301 <span class="comment">//       OUTPUT</span>
01302 <span class="comment">//               eventList - modified list of detection events </span>
01303 <span class="comment">//               errMsg - informational message for error handler</span>
01304 <span class="comment">//</span>
01305 <span class="comment">//       DESCRIPTION</span>
01306 <span class="comment">//               Compute a new scatter estimate for each event in the event list</span>
01307 <span class="comment">//</span>
01308 <span class="comment">//       HISTORY</span>
01309 <span class="comment">//               03/02/04 - st - Porting it to C++</span>
01310 <span class="comment">//               01/01/04 - cb - original code validated</span>
01311 <span class="comment">//-</span>
01312 <span class="comment">//===============================================================================*/</span>
01313 
01314 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::updateScatter(<span class="keywordtype">float</span> samplingFactor,<a class="code" href="classImage.html">Image</a> &amp;muImage,<a class="code" href="classImage.html">Image</a> &amp;lambdaImage,<a class="code" href="classEventList.html">EventList</a> &amp;eventList) {
01315                 
01316         Status *status = Status::getStatus();
01317         <a class="code" href="classFrameInfo.html">FrameInfo</a> *fi = FrameInfo::getInstance();
01318         <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
01319             status-&gt;printMemInfo();
01320         }
01321 
01322         <span class="comment">//compute scatter point locations - a structure of (x,y,z) coordinates</span>
01323 
01324         clock_t time0 = clock();
01325 
01326         <span class="keywordflow">if</span>(status-&gt;proc == 0) {
01327                 scatterPointList = <span class="keyword">new</span> DList&lt;coordIndex&gt;;
01328                 <span class="keywordflow">if</span> (!defineScatterPoints(samplingFactor)) {
01329                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01330                 }
01331                 <span class="keywordtype">int</span> nScatterPoints = scatterPointList-&gt;count;
01332                 cout &lt;&lt; <span class="stringliteral">"Scatter Points count:"</span>&lt;&lt;nScatterPoints&lt;&lt;<span class="stringliteral">"\n"</span>;
01333 <span class="preprocessor">#ifdef SCATTER_DEBUG</span>
01334 <span class="preprocessor"></span>                validateEndPoints();
01335                 validateScatterPoints();
01336 <span class="preprocessor">#endif </span><span class="comment">/* SCATTER_DEBUG */</span>
01337  
01338         }
01339         <span class="keywordtype">int</span> nEndPoints = endPointList.nAngles*endPointList.nSlices;
01340 
01341     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
01342           status-&gt;printMemInfo();
01343     }
01344 
01345         DList&lt;coordIndex&gt; *scatterPointSubList = <span class="keyword">new</span> DList&lt;coordIndex&gt;;
01346         <span class="comment">// Compute scatter contribution from a subset of scatter points such that </span>
01347         <span class="comment">//   the cluster covers all of them</span>
01348         <span class="comment">// Same code would run on all processors; each processor would process a sublist </span>
01349         <span class="comment">//   of the scatter points as determined by status.proc and status.numProcs.</span>
01350         <span class="comment">//</span>
01351         
01352         <span class="keywordflow">if</span>(status-&gt;proc == 0) {
01353                 scatterDealerPlayer(scatterPointSubList);
01354         } <span class="keywordflow">else</span> {
01355                 scatterPlayer(scatterPointSubList);
01356         }
01357         
01358         <a class="code" href="classArray4D.html">Array4D&lt;float&gt;</a> scatterPartial;
01359         <span class="keywordflow">if</span> (!computeScatter(samplingFactor, muImage, lambdaImage, scatterPointSubList, scatterPartial) ) {
01360                 cerr &lt;&lt; <span class="stringliteral">"ComputeScatter failed...\n"</span>;
01361         }
01362     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
01363           status-&gt;printMemInfo();
01364     }
01365 
01378 <span class="comment">//        cout&lt;&lt;"After compute scatter-1"&lt;&lt;endl;cout.flush();</span>
01379         
01380         <span class="keywordtype">int</span> size = endPointList.nAngles*endPointList.nSlices;
01381 
01382         <a class="code" href="classArray4D.html">Array4D&lt;float&gt;</a> scatterSum(endPointList.nAngles,endPointList.nSlices,
01383                         endPointList.nAngles,endPointList.nSlices);
01384 
01385         <span class="keywordtype">float</span> sendBuf[size], recvBuf[size];
01386 
01387         scatterSum = scatterPartial;
01388 
01389         <span class="keywordtype">float</span> totalScatterPartial = 0;
01390 
01391 <span class="comment">//        cout&lt;&lt;"Before global sum-1"&lt;&lt;endl;cout.flush();</span>
01392         MPI::COMM_WORLD.Barrier();
01393         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleA = 0; iAngleA &lt;= endPointList.nAngles-1; iAngleA++) {
01394            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceA = 0; iSliceA &lt;= endPointList.nSlices-1; iSliceA++) {
01395              MPI::COMM_WORLD.Allreduce(scatterPartial.getSpecialBlock(iAngleA,iSliceA), &amp;recvBuf,size,MPI::FLOAT,MPI::SUM);
01396              scatterSum.<a class="code" href="classArray4D.html#a13">putSpecialBlock</a>(iAngleA,iSliceA, recvBuf);
01397 <span class="comment">//             cout&lt;&lt;"After global sum-1"&lt;&lt;endl;cout.flush();</span>
01398           }
01399         }                               
01400 
01401         <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
01402           status-&gt;printMemInfo();
01403         }
01404 
01405         <span class="keywordtype">float</span> scatterScaleFactor = 0.0; 
01406         <span class="keywordflow">if</span> (status-&gt;proc == 0) {
01407 <span class="comment">//==================================================</span>
01408 <span class="comment">//compute scatter scale factor from scatter tails</span>
01409 <span class="comment">//NEED TO ADD: OUTPUT INDICES FOR EDGES</span>
01410             <span class="keywordtype">float</span> alphaNumerator = 0.0;
01411             <span class="keywordtype">float</span> alphaDenominator = 0.0;
01412             <span class="keywordtype">float</span> duration = fi-&gt;<a class="code" href="classFrameInfo.html#o3">Duration</a>/1000.0;
01413             <span class="keywordtype">float</span> alphaPrompts;
01414             <span class="keywordtype">float</span> alphaDelays;
01415             <span class="keywordtype">float</span> alphaScatter;
01416             <span class="keywordtype">float</span> alphaNQEvents;
01417             <span class="keywordtype">float</span> localAlpha;
01418             ofstream fEdgeList;
01419             <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt;= 3) fEdgeList.open(<span class="stringliteral">"edgeList.txt"</span>);
01420     
01421 <span class="comment">//find edges and get neighboring elements</span>
01422 <span class="comment">// RC 2005-11-01 - modified so edgeList has correct values</span>
01423 <span class="comment">// RC 2005-11-02 - modified so (I think) the search starts correctly</span>
01424             <span class="keywordtype">int</span> nAngles = endPointList.nAngles; 
01425             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceB = 0; iSliceB &lt;= endPointList.nSlices-1; iSliceB++) {
01426                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleB = 0; iAngleB &lt;= endPointList.nAngles-1; iAngleB++) {
01427                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceA = 0; iSliceA &lt;= endPointList.nSlices-1; iSliceA++) {
01428                     <span class="keywordtype">int</span> flag = 0;
01429                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleA = 0; iAngleA &lt;= endPointList.nAngles-1; iAngleA++) {
01430                             <span class="comment">// want to start outside the object - that would be at iAngleB</span>
01431                             <span class="comment">// change -iAnglesB to +iAnglesB</span>
01432                             <span class="keywordflow">if</span> (    binInsideMask((iAngleA+iAngleB+nAngles)   % nAngles,iSliceA,iAngleB,iSliceB) != flag and flag == 0 ) {
01433                                 <span class="keywordflow">if</span> (binInsideMask((iAngleA+iAngleB+nAngles-3) % nAngles,iSliceA,iAngleB,iSliceB) == 0) {
01434 <span class="comment">//                                  edge((iAngleA-iAngleB+nAngles-3) % nAngles,iSliceA,iAngleB,iSliceB) = 1;</span>
01435                                     alphaPrompts  =    binPrompts((iAngleA+iAngleB+nAngles-3) % nAngles,iSliceA,iAngleB,iSliceB);
01436                                     alphaDelays   =     binDelays((iAngleA+iAngleB+nAngles-3) % nAngles,iSliceA,iAngleB,iSliceB);
01437                                     alphaScatter  =    scatterSum((iAngleA+iAngleB+nAngles-3) % nAngles,iSliceA,iAngleB,iSliceB);
01438                                     alphaNQEvents = binRandomized((iAngleA+iAngleB+nAngles-3) % nAngles,iSliceA,iAngleB,iSliceB);
01439                                     <span class="keywordflow">if</span> (alphaScatter != 0.0 &amp;&amp; alphaNQEvents != 0.0) {
01440                                         <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt;= 3) fEdgeList&lt;&lt;iSliceA&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;(iAngleA+iAngleB+nAngles-3) % nAngles&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iSliceB&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iAngleB&lt;&lt;endl;
01441                                         alphaNumerator   += alphaPrompts-alphaDelays;
01442                                         alphaDenominator += alphaScatter*alphaNQEvents;
01443                                         localAlpha = params-&gt;modelBasedScatter.globalScaleFactor * ((alphaPrompts-alphaDelays) / (alphaScatter*alphaNQEvents)) / duration;   
01444                                     }
01445                                 }
01446                                 <span class="keywordflow">if</span> (binInsideMask((iAngleA+iAngleB+nAngles-2) % nAngles,iSliceA,iAngleB,iSliceB) == 0) {
01447 <span class="comment">//                                  edge((iAngleA+iAngleB+nAngles-2) % nAngles,iSliceA,iAngleB,iSliceB) = 1;</span>
01448                                     alphaPrompts  =    binPrompts((iAngleA+iAngleB+nAngles-2) % nAngles,iSliceA,iAngleB,iSliceB);
01449                                     alphaDelays   =     binDelays((iAngleA+iAngleB+nAngles-2) % nAngles,iSliceA,iAngleB,iSliceB);
01450                                     alphaScatter  =    scatterSum((iAngleA+iAngleB+nAngles-2) % nAngles,iSliceA,iAngleB,iSliceB);
01451                                     alphaNQEvents = binRandomized((iAngleA+iAngleB+nAngles-2) % nAngles,iSliceA,iAngleB,iSliceB);
01452                                     <span class="keywordflow">if</span> (alphaScatter != 0.0 &amp;&amp; alphaNQEvents != 0.0) {
01453                                         <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt;= 3) fEdgeList&lt;&lt;iSliceA&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;(iAngleA+iAngleB+nAngles-2) % nAngles&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iSliceB&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iAngleB&lt;&lt;endl;
01454                                         alphaNumerator   += alphaPrompts-alphaDelays;
01455                                         alphaDenominator += alphaScatter*alphaNQEvents;
01456                                         localAlpha = params-&gt;modelBasedScatter.globalScaleFactor * ((alphaPrompts-alphaDelays) / (alphaScatter*alphaNQEvents)) / duration;   
01457                                     }
01458                                 }
01459                                 flag = 1;       <span class="comment">// now inside</span>
01460                             }
01461                             <span class="keywordflow">if</span> (    binInsideMask((iAngleA+iAngleB+nAngles)   % nAngles,iSliceA,iAngleB,iSliceB) != flag and flag == 1 ) {
01462                                 <span class="keywordflow">if</span> (binInsideMask((iAngleA+iAngleB+nAngles+1) % nAngles,iSliceA,iAngleB,iSliceB) == 0) {
01463 <span class="comment">//                                  edge((iAngleA+iAngleB+nAngles+1) % nAngles,iSliceA,iAngleB,iSliceB) = 1;</span>
01464                                     alphaPrompts  =    binPrompts((iAngleA+iAngleB+nAngles+1) % nAngles,iSliceA,iAngleB,iSliceB);
01465                                     alphaDelays   =     binDelays((iAngleA+iAngleB+nAngles+1) % nAngles,iSliceA,iAngleB,iSliceB);
01466                                     alphaScatter  =    scatterSum((iAngleA+iAngleB+nAngles+1) % nAngles,iSliceA,iAngleB,iSliceB);
01467                                     alphaNQEvents = binRandomized((iAngleA+iAngleB+nAngles+1) % nAngles,iSliceA,iAngleB,iSliceB);
01468                                     <span class="keywordflow">if</span> (alphaScatter != 0.0 &amp;&amp; alphaNQEvents != 0.0) {
01469                                         <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt;= 3) fEdgeList&lt;&lt;iSliceA&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;(iAngleA+iAngleB+nAngles+1) % nAngles&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iSliceB&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iAngleB&lt;&lt;endl;
01470                                         alphaNumerator   += alphaPrompts-alphaDelays;
01471                                         alphaDenominator += alphaScatter*alphaNQEvents;
01472                                         localAlpha = params-&gt;modelBasedScatter.globalScaleFactor * ((alphaPrompts-alphaDelays) / (alphaScatter*alphaNQEvents)) / duration;   
01473                                     }
01474                                 }
01475                                 <span class="keywordflow">if</span> (binInsideMask((iAngleA+iAngleB+nAngles+2) % nAngles,iSliceA,iAngleB,iSliceB) == 0) {
01476 <span class="comment">//                                  edge((iAngleA+iAngleB+nAngles+2) % nAngles,iSliceA,iAngleB,iSliceB) = 1;</span>
01477                                     alphaPrompts  =    binPrompts((iAngleA+iAngleB+nAngles+2) % nAngles,iSliceA,iAngleB,iSliceB);
01478                                     alphaDelays   =     binDelays((iAngleA+iAngleB+nAngles+2) % nAngles,iSliceA,iAngleB,iSliceB);
01479                                     alphaScatter  =    scatterSum((iAngleA+iAngleB+nAngles+2) % nAngles,iSliceA,iAngleB,iSliceB);
01480                                     alphaNQEvents = binRandomized((iAngleA+iAngleB+nAngles+2) % nAngles,iSliceA,iAngleB,iSliceB);
01481                                     <span class="keywordflow">if</span> (alphaScatter != 0.0 &amp;&amp; alphaNQEvents != 0.0) {
01482                                         <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt;= 3) fEdgeList&lt;&lt;iSliceA&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;(iAngleA+iAngleB+nAngles+2)% nAngles&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iSliceB&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iAngleB&lt;&lt;endl;
01483                                         alphaNumerator   += alphaPrompts-alphaDelays;
01484                                         alphaDenominator += alphaScatter*alphaNQEvents;
01485                                         localAlpha = params-&gt;modelBasedScatter.globalScaleFactor * ((alphaPrompts-alphaDelays) / (alphaScatter*alphaNQEvents)) / duration;   
01486                                     }
01487                                 }
01488                                 flag = 0; <span class="comment">//now outside</span>
01489                             }
01490                         }
01491                     }
01492                 }
01493             }
01494             <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.autoScaling) {
01495                 scatterScaleFactor = params-&gt;modelBasedScatter.globalScaleFactor * (alphaNumerator / alphaDenominator) / duration;   
01496             } <span class="keywordflow">else</span> {
01497                 scatterScaleFactor = params-&gt;modelBasedScatter.globalScaleFactor / duration;
01498             }
01499             cout&lt;&lt;<span class="stringliteral">"alpha: globalFactor =       "</span>&lt;&lt;params-&gt;modelBasedScatter.globalScaleFactor&lt;&lt;endl;
01500             cout&lt;&lt;<span class="stringliteral">"alpha: alphaNumerator =     "</span>&lt;&lt;alphaNumerator&lt;&lt;endl;
01501             cout&lt;&lt;<span class="stringliteral">"alpha: alphaDenominator =   "</span>&lt;&lt;alphaDenominator&lt;&lt;endl;
01502             cout&lt;&lt;<span class="stringliteral">"alpha: duration =           "</span>&lt;&lt;duration&lt;&lt;endl;
01503             cout&lt;&lt;<span class="stringliteral">"alpha: ScatterScaleFactor = "</span>&lt;&lt;scatterScaleFactor&lt;&lt;endl;
01504             <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt;= 3) fEdgeList.close();
01505         }
01506 <span class="comment">//      broadcast scatterScaleFactor</span>
01507         MPI::COMM_WORLD.Bcast(&amp;scatterScaleFactor, 1, MPI::FLOAT, 0);
01508 
01509 
01510 <span class="comment">//==================================================</span>
01511         
01512         <span class="keywordtype">float</span> totalScatterSum = 0;
01513         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceA = 0; iSliceA &lt;= endPointList.nSlices-1; iSliceA++) {
01514            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleA = 0; iAngleA &lt;= endPointList.nAngles-1; iAngleA++) {
01515               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceB = 0; iSliceB &lt;= endPointList.nSlices-1; iSliceB++) {
01516                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleB = 0; iAngleB &lt;= endPointList.nAngles-1; iAngleB++) {
01517                    scatterPartial(iAngleA,iSliceA,iAngleB, iSliceB) *= scatterScaleFactor;
01518                    scatterSum(iAngleA,iSliceA,iAngleB, iSliceB) *= scatterScaleFactor;
01519                    totalScatterPartial += scatterPartial(iAngleA,iSliceA,iAngleB, iSliceB);
01520                    totalScatterSum += scatterSum(iAngleA,iSliceA,iAngleB, iSliceB);
01521                 }
01522               }
01523            }
01524         }                               
01525 <span class="comment">//        cout&lt;&lt;"After total scatter sum-1"&lt;&lt;endl;cout.flush();</span>
01526         <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt; 2) {
01527            cout &lt;&lt;<span class="stringliteral">"===========================================================\n"</span>;
01528            cout &lt;&lt;<span class="stringliteral">"Global sum check at proc :"</span>&lt;&lt;status-&gt;proc&lt;&lt;<span class="stringliteral">"\n"</span>;
01529            cout &lt;&lt;<span class="stringliteral">"totalScatterPartial: "</span>&lt;&lt;totalScatterPartial&lt;&lt;<span class="stringliteral">"\n"</span>;
01530            cout &lt;&lt;<span class="stringliteral">"totalScatterSum: "</span>&lt;&lt;totalScatterSum&lt;&lt;<span class="stringliteral">"\n"</span>;
01531            cout &lt;&lt;<span class="stringliteral">"===========================================================\n"</span>;
01532            cout.flush();
01533         }
01534         
01535         <a class="code" href="classEventPacket.html">EventPacket</a> event; <span class="comment">//event extracted from the event list</span>
01536         <a class="code" href="classEventPacket.html">EventPacket</a> sentry = eventList.<a class="code" href="classEventList.html#a6">getSentry</a>(); <span class="comment">//prepare for sentry</span>
01537 
01538 
01539         <span class="keywordtype">int</span> totalEvents = 0;
01540         <span class="keywordtype">float</span> scatter = 0.0;
01541         <span class="keywordtype">float</span> rand = 0.0;
01542         <span class="keywordtype">float</span> yhat = 0.0;
01543         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> subset=0;subset&lt;params-&gt;algorithm.numSets;subset++){
01544                 <span class="keywordtype">int</span> count = 0;
01545                 event = eventList.<a class="code" href="classEventList.html#a3">getFirst</a>(subset);<span class="comment">//Get first event</span>
01546                 
01547                 <span class="keywordflow">while</span> (!(event==sentry)) {
01548                   <span class="comment">// be sure the event is still in play</span>
01549                   <span class="keywordflow">if</span> (event.<a class="code" href="classEventPacket.html#o1">jstop</a> &gt;= event.<a class="code" href="classEventPacket.html#o0">jstart</a>) {
01550                         <span class="comment">// If not scaling scatter, then apply livetime, decay and pos. frac. corrections</span>
01551                         coordIndex a,b;
01552 
01553                         a.x = event.<a class="code" href="classEventPacket.html#o12">x1</a>; a.y = event.<a class="code" href="classEventPacket.html#o13">y1</a>; a.z = event.<a class="code" href="classEventPacket.html#o14">z1</a>;
01554                         b.x = event.<a class="code" href="classEventPacket.html#o15">x2</a>; b.y = event.<a class="code" href="classEventPacket.html#o16">y2</a>; b.z = event.<a class="code" href="classEventPacket.html#o17">z2</a>;
01555 
01556                         neighborIndex neighborList;
01557 
01558                         <span class="keywordflow">if</span>(!getNearestEndPoints(a,b, neighborList)) <span class="keywordflow">continue</span>;
01559                         <span class="comment">// 2006-05-10 rc ensured that LORs are within legal scatter range</span>
01560                         neighborList.izA[2]=max(0,min(endPointList.nSlices-1,neighborList.izA[2]));
01561                         neighborList.izB[2]=max(0,min(endPointList.nSlices-1,neighborList.izB[2]));
01562                         event.<a class="code" href="classEventPacket.html#o11">scatter</a> = scatterSum(neighborList.iAngleA[2],neighborList.izA[2],
01563                                    neighborList.iAngleB[2],neighborList.izB[2]);
01564 
01565                         event.<a class="code" href="classEventPacket.html#o11">scatter</a> *= event.<a class="code" href="classEventPacket.html#o9">norm</a>;
01566                         <span class="keywordflow">if</span>(event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a> != 0) {
01567                                 event.<a class="code" href="classEventPacket.html#o11">scatter</a> *= event.<a class="code" href="classEventPacket.html#o25">livetime_decay</a>;
01568                         }
01569 
01570                         totalEvents++;
01571                         scatter += event.<a class="code" href="classEventPacket.html#o11">scatter</a>;
01572                         rand += event.<a class="code" href="classEventPacket.html#o8">rand</a>;
01573                         yhat += event.<a class="code" href="classEventPacket.html#o18">yhat</a>;
01574 
01575                         eventList.<a class="code" href="classEventList.html#a7">replace</a>(subset, event);
01576 
01577                         count++;
01578                     }
01579 
01580                     event = eventList.<a class="code" href="classEventList.html#a4">getNext</a>(subset);
01581                         
01582                 }
01583         }
01584 
01585         <span class="keywordflow">if</span>(params-&gt;modelBasedScatter.verbosity &gt; 2) {
01586                 cout &lt;&lt;<span class="stringliteral">"===========================================================\n"</span>;
01587                 cout &lt;&lt;<span class="stringliteral">"Scatter Estimate at proc: "</span>&lt;&lt;status-&gt;proc&lt;&lt;<span class="stringliteral">"\n"</span>;
01588                 cout &lt;&lt;<span class="stringliteral">"Total Events :"</span> &lt;&lt; totalEvents&lt;&lt;<span class="stringliteral">"\n"</span>;
01589                 cout &lt;&lt;<span class="stringliteral">"Total Scatter Estimate :"</span> &lt;&lt; scatter&lt;&lt;<span class="stringliteral">"\n"</span>;
01590                 cout &lt;&lt;<span class="stringliteral">"Total Randoms Estimate :"</span> &lt;&lt; rand&lt;&lt;<span class="stringliteral">"\n"</span>;
01591                 cout &lt;&lt;<span class="stringliteral">"Total Yhat Estimate (wrong on first iteration) :"</span> &lt;&lt; yhat&lt;&lt;<span class="stringliteral">"\n"</span>;
01592                 cout &lt;&lt;<span class="stringliteral">"Total Time taken for scatter calculation: "</span>&lt;&lt;clock()-time0&lt;&lt;<span class="stringliteral">" Microseconds\n"</span>;
01593                 cout &lt;&lt;<span class="stringliteral">"===========================================================\n"</span>;
01594                 cout.flush();
01595 
01596             <span class="keywordflow">if</span>(status-&gt;proc == 0) {
01597                 ofstream ss;
01598                 stringstream ssFileStream;
01599                 string ssFile;
01600                 ssFileStream&lt;&lt;<span class="stringliteral">"ScatterSum-"</span>&lt;&lt;status-&gt;iter&lt;&lt;<span class="stringliteral">"-"</span>&lt;&lt;status-&gt;subset&lt;&lt;<span class="stringliteral">".raw"</span>;
01601                 ssFile = ssFileStream.str();
01602                 ss.open(ssFile.c_str(), ios::out | ios::binary);
01603 
01604                 <span class="keywordtype">int</span> arrSize =  POW2(endPointList.nSlices)*POW2(endPointList.nAngles)*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>);
01605 
01606                 <span class="keywordtype">char</span> tmpbin[4];
01607                 <span class="keywordtype">int</span> m=0;
01608                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i4=0 ; i4&lt; endPointList.nSlices ; i4++) {
01609                   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i3=0 ; i3 &lt; endPointList.nAngles ; i3++) {
01610                     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i2=0; i2 &lt; endPointList.nSlices ; i2++) {
01611                       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i1=0 ; i1 &lt; endPointList.nAngles ; i1++) {
01612                          <span class="keywordtype">int</span> c = *(<span class="keywordtype">int</span> *) &amp;scatterSum(i1,i2,i3,i4);
01613                          tmpbin[m] = c;
01614                          tmpbin[m+1] = c &gt;&gt; 8;
01615                          tmpbin[m+2] = c &gt;&gt; 16;
01616                          tmpbin[m+3] = c &gt;&gt; 24;
01617                          ss.write(tmpbin, 4);
01618                       }
01619                     }
01620                   }
01621                 }
01622                 ss.close();
01623             }
01624         }
01625 
01626         <span class="keywordflow">return</span> <span class="keyword">true</span>;
01627 }
01628 
01629 <span class="keywordtype">void</span> ModelBasedScatterCorrection::scatterDealerPlayer(DList&lt;coordIndex&gt; *scatterPointSubList) {
01630         Status *status = Status::getStatus(); 
01631         <span class="keywordtype">int</span> numProcs = status-&gt;numProcs;
01632         <span class="keywordtype">int</span> nScatterPoints = scatterPointList-&gt;count;
01633 
01634         <span class="keywordtype">int</span> proc = 0;   
01635         coordIndex s;
01636         <span class="keywordtype">bool</span> validList = scatterPointList-&gt;getFirst(s);
01637         <span class="keywordtype">int</span> sCount = 0;
01638         <span class="keywordflow">while</span>(sCount &lt; nScatterPoints &amp;&amp; validList) {
01639                 <span class="keywordflow">if</span>(proc == 0) {
01640                         scatterPointSubList-&gt;add(s);
01641                 } <span class="keywordflow">else</span> {
01642                         <a class="code" href="classUtilities.html#e0">Utilities::mpiSend</a>(proc, &amp;s, <span class="keyword">sizeof</span>(coordIndex),0);
01643                 }
01644                 validList = scatterPointList-&gt;getNext(s);
01645                 ++sCount;
01646                 proc++;
01647                 proc = proc%numProcs;
01648         }
01649         <span class="keywordflow">for</span>(proc=1; proc &lt; numProcs ; proc++) {
01650                 <a class="code" href="classUtilities.html#e0">Utilities::mpiSend</a>(proc, &amp;sentryPoint, <span class="keyword">sizeof</span>(coordIndex),0);
01651         }       
01652 }
01653 
01654 <span class="keywordtype">void</span>  ModelBasedScatterCorrection::scatterPlayer(DList&lt;coordIndex&gt; *scatterPointSubList) {
01655         coordIndex s;
01656         <span class="keywordflow">do</span> {
01657                 <a class="code" href="classUtilities.html#e1">Utilities::mpiRecv</a>(0, &amp;s, <span class="keyword">sizeof</span>(coordIndex),0 );
01658                 scatterPointSubList-&gt;add(s);
01659         } <span class="keywordflow">while</span>(s.x != sentryPoint.x &amp;&amp; 
01660                 s.y != sentryPoint.y &amp;&amp; 
01661                 s.z != sentryPoint.z);
01662 }
01663 
01664 <span class="comment">/*;===============================================================================</span>
01665 <span class="comment">//+</span>
01666 <span class="comment">//       NAME</span>
01667 <span class="comment">//               computeScatter </span>
01668 <span class="comment">//</span>
01669 <span class="comment">//       SYNOPSIS</span>
01670 <span class="comment">//               computeScatter(frameInfo, house, params, scanner, samplingFactor, </span>
01671 <span class="comment">//                  emissionImage, muImage, endPointList, scatterPointList, </span>
01672 <span class="comment">//                  scatterPartial)</span>
01673 <span class="comment">//</span>
01674 <span class="comment">//       INPUT</span>
01675 <span class="comment">//               frameInfo - structure containing frame-specific info</span>
01676 <span class="comment">//               house - structure containing "house" data</span>
01677 <span class="comment">//               params - structure containing all the various parameter values</span>
01678 <span class="comment">//               scanner - structure describing the PET scanner hardware</span>
01679 <span class="comment">//               samplingFactor - a multiplicative factor that allows for more</span>
01680 <span class="comment">//                  coarse spatial sampling without changing the ultimate desired</span>
01681 <span class="comment">//                  sampling (params-&gt;modelBasedScatter.endPointAxialStep, </span>
01682 <span class="comment">//                  params-&gt;modelBasedScatter.endPointAzimuthalStep, </span>
01683 <span class="comment">//                  params-&gt;modelBasedScatter.scatterPointAxialStep and</span>
01684 <span class="comment">//                  params-&gt;modelBasedScatter.scatterPointAzimuthalStep)</span>
01685 <span class="comment">//               emissionImage - array containing the current image estimate</span>
01686 <span class="comment">//               muImage - array containing the attenuation coefficient map</span>
01687 <span class="comment">//               endPointList - list of all valid "detector" end point locations</span>
01688 <span class="comment">//               scatterPointList - list of all scatter point locations</span>
01689 <span class="comment">//</span>
01690 <span class="comment">//       OUTPUT</span>
01691 <span class="comment">//               scatterPartial - contribution to the total observed scatter</span>
01692 <span class="comment">//                  from the subset of scatter points computed on this node </span>
01693 <span class="comment">//               errMsg - informational message for error handler</span>
01694 <span class="comment">//</span>
01695 <span class="comment">//       DESCRIPTION</span>
01696 <span class="comment">//               Compute the contribution to the total observed scatter for each</span>
01697 <span class="comment">//               end point combination due to the subset of the scatter points</span>
01698 <span class="comment">//               computed on the current node</span>
01699 <span class="comment">//</span>
01700 <span class="comment">//       HISTORY</span>
01701 <span class="comment">//               2004-01-01 - cb - original code </span>
01702 <span class="comment">//-</span>
01703 <span class="comment">//===============================================================================</span>
01704 <span class="comment">//*/</span>
01705 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::computeScatter (<span class="keywordtype">float</span> samplingFactor,
01706             <a class="code" href="classImage.html">Image</a> &amp;muImage, <a class="code" href="classImage.html">Image</a> &amp;emissionImage, DList&lt;coordIndex&gt; *scatterPointList,           
01707            <a class="code" href="classArray4D.html">Array4D&lt;float&gt;</a> &amp;scatterPartial) {
01708         Status *status = Status::getStatus();
01709 
01710 <span class="preprocessor">#ifdef SCATTER_DEBUG</span>
01711 <span class="preprocessor"></span>        validateComputeRaySum(emissionImage, muImage);
01712 <span class="preprocessor">#endif</span>
01713 <span class="preprocessor"></span>
01714         <span class="keywordtype">int</span> debug = params-&gt;modelBasedScatter.verbosity;
01715         clock_t time0 = clock();
01716         
01717 <span class="comment">/*******************</span>
01718 <span class="comment">        if (debug &gt;= 2) {</span>
01719 <span class="comment">                //get_hrrt_dtct, xd, yd, zd //From house (setHrrtDtct)</span>
01720 <span class="comment">                house-&gt;getHrrtDtct(Array3D&lt;float&gt; &amp;xd, Array3D&lt;float&gt; &amp;yd, Array1D&lt;float&gt; &amp;zd);</span>
01721 <span class="comment">                muImage.write("muImage_computeScatter.xml", params-&gt;extensions);</span>
01722 <span class="comment">                //err=plotMuMask(params,muImage,errMsg)</span>
01723 <span class="comment">                //iplot, xd(0), yd(0), zd(0), linestyle=6, srm_index=3, sym_color=(0,0,200),$</span>
01724 <span class="comment">                //xrange=(-250,250), yrange=(-250,250), zrange=(-130,130)</span>
01725 <span class="comment">        }</span>
01726 <span class="comment">******************/</span>
01727     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
01728           status-&gt;printMemInfo();
01729     }
01730 
01731         <a class="code" href="classArray3D.html">Array3D&lt;char&gt;</a> mask;
01732         mask.<a class="code" href="classArray3D.html#a8">init</a>(params-&gt;geometry.nX,params-&gt;geometry.nY,params-&gt;geometry.nZ);
01733 <span class="comment">//</span>
01734         <span class="comment">// Determine volume to average mu (related to scatter point spacing)</span>
01735 <span class="comment">//</span>
01736         DList&lt;float&gt; *localMu = <span class="keyword">new</span> DList&lt;float&gt;;
01737         <span class="keywordtype">float</span> separation = params-&gt;modelBasedScatter.pointSeparation;
01738         <span class="comment">/***</span>
01739 <span class="comment">        int djxs = round(samplingFactor * separation / params-&gt;geometry.dX / 2.0);</span>
01740 <span class="comment">        int djys = round(samplingFactor * separation / params-&gt;geometry.dY / 2.0);</span>
01741 <span class="comment">        int djzs = round(samplingFactor * separation / params-&gt;geometry.dZ / 2.0);</span>
01742 <span class="comment">        ***/</span>
01743         <span class="keywordtype">int</span> djxs = 1;
01744         <span class="keywordtype">int</span> djys = 1;
01745         <span class="keywordtype">int</span> djzs = 1;
01746         <span class="keywordtype">float</span> scatterPointVolume = POW3(samplingFactor * separation); 
01747 
01748         <span class="keywordflow">if</span> ((debug &gt; 2) &amp;&amp; (status-&gt;proc == 0) ) {
01749                 cout &lt;&lt; <span class="stringliteral">"mu volume: "</span>&lt;&lt; djxs&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt; djys&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt; djzs&lt;&lt;<span class="stringliteral">"\n"</span>; ;
01750                 cout &lt;&lt; <span class="stringliteral">"computeScatter - setup: "</span>&lt;&lt;(clock()-time0)&lt;&lt; <span class="stringliteral">" microsec"</span>&lt;&lt;<span class="stringliteral">"\n"</span>;;
01751                 cout.flush();
01752                 time0 = clock();
01753         }
01754           
01755         <span class="comment">// Get ready to compute ray sums for scatterPoint, endPoint pairs</span>
01756 
01757         <span class="keywordtype">int</span> nScatterPoints = scatterPointList-&gt;count;
01758         
01759         <span class="comment">// Determine which scatter points are valid</span>
01760         
01761         <span class="keywordtype">int</span> jxmax = params-&gt;geometry.nX-1;
01762         <span class="keywordtype">int</span> jymax = params-&gt;geometry.nY-1;
01763         <span class="keywordtype">int</span> jzmax = params-&gt;geometry.nZ-1;
01764     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
01765           status-&gt;printMemInfo();
01766     }
01767 
01768 
01769         coordIndex curScatterPoint;
01770         <span class="keywordtype">bool</span> validList = <span class="keyword">false</span>;
01771         validList = scatterPointList-&gt;getFirst(curScatterPoint);
01772         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> scatpt = 0;
01773         scatpt &lt; nScatterPoints &amp;&amp; validList; scatpt++) {
01774 
01775     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
01776           status-&gt;printMemInfo();
01777     }
01778 
01779                 imgIndex scatterPointIndex;
01780                 <span class="keywordflow">if</span> (!convertCoordinatesToImageIndices(curScatterPoint, scatterPointIndex)) {
01781                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01782                 }
01783                 <span class="keywordtype">int</span> jxs = scatterPointIndex.x;
01784                 <span class="keywordtype">int</span> jys = scatterPointIndex.y;
01785                 <span class="keywordtype">int</span> jzs = scatterPointIndex.z;
01786                 <span class="keywordflow">if</span> ((debug &gt; 2)&amp;&amp; (status-&gt;proc == 0)) {
01787                 <span class="comment">/*</span>
01788 <span class="comment">                        int xxx = *curScatterPoint.x;</span>
01789 <span class="comment">                        int yyy = *curScatterPoint.y;</span>
01790 <span class="comment">                        int zzz = *curScatterPoint.z;</span>
01791 <span class="comment">                        */</span>
01792                 }
01793 
01794                 <span class="comment">// If scatter point is outside of image volume, then skip it</span>
01795 
01796                 <span class="keywordflow">if</span> ( (jxs &lt; 0) || (jxs &gt; jxmax) || 
01797                         (jys &lt; 0) || (jys &gt; jymax) || 
01798                         (jzs &lt; 0) || (jzs &gt; jzmax) ) {
01799                         <span class="keywordflow">if</span> (debug &gt;= 2) {
01800                         <span class="comment">//        print, 'BAD scatter point', scatterPointList(scatpt), jxs, jys, jzs, jxmax, jymax, jzmax</span>
01801                         <span class="comment">//        iplot, (xxx,xxx), (yyy,yyy), (zzz,zzz), sym_index=2, color=(0,200,0), overplot=1</span>
01802                                 <span class="comment">//oplot, (xxx,xxx), (yyy,yyy), psym=2, color=color24('purple')</span>
01803                                 <span class="comment">//print, scatterPointList(scatpt), xxx, yyy, zzz, '                 (bad pt)'</span>
01804                         }
01805 <span class="preprocessor">                #ifdef SCATTER_DEBUG</span>
01806 <span class="preprocessor"></span>                        cout &lt;&lt; <span class="stringliteral">"ScatterPoint["</span>&lt;&lt;scatpt&lt;&lt;<span class="stringliteral">"] = x:"</span>&lt;&lt;curScatterPoint.x&lt;&lt;<span class="stringliteral">" y:"</span>&lt;&lt;curScatterPoint.y&lt;&lt;<span class="stringliteral">" z:"</span>&lt;&lt;curScatterPoint.z&lt;&lt;<span class="stringliteral">"\n"</span>;
01807                         cout &lt;&lt; <span class="stringliteral">"Delete Scatter Point-1\n"</span>;
01808                         cout.flush();
01809 <span class="preprocessor">                #endif //SCATTER_DEBUG</span>
01810 <span class="preprocessor"></span>                        scatterPointList-&gt;delElement();
01811                 } <span class="keywordflow">else</span> {
01812 
01813                         <span class="comment">// If scatter point is inside a region with very low attenuation coefficient, then skip</span>
01814 
01815                         <span class="keywordtype">int</span> jxs1 = maxOfNum(0, scatterPointIndex.x - djxs);
01816                         <span class="keywordtype">int</span> jys1 = maxOfNum(0, scatterPointIndex.y - djys);
01817                         <span class="keywordtype">int</span> jzs1 = maxOfNum(0, scatterPointIndex.z - djzs);
01818                         <span class="keywordtype">int</span> jxs2 = minOfNum(scatterPointIndex.x + djxs, params-&gt;geometry.nX - 1);
01819                         <span class="keywordtype">int</span> jys2 = minOfNum(scatterPointIndex.y + djys, params-&gt;geometry.nY - 1);
01820                         <span class="keywordtype">int</span> jzs2 = minOfNum(scatterPointIndex.z + djzs, params-&gt;geometry.nZ - 1);
01821                         <span class="keywordtype">float</span> avg_mu = meanPartial(muImage,jxs1,jxs2,jys1,jys2,jzs1,jzs2);
01822                         <span class="keywordflow">if</span> ( avg_mu &lt; params-&gt;modelBasedScatter.attenThreshold ) {
01823 <span class="preprocessor">                #ifdef SCATTER_DEBUG</span>
01824 <span class="preprocessor"></span>                                cout &lt;&lt; <span class="stringliteral">"ScatterPoint["</span>&lt;&lt;scatpt&lt;&lt;<span class="stringliteral">"] = x:"</span>&lt;&lt;curScatterPoint.x&lt;&lt;<span class="stringliteral">" y:"</span>&lt;&lt;curScatterPoint.y&lt;&lt;<span class="stringliteral">" z:"</span>&lt;&lt;curScatterPoint.z&lt;&lt;<span class="stringliteral">"\n"</span>;
01825                                 cout &lt;&lt; <span class="stringliteral">"Delete Scatter Point-2\n"</span>;
01826                                 cout.flush();
01827 <span class="preprocessor">                #endif //SCATTER_DEBUG</span>
01828 <span class="preprocessor"></span>                                scatterPointList-&gt;delElement();
01829                         } <span class="keywordflow">else</span> {
01830     
01831                 
01832                                 <span class="comment">// Collect the valid scatter points and the average atten. coeff. in its neighborhood</span>
01833                                 localMu-&gt;add(avg_mu);
01834                         }
01835                 }
01836                 validList = scatterPointList-&gt;getNext(curScatterPoint);
01837         }
01838         <span class="keywordflow">if</span> ((debug &gt; 2) &amp;&amp; (status-&gt;proc == 0)) {
01839                 cout &lt;&lt; <span class="stringliteral">"computeScatter - select valid scatter points: "</span>&lt;&lt; clock()-time0&lt;&lt; <span class="stringliteral">" microsec\n"</span>; 
01840                 cout &lt;&lt; <span class="stringliteral">"Valid scatter points:"</span>&lt;&lt;scatterPointList-&gt;count&lt;&lt;<span class="stringliteral">"\n"</span>;
01841                 cout &lt;&lt; <span class="stringliteral">"Valid localMu:"</span>&lt;&lt;localMu-&gt;count&lt;&lt;<span class="stringliteral">"\n"</span>;
01842                 cout.flush();
01843                 time0 = clock();
01844         }
01845         nScatterPoints = scatterPointList-&gt;count;
01846 
01847         <span class="comment">// Compute the ray sums and incidence angles for scatterPoint, endPoint pairs</span>
01848 
01849         
01850         <a class="code" href="classArray3D.html">Array3D&lt;float&gt;</a> emissionRaySum(nScatterPoints,endPointList.nAngles,endPointList.nSlices);
01851         <a class="code" href="classArray3D.html">Array3D&lt;float&gt;</a> muRaySum(nScatterPoints,endPointList.nAngles,endPointList.nSlices);
01852         <a class="code" href="classArray3D.html">Array3D&lt;float&gt;</a> axialIncidenceAngle(nScatterPoints,endPointList.nAngles,endPointList.nSlices);
01853         <a class="code" href="classArray3D.html">Array3D&lt;float&gt;</a> azimuthalIncidenceAngle(nScatterPoints,endPointList.nAngles,endPointList.nSlices);
01854     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
01855           status-&gt;printMemInfo();
01856     }
01857 
01858 
01859         validList = scatterPointList-&gt;getFirst(curScatterPoint);
01860         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> scatpt = 0; scatpt &lt; nScatterPoints &amp;&amp; validList; 
01861              scatpt++,validList = scatterPointList-&gt;getNext(curScatterPoint)) {
01862                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSlice = 0; iSlice &lt;= endPointList.nSlices-1; iSlice++) {
01863                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngle = 0; iAngle &lt;= endPointList.nAngles-1; iAngle++) {
01864                                  coordIndex endPoint;
01865                                  endPoint.x = endPointList.x(iAngle,iSlice);
01866                                  endPoint.y = endPointList.y(iAngle,iSlice);
01867                                  endPoint.z = endPointList.z(iAngle,iSlice);
01868                                 <span class="keywordflow">if</span> ((debug &gt; 2)&amp;&amp; (status-&gt;proc == 0)) {
01869                                 <span class="comment">/*</span>
01870 <span class="comment">                                   oplot,(endPoint.x,endPoint.x),</span>
01871 <span class="comment">                                         (endPoint.y,endPoint.y),</span>
01872 <span class="comment">                                         psym=2, color=color24('red'), linestyle=1</span>
01873 <span class="comment">                                   oplot,(scatpt.x,scatpt.x),</span>
01874 <span class="comment">                                         (scatpt.y,scatpt.y),</span>
01875 <span class="comment">                                         psym=2, color=color24('green'), linestyle=1</span>
01876 <span class="comment">                                */</span>
01877                                 }
01878                                 
01879                                 <span class="keywordtype">float</span> emissionSum, muSum;
01880                                 <span class="keywordflow">if</span> (!computeRaySum(emissionImage, muImage, endPoint, curScatterPoint,    
01881                                     emissionSum, muSum)) { 
01882                                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01883                                 }
01884 
01885                                 emissionRaySum(scatpt,iAngle,iSlice) = emissionSum;
01886                                 muRaySum(scatpt,iAngle,iSlice) = muSum;
01887 
01888                                 <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.computeIncidenceAngles) {
01889                                         <span class="keywordtype">int</span> select;
01890                                         coordIndex panelIntersection;
01891                                         <span class="keywordtype">float</span> axialAngle, azimuthalAngle;
01892                                         <span class="keywordflow">if</span> (!getPanelHit(endPoint, curScatterPoint, panelIntersection,     
01893                                            select)) {
01894                                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
01895                                         }
01896                                         <span class="keywordflow">if</span> (!getIncidenceAngles(curScatterPoint, panelIntersection, select, axialAngle, azimuthalAngle,       
01897                                                 endPoint)) {
01898                                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
01899                                         }
01900                                         axialIncidenceAngle(scatpt,iAngle,iSlice) = axialAngle;
01901                                         azimuthalIncidenceAngle(scatpt,iAngle,iSlice) = azimuthalAngle;
01902 
01903                                         <span class="keywordflow">if</span> (debug &gt; 4) {
01904                                         <span class="comment">/*</span>
01905 <span class="comment">                                                oplot,(panelIntersection.x,scatpt.x),</span>
01906 <span class="comment">                                   (panelIntersection.y,scatpt.y),</span>
01907 <span class="comment">                                   psym=0, color=color24('yellow'), linestyle=0</span>
01908 <span class="comment">                                      xyouts, -390, -390, acos(azimuthalAngle)*180.0/Constant::PI  ,charsize=3</span>
01909 <span class="comment">                                     print, 'Ax: ', acos(axialAngle)*180.0/Constant::PI, '  Azim: ',$ </span>
01910 <span class="comment">                                            acos(azimuthalAngle)*180.0/Constant::PI, '  Panel: ',select, </span>
01911 <span class="comment">                                    panelIntersection.z,scatpt.z</span>
01912 <span class="comment">                                        xxx=bytarr(300,50);</span>
01913 <span class="comment">                                        tvscl,xxx</span>
01914 <span class="comment">                                        oplot,(endPoint.x,scatpt.x),</span>
01915 <span class="comment">                                                (endPoint.y,scatpt.y),</span>
01916 <span class="comment">                                        psym=0, color=color24('black'), linestyle=0</span>
01917 <span class="comment">                                        */</span>
01918                                         
01919                                         }
01920                                 }
01921                         }
01922                 }
01923         }
01924         <span class="keywordflow">if</span> ((debug &gt; 2)&amp;&amp; (status-&gt;proc == 0)) {
01925                 cout&lt;&lt; <span class="stringliteral">"computeScatter - raySums and ASBIncidenceAngles done: "</span>&lt;&lt; clock()-time0&lt;&lt; <span class="stringliteral">" microsec\n"</span> ;
01926                 cout.flush();
01927                 time0 = clock();
01928         }
01929 
01930     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
01931           status-&gt;printMemInfo();
01932     }
01933 
01934         <a class="code" href="classArray4D.html">Array4D&lt;float&gt;</a> LORAxialIncidenceAngle(endPointList.nAngles,endPointList.nSlices,
01935                                   endPointList.nAngles,endPointList.nSlices);
01936         <a class="code" href="classArray4D.html">Array4D&lt;float&gt;</a> LORAzimuthalIncidenceAngle(endPointList.nAngles,endPointList.nSlices,
01937                                   endPointList.nAngles,endPointList.nSlices);
01938         <span class="comment">// Compute incidence angles for LORs, one set for each endPoint</span>
01939         <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.computeIncidenceAngles) {
01940  
01941                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceA = 0; iSliceA &lt;= endPointList.nSlices-1; iSliceA++) {
01942                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleA = 0; iAngleA &lt;= endPointList.nAngles-1; iAngleA++) {
01943                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceB = 0; iSliceB &lt;= endPointList.nSlices-1; iSliceB++) {
01944                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleB = 0; iAngleB &lt;= endPointList.nAngles-1; iAngleB++) {
01945                                                 coordIndex endPointA;
01946                                                 endPointA.x = endPointList.x(iAngleA,iSliceA);
01947                                                 endPointA.y = endPointList.y(iAngleA,iSliceA);
01948                                                 endPointA.z = endPointList.z(iAngleA,iSliceA);
01949                                                 coordIndex endPointB;
01950                                                 endPointB.x = endPointList.x(iAngleB,iSliceB);
01951                                                 endPointB.y = endPointList.y(iAngleB,iSliceB);
01952                                                 endPointB.z = endPointList.z(iAngleB,iSliceB);
01953 
01954                                                 <span class="comment">// Skip pairs that do not intersect the FOV</span>
01955                                                 coordIntersectionIndex inter;
01956                                                 <span class="keywordflow">if</span> (!getCylinderIntersection(params-&gt;geometry.FOV_r, endPointA,
01957                                                         endPointB, inter )) {
01958                                                         <span class="keywordflow">continue</span>;
01959                                                 }
01960 
01961                                                 <span class="comment">// Skip pairs that align along the z-axis</span>
01962                                                 <span class="keywordflow">if</span> (endPointA.x == endPointB.x &amp;&amp; endPointA.y == endPointB.y )  
01963                                                         <span class="keywordflow">continue</span>;
01964     
01965                                                 <span class="comment">// Incidence angle at detector A from the direction of detector B</span>
01966                                                 coordIndex sourcePoint = endPointB;
01967                                                 coordIndex panelIntersection;
01968                                                 <span class="keywordtype">int</span> select;
01969                                                 <span class="keywordtype">float</span> axialAngle=0.0, azimuthalAngle=0.0;
01970                                                 <span class="keywordflow">if</span> (!getPanelHit(endPointA, sourcePoint, panelIntersection, select)) {
01971                                                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01972                                                 }
01973                                                 <span class="keywordflow">if</span> (!getIncidenceAngles(sourcePoint, panelIntersection, select,
01974                                                          axialAngle, azimuthalAngle, endPointA)) {
01975                                                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01976                                                 }
01977                                                 LORAxialIncidenceAngle(iAngleA,iSliceA,iAngleB,iSliceB) = axialAngle;
01978                                                 LORAzimuthalIncidenceAngle(iAngleA,iSliceA,iAngleB,iSliceB) = azimuthalAngle;
01979 
01980                                                 <span class="comment">// Incidence angle at detector B from the direction of detector A</span>
01981                                                 sourcePoint = endPointA;
01982                                                 <span class="keywordflow">if</span> (!getPanelHit(endPointB,        
01983                                                         sourcePoint, panelIntersection, select)) {
01984                                                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01985                                                 }
01986                                                 <span class="keywordflow">if</span> (!getIncidenceAngles(sourcePoint,      
01987                                                         panelIntersection, select, axialAngle, azimuthalAngle,
01988                                                         endPointB)) {
01989                                                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01990                                                 }
01991                                                 LORAxialIncidenceAngle(iAngleB,iSliceB,iAngleA,iSliceA) = axialAngle;
01992                                                 LORAzimuthalIncidenceAngle(iAngleB,iSliceB,iAngleA,iSliceA) = azimuthalAngle;
01993                                         }
01994                                 }
01995                         }
01996                 }
01997         }
01998 
01999         <span class="keywordflow">if</span> ((debug &gt; 2)&amp;&amp; (status-&gt;proc == 0)) {
02000                 cout&lt;&lt; <span class="stringliteral">"computeScatter - LORIncidenceAngles done: "</span>&lt;&lt; clock()-time0&lt;&lt; <span class="stringliteral">" sec\n"</span>;
02001                 time0 = clock();
02002                 cout.flush();
02003                 <span class="comment">/*</span>
02004 <span class="comment">                tvscl, total(mask,1), 150,0 </span>
02005 <span class="comment">                tvscl, total(mask,2), 0,150 </span>
02006 <span class="comment">                tvscl, total(mask,3), 0,0 </span>
02007 <span class="comment">                */</span>
02008         }
02009 
02010     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
02011           status-&gt;printMemInfo();
02012     }
02013 
02014         <span class="comment">// Quadratic function used to scale atten. coeff. from 511 keV value  </span>
02015         <span class="comment">//   to that for the scatter photon energy (expressed by scatter angle cosine)</span>
02016 
02017         <span class="keywordtype">float</span> p0 = params-&gt;modelBasedScatter.attenScaleParam0;   <span class="comment">// constant term </span>
02018         <span class="keywordtype">float</span> p1 = params-&gt;modelBasedScatter.attenScaleParam1;   <span class="comment">// linear term</span>
02019         <span class="keywordtype">float</span> p2 = params-&gt;modelBasedScatter.attenScaleParam2;   <span class="comment">// quadratic term</span>
02020 
02021         <span class="keywordtype">int</span> nTotalASB = 0;
02022         <span class="keywordtype">int</span> nExcluded = 0;
02023         <span class="keywordtype">int</span> nIncluded = 0;
02024         <span class="keywordtype">float</span> rSA2, rSB2;
02025 
02026         <span class="comment">// Compute scatter for each endPoint, endPoint pair </span>
02027         scatterPartial.<a class="code" href="classArray4D.html#a9">init</a>(endPointList.nAngles,endPointList.nSlices,
02028                                 endPointList.nAngles,endPointList.nSlices);
02029         
02030         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceA = 0; iSliceA &lt;= endPointList.nSlices-1; iSliceA++) 
02031                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleA = 0; iAngleA &lt;= endPointList.nAngles-1; iAngleA++) 
02032                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceB = 0; iSliceB &lt;= endPointList.nSlices-1; iSliceB++) 
02033                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleB = 0; iAngleB &lt;= endPointList.nAngles-1; iAngleB++) 
02034                                         scatterPartial(iAngleA,iSliceA,iAngleB,iSliceB) = 0.0;
02035         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceA = 0; iSliceA &lt;= endPointList.nSlices-1; iSliceA++) {
02036                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleA = 0; iAngleA &lt;= endPointList.nAngles-1; iAngleA++) {
02037     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
02038           status-&gt;printMemInfo();
02039     }
02040                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSliceB = 0; iSliceB &lt;= endPointList.nSlices-1; iSliceB++) {
02041                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAngleB = 0; iAngleB &lt;= endPointList.nAngles-1; iAngleB++) {
02042                                         coordIndex endPointA;
02043 
02044                                         endPointA.x = endPointList.x(iAngleA,iSliceA);
02045                                         endPointA.y = endPointList.y(iAngleA,iSliceA);
02046                                         endPointA.z = endPointList.z(iAngleA,iSliceA);
02047                                         coordIndex endPointB;
02048                                         endPointB.x = endPointList.x(iAngleB,iSliceB);
02049                                         endPointB.y = endPointList.y(iAngleB,iSliceB);
02050                                         endPointB.z = endPointList.z(iAngleB,iSliceB);
02051 
02052                                         <span class="comment">// Accumulate contributions due to each scatterPoint</span>
02053                                          validList = scatterPointList-&gt;getFirst(curScatterPoint);
02054                                          <span class="keywordtype">float</span> curlocalMu = 0.0;
02055                                          <span class="keywordtype">bool</span> validList1 = localMu-&gt;getFirst(curlocalMu);
02056                                          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> scatpt = 0; 
02057                                               scatpt &lt; nScatterPoints &amp;&amp; validList &amp;&amp; validList1; 
02058                                               scatpt++,validList = scatterPointList-&gt;getNext(curScatterPoint),
02059                                                  validList1 = localMu-&gt;getNext(curlocalMu) ){
02060                                                 
02061                                                 <span class="keywordflow">if</span> (debug &gt; 4) {
02062                                                         time0 = clock();
02063                                                         cout&lt;&lt; <span class="stringliteral">"computeScatter - START SCATPT LOOP: "</span>&lt;&lt; clock()-time0&lt;&lt; <span class="stringliteral">" sec"</span>&lt;&lt;endl;
02064                                                         cout.flush();
02065                                                         time0 = clock();
02066                                                 }
02067 
02068                                                 <span class="comment">// Determine the angle between ray AS and BS </span>
02069                                                 <span class="comment">//   - needed to determine scatter photon energy</span>
02070 
02071                                                 coordIndex scatterPoint = curScatterPoint;
02072 
02073                                                 <span class="comment">// Get dot product of (locS-locA) and (locS-locB)</span>
02074 
02075                                                 <span class="keywordtype">float</span> numerator  = (scatterPoint.x - endPointA.x) * (scatterPoint.x - endPointB.x);
02076                                                 numerator += (scatterPoint.y - endPointA.y) * (scatterPoint.y - endPointB.y);
02077                                                 numerator += (scatterPoint.z - endPointA.z) * (scatterPoint.z - endPointB.z);
02078 
02079                                                 <span class="comment">// Exclude angles &gt; 90 degrees (backscatter)</span>
02080 
02081                                                 <span class="keywordflow">if</span> (numerator &gt; 0.0) <span class="keywordflow">continue</span>;
02082 
02083                                                 <span class="comment">// Get product of norm(locS-locA) and norm(locS-locB)</span>
02084 
02085                                                 rSA2  = POW2(scatterPoint.x-endPointA.x);
02086                                                 rSA2 += POW2(scatterPoint.y-endPointA.y);
02087                                                 rSA2 += POW2(scatterPoint.z-endPointA.z);
02088                                                 rSB2  = POW2(scatterPoint.x-endPointB.x);
02089                                                 rSB2 += POW2(scatterPoint.y-endPointB.y);
02090                                                 rSB2 += POW2(scatterPoint.z-endPointB.z);
02091                                                 <span class="keywordtype">float</span> denominator = sqrt(rSA2) * sqrt(rSB2);
02092 
02093                                                 <span class="comment">// This gives you the scatter angle cosine</span>
02094 
02095                                                 <span class="keywordtype">float</span> scatterAngleCosine = fabs(numerator / denominator); 
02096                                                 <span class="keywordflow">if</span> (debug &gt; 4) {
02097                                                         cout&lt;&lt;<span class="stringliteral">"computeScatter - GOT SCATTER ANGLE: "</span>&lt;&lt; clock()-time0&lt;&lt; <span class="stringliteral">" sec"</span>&lt;&lt;endl;
02098                                                         time0 = clock();
02099                                                 }
02100 
02101                                                 nTotalASB += 1;  <span class="comment">// count total number of ASB combinations considered</span>
02102 
02103                                                 <span class="comment">// Compute detection probability roll-off around reconLLD that results</span>
02104                                                 <span class="comment">// from finite energy resolution of detectors</span>
02105                                                 
02106                                                 <span class="keywordtype">float</span> photonEnergy = 511. / (2.-scatterAngleCosine);
02107                                                 <span class="keywordtype">float</span> scatterEnergyEff = probDetect(photonEnergy);
02108                                                 
02109                                                 <span class="comment">// Exclude scatters that have detection probability below the threshold</span>
02110                                                 
02111                                                 <span class="keywordflow">if</span> ((scatterEnergyEff &lt; params-&gt;modelBasedScatter.detectionThreshold)) {
02112                                                         nExcluded +=1; <span class="comment">// count how many ASB combinations are excluded</span>
02113                                                         <span class="keywordflow">continue</span>;    
02114                                                 }
02115                                                 
02116                                                 <span class="comment">// Scale atten. coeff. according to photon energy (as expressed by cos(scatterAngle))</span>
02117 
02118                                                 <span class="keywordtype">float</span> attenScaleFactor = p0 +
02119                                                         p1*scatterAngleCosine + p2*POW2(scatterAngleCosine);
02120                                                 <span class="keywordtype">float</span> emissionRaySumSA = emissionRaySum(scatpt,iAngleA,iSliceA);
02121                                                 <span class="keywordtype">float</span> emissionRaySumSB = emissionRaySum(scatpt,iAngleB,iSliceB);
02122                                                 <span class="keywordtype">float</span> muRaySumSA = muRaySum(scatpt,iAngleA,iSliceA);
02123                                                 <span class="keywordtype">float</span> muRaySumSB = muRaySum(scatpt,iAngleB,iSliceB);
02124                                                 <span class="keywordtype">float</span> scatterMuRaySumSA = muRaySumSA * attenScaleFactor;     
02125                                                 <span class="keywordtype">float</span> scatterMuRaySumSB = muRaySumSB * attenScaleFactor;     
02126                                                 <span class="keywordflow">if</span> (debug &gt; 4) {
02127                                                         cout&lt;&lt;<span class="stringliteral">"computeScatter - SCALED ATTEN COEFF: "</span>&lt;&lt;clock()-time0&lt;&lt;<span class="stringliteral">" sec"</span>&lt;&lt;endl;
02128                                                         time0 = clock(); 
02129                                                 }
02130 
02131                                                 <span class="comment">// Compute detection efficiency for scatter photon energy (from scatterAngleCosine)</span>
02132                                                 <span class="comment">// that results from stopping power differences of crystals at diff energies</span>
02133 
02134                                                 <span class="keywordtype">float</span> p0 = params-&gt;modelBasedScatter.detectionEffParam0;
02135                                                 <span class="keywordtype">float</span> p1 = params-&gt;modelBasedScatter.detectionEffParam1;
02136                                                 <span class="keywordtype">float</span> p2 = params-&gt;modelBasedScatter.detectionEffParam2;
02137                 <span class="keywordtype">float</span> p3 = 0.0; <span class="comment">//params-&gt;modelBasedScatter.detectionEffParam2;</span>
02138                                                 scatterEnergyEff *= p0 + p1*scatterAngleCosine + p2*POW2(scatterAngleCosine);
02139                                                 <span class="keywordflow">if</span> (debug &gt; 4) {
02140                                                         cout&lt;&lt;<span class="stringliteral">"computeScatter - GOT ENERGY DET EFF: "</span>&lt;&lt;clock()-time0&lt;&lt;<span class="stringliteral">" sec"</span>&lt;&lt;endl;
02141                                                         time0 = clock(); 
02142                                                 }
02143 
02144                                                 <span class="comment">// Compute the geometric factors due to different incidence angles</span>
02145 
02146                                                 <span class="keywordtype">float</span> detectionEff;
02147                                                 <span class="keywordflow">if</span> (params-&gt;modelBasedScatter.computeIncidenceAngles) {
02148                                                         p0 =  0.1099; 
02149                                                         p1 =  2.1531;
02150                                                         p2 = -1.9112;
02151                                                         p3 =  0.6479;
02152 <span class="comment">// axial</span>
02153                                                         <span class="keywordtype">float</span> angleCosine = LORAxialIncidenceAngle(iAngleA,iSliceA,iAngleB,iSliceB);
02154                                                         <span class="keywordtype">float</span> geometricEff_AB_axial = p0 +
02155                                                                 p1*angleCosine + p2*POW2(angleCosine) + p3*POW3(angleCosine);
02156                                                         angleCosine = LORAxialIncidenceAngle(iAngleB,iSliceB,iAngleA,iSliceA);
02157                                                         <span class="keywordtype">float</span> geometricEff_BA_axial = p0 +
02158                                                                 p1*angleCosine + p2*POW2(angleCosine) + p3*POW3(angleCosine);
02159                                                         angleCosine = axialIncidenceAngle(scatpt,iAngleA,iSliceA);
02160                                                         <span class="keywordtype">float</span> geometricEff_SA_axial = p0 +
02161                                                                 p1*angleCosine + p2*POW2(angleCosine) + p3*POW3(angleCosine);
02162                                                         angleCosine = axialIncidenceAngle(scatpt,iAngleB,iSliceB);
02163                                                         <span class="keywordtype">float</span> geometricEff_SB_axial = p0 +
02164                                                                 p1*angleCosine + p2*POW2(angleCosine) + p3*POW3(angleCosine);
02165 <span class="comment">// azimuthal</span>
02166                                                         angleCosine = LORAzimuthalIncidenceAngle(iAngleA,iSliceA,iAngleB,iSliceB);
02167                                                         <span class="keywordtype">float</span> geometricEff_AB_azimuthal = p0 +
02168                                                                 p1*angleCosine + p2*POW2(angleCosine) + p3*POW3(angleCosine);
02169                                                         angleCosine = LORAzimuthalIncidenceAngle(iAngleB,iSliceB,iAngleA,iSliceA);
02170                                                         <span class="keywordtype">float</span> geometricEff_BA_azimuthal = p0 +
02171                                                                 p1*angleCosine + p2*POW2(angleCosine) + p3*POW3(angleCosine);
02172                                                         angleCosine = azimuthalIncidenceAngle(scatpt,iAngleA,iSliceA);
02173                                                         <span class="keywordtype">float</span> geometricEff_SA_azimuthal = p0 +
02174                                                                 p1*angleCosine + p2*POW2(angleCosine) + p3*POW3(angleCosine);
02175                                                         angleCosine = azimuthalIncidenceAngle(scatpt,iAngleB,iSliceB);
02176                                                         <span class="keywordtype">float</span> geometricEff_SB_azimuthal = p0 +
02177                                                                 p1*angleCosine + p2*POW2(angleCosine) + p3*POW3(angleCosine);
02178         
02179                                                         <span class="keywordtype">float</span> detectionEffSA  = geometricEff_SA_axial * geometricEff_SA_azimuthal;
02180                                                         detectionEffSA /= geometricEff_AB_axial * geometricEff_AB_azimuthal;
02181 
02182                                                         <span class="keywordtype">float</span> detectionEffSB  = geometricEff_SB_axial * geometricEff_SB_azimuthal;
02183                                                         detectionEffSB /= geometricEff_BA_axial * geometricEff_BA_azimuthal;
02184         
02185                                                         detectionEff = detectionEffSA * detectionEffSB * scatterEnergyEff;
02186                                                 } <span class="keywordflow">else</span> {
02187                                                         detectionEff = scatterEnergyEff;
02188                                                 }
02189  
02190                                                 <span class="keywordflow">if</span> (debug &gt; 4) {
02191                                                         cout&lt;&lt;<span class="stringliteral">"computeScatter - GOT GEOM DET EFFS: "</span>&lt;&lt;clock()-time0&lt;&lt;<span class="stringliteral">" sec"</span>&lt;&lt;endl;
02192                                                         time0 = clock();
02193                                                 }
02194          
02195 <span class="comment">//print, endptA, endptB, scatpt, muRaySumSA, scatterMuRaySumSB, emissionRaySumSA, geometricEff.SA.axial,$</span>
02196 <span class="comment">//geometricEff.AB.axial, geometricEff.SA.azimuthal, geometricEff.AB.azimuthal, scatterEnergyEff, detectionEff</span>
02197 <span class="comment">//</span>
02198 <span class="comment">// Compute the geometric cross sections presented to S by the detectors at A and B</span>
02199 <span class="comment">//   Compute the crystal area assuming normal incidence since the geometricEff</span>
02200 <span class="comment">//   accounts for oblique incidence.</span>
02201 <span class="comment">//        </span>
02202                                                 <span class="keywordtype">float</span> crystalArea = scannerParams-&gt;dtctWidthX * scannerParams-&gt;dtctWidthZ;
02203                                                 <span class="keywordtype">float</span> geometricCrossSectionSA = crystalArea / rSA2;  
02204                                                 <span class="keywordtype">float</span> geometricCrossSectionSB = crystalArea / rSB2;  
02205 <span class="comment">//      </span>
02206 <span class="comment">// Compute differential cross section for 511 keV photons at this scatter angle</span>
02207 <span class="comment">//</span>
02208                                                 <span class="keywordtype">float</span> diffCrossSection  = 1.0 / 2.0; <span class="comment">//(1/electron);</span>
02209                                                 diffCrossSection *= ( 1.0 +POW2(scatterAngleCosine) ) / POW2( 2.0 - scatterAngleCosine );
02210                                                 diffCrossSection *= ( 1.0 +POW2(1-scatterAngleCosine) /
02211                                                       ((2.0-scatterAngleCosine)*(1.0+POW2(scatterAngleCosine))) );
02212                                                 <span class="keywordflow">if</span> (debug &gt; 4) {
02213                                                          cout&lt;&lt;<span class="stringliteral">"computeScatter - GOT DIFF CROSS SECTION: "</span>&lt;&lt;clock()-time0&lt;&lt;<span class="stringliteral">" sec"</span>&lt;&lt;endl;
02214                                                         time0 = clock(); 
02215                                                 }
02216 <span class="comment">//</span>
02217 <span class="comment">// Compute the total photon flux at A and B due to scatter point S</span>
02218 <span class="comment">//</span>
02219                                                 <span class="keywordtype">float</span> Isa = exp( -(muRaySumSA + scatterMuRaySumSB) ) * emissionRaySumSA;
02220                                                 <span class="keywordtype">float</span> Isb = exp( -(scatterMuRaySumSA + muRaySumSB) ) * emissionRaySumSB;
02221                                                 <span class="keywordtype">float</span> Iasb = detectionEff * (Isa + Isb);
02222                                                 <span class="keywordflow">if</span> (debug &gt; 4) {
02223                                                         cout&lt;&lt;<span class="stringliteral">"computeScatter - GOT TOTAL PHOTON FLUX: "</span>&lt;&lt;clock()-time0&lt;&lt;<span class="stringliteral">" sec"</span>&lt;&lt;endl;
02224                                                         time0 = clock();
02225                                                 } 
02226 <span class="comment">//</span>
02227 <span class="comment">// Compute the scatter contribution from this ASB combination</span>
02228 <span class="comment">//</span>
02229                                                 <span class="keywordtype">float</span> comptonScatterCoeff = 2.365412; 
02230                                                 <span class="keywordtype">float</span> bigFactor = geometricCrossSectionSA * geometricCrossSectionSB;
02231                                                 bigFactor *= curlocalMu * diffCrossSection * scatterPointVolume;   
02232                                                 bigFactor /= 4.0 * Constant::PI * comptonScatterCoeff;
02233                                                 <span class="keywordtype">float</span> scatterTemp = params-&gt;modelBasedScatter.globalScaleFactor * 
02234                                                                         bigFactor * Iasb;         
02235                                                 scatterPartial(iAngleA,iSliceA,iAngleB,iSliceB) += scatterTemp; 
02236                                                 nIncluded += 1; <span class="comment">// count how many ASB combinations contribute</span>
02237                                                 <span class="keywordflow">if</span> (debug &gt; 4) {
02238                                                         cout&lt;&lt;<span class="stringliteral">"computeScatter - GOT SCATTER ESTIMATE:"</span>&lt;&lt;clock()-time0&lt;&lt;<span class="stringliteral">" sec"</span>&lt;&lt;endl;
02239                                                         time0 = clock();
02240                                                 } 
02241 
02242 <span class="comment">//                                              if (params-&gt;modelBasedScatter.verbosity &gt; 4) {</span>
02243 <span class="keywordflow">if</span> (debug &gt; 3 &amp;&amp; scatpt == 3 &amp;&amp; iAngleB == 50 &amp;&amp; iSliceA == 8 &amp;&amp; iSliceB == 8) {
02244                                                         cout&lt;&lt;<span class="stringliteral">"iAngleA,iSliceA,iAngleB,iSliceB "</span>&lt;&lt;iAngleA&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iSliceA&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iAngleB&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;iSliceB&lt;&lt;endl;
02245                                                         cout&lt;&lt;<span class="stringliteral">"    scatpt, scatterTemp, bigFactor "</span>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;scatpt&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;scatterTemp&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;bigFactor&lt;&lt;endl;
02246                                                         cout&lt;&lt;<span class="stringliteral">"    crystalArea, rSA2, rSB2 "</span>&lt;&lt;crystalArea&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;rSA2&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;rSB2&lt;&lt;endl;
02247                                                         cout&lt;&lt;<span class="stringliteral">"    geometricCrossSectionSA,geometricCrossSectionSB,localMu(scatpt) "</span>&lt;&lt;geometricCrossSectionSA&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;geometricCrossSectionSB&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;curlocalMu&lt;&lt;endl; 
02248                                                         cout&lt;&lt;<span class="stringliteral">"    diffCrossSection,detectionEff "</span>&lt;&lt;diffCrossSection&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;detectionEff&lt;&lt;endl;
02249                                                         cout&lt;&lt;<span class="stringliteral">"    muRaySumSA, scatterMuRaySumSA,emissionRaySumSA, Iasb "</span>&lt;&lt;muRaySumSA&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;scatterMuRaySumSA&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;emissionRaySumSA&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;Iasb&lt;&lt;endl;
02250                                                         cout&lt;&lt;<span class="stringliteral">"    scatpt x,y,z "</span>&lt;&lt;scatterPoint.x&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;scatterPoint.y&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;scatterPoint.z&lt;&lt;endl;
02251                                                         cout&lt;&lt;<span class="stringliteral">"    endptA x,y,z "</span>&lt;&lt;endPointA.x   &lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;endPointA.y   &lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;endPointA.z   &lt;&lt;endl;
02252                                                         cout&lt;&lt;<span class="stringliteral">"    endptB x,y,z "</span>&lt;&lt;endPointB.x   &lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;endPointB.y   &lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;endPointB.z   &lt;&lt;endl;
02253                                                 }
02254                                         }
02255                                 }
02256                         }
02257                 }
02258         }
02259         <span class="keywordflow">if</span> ((debug &gt; 2)&amp;&amp; (status-&gt;proc == 0)) {
02260                 cout &lt;&lt;<span class="stringliteral">"computeScatter - calc scatter contributions done: "</span>&lt;&lt;
02261                         clock()-time0&lt;&lt;<span class="stringliteral">" sec, or "</span>&lt;&lt;(clock()-time0)/float(nTotalASB)
02262                         &lt;&lt;<span class="stringliteral">" per ASB\n"</span>;
02263                         time0 = clock(); 
02264                 cout&lt;&lt; <span class="stringliteral">"Total ASBs: "</span>&lt;&lt;nTotalASB&lt;&lt;<span class="stringliteral">" Below LLD: "</span>&lt;&lt;nExcluded&lt;&lt;
02265                         <span class="stringliteral">" Above LLD: "</span>&lt;&lt;nIncluded&lt;&lt;<span class="stringliteral">"\n"</span>; 
02266                 cout.flush();
02267                 
02268         }
02269 
02270     <span class="keywordflow">if</span>(params-&gt;frame.verbosity &gt;= 6) {
02271           status-&gt;printMemInfo();
02272     }
02273 
02274         <span class="keywordflow">return</span> <span class="keyword">true</span>;
02275 }
02276 
02277 
02278 
02279 <span class="comment">/********************************************************************</span>
02280 <span class="comment">//SOME GENERAL NOTES COMPARING IMPLEMENTATION SPEEDS</span>
02281 <span class="comment"></span>
02282 <span class="comment">//METHOD 1</span>
02283 <span class="comment">// Compute the geometric factors due to different incidence angles</span>
02284 <span class="comment">        geometricEff = { AB:{axial:0.0, azimuthal:0.0},</span>
02285 <span class="comment">                         BA:{axial:0.0, azimuthal:0.0},</span>
02286 <span class="comment">                         SA:{axial:0.0, azimuthal:0.0},</span>
02287 <span class="comment">                         SB:{axial:0.0, azimuthal:0.0}   }</span>
02288 <span class="comment">        geometricEff.AB.axial = getGeometricEff(LORAxialIncidenceAngle(endptA,endptB))</span>
02289 <span class="comment">        geometricEff.BA.axial = getGeometricEff(LORAxialIncidenceAngle(endptB,endptA))</span>
02290 <span class="comment">        geometricEff.SA.axial = getGeometricEff(axialIncidenceAngle(scatpt,endptA))</span>
02291 <span class="comment">        geometricEff.SB.axial = getGeometricEff(axialIncidenceAngle(scatpt,endptB))</span>
02292 <span class="comment">        geometricEff.AB.azimuthal = getGeometricEff(LORAzimuthalIncidenceAngle(endptA,endptB))</span>
02293 <span class="comment">        geometricEff.BA.azimuthal = getGeometricEff(LORAzimuthalIncidenceAngle(endptB,endptA))</span>
02294 <span class="comment">        geometricEff.SA.azimuthal = getGeometricEff(azimuthalIncidenceAngle(scatpt,endptA))</span>
02295 <span class="comment">        geometricEff.SB.azimuthal = getGeometricEff(azimuthalIncidenceAngle(scatpt,endptB))</span>
02296 <span class="comment">        </span>
02297 <span class="comment">        detectionEffSA  = geometricEff.SA.axial * geometricEff.SA.azimuthal</span>
02298 <span class="comment">        detectionEffSA /= geometricEff.AB.axial * geometricEff.AB.azimuthal</span>
02299 <span class="comment"></span>
02300 <span class="comment">        detectionEffSB  = geometricEff.SB.axial * geometricEff.SB.azimuthal</span>
02301 <span class="comment">        detectionEffSB /= geometricEff.BA.axial * geometricEff.BA.azimuthal</span>
02302 <span class="comment">        </span>
02303 <span class="comment">        detectionEff = detectionEffSA * detectionEffSB * scatterEnergyEff</span>
02304 <span class="comment"></span>
02305 <span class="comment">//METHOD 2 - 2x faster</span>
02306 <span class="comment">// Compute the geometric factors due to different incidence angles</span>
02307 <span class="comment">        angleCosine = LORAxialIncidenceAngle(endptA,endptB)</span>
02308 <span class="comment">        geometricEff_AB_axial = p0 + p1*angleCosine + p2*angleCosine^2</span>
02309 <span class="comment">        angleCosine = LORAxialIncidenceAngle(endptB,endptA)</span>
02310 <span class="comment">        geometricEff_BA_axial = p0 + p1*angleCosine + p2*angleCosine^2</span>
02311 <span class="comment">        angleCosine = axialIncidenceAngle(scatpt,endptA)</span>
02312 <span class="comment">        geometricEff_SA_axial = p0 + p1*angleCosine + p2*angleCosine^2</span>
02313 <span class="comment">        angleCosine = axialIncidenceAngle(scatpt,endptB)</span>
02314 <span class="comment">        geometricEff_SB_axial = p0 + p1*angleCosine + p2*angleCosine^2</span>
02315 <span class="comment">        angleCosine = LORAzimuthalIncidenceAngle(endptA,endptB)</span>
02316 <span class="comment">        geometricEff_AB_azimuthal = p0 + p1*angleCosine + p2*angleCosine^2</span>
02317 <span class="comment">        angleCosine = LORAzimuthalIncidenceAngle(endptB,endptA)</span>
02318 <span class="comment">        geometricEff_BA_azimuthal = p0 + p1*angleCosine + p2*angleCosine^2</span>
02319 <span class="comment">        angleCosine = azimuthalIncidenceAngle(scatpt,endptA)</span>
02320 <span class="comment">        geometricEff_SA_azimuthal = p0 + p1*angleCosine + p2*angleCosine^2</span>
02321 <span class="comment">        angleCosine = azimuthalIncidenceAngle(scatpt,endptB)</span>
02322 <span class="comment">        geometricEff_SB_azimuthal = p0 + p1*angleCosine + p2*angleCosine^2</span>
02323 <span class="comment">        </span>
02324 <span class="comment">        detectionEffSA  = geometricEff_SA_axial * geometricEff_SA_azimuthal</span>
02325 <span class="comment">        detectionEffSA /= geometricEff_AB_axial * geometricEff_AB_azimuthal</span>
02326 <span class="comment"></span>
02327 <span class="comment">        detectionEffSB  = geometricEff_SB_axial * geometricEff_SB_azimuthal</span>
02328 <span class="comment">        detectionEffSB /= geometricEff_BA_axial * geometricEff_BA_azimuthal</span>
02329 <span class="comment">        </span>
02330 <span class="comment">        detectionEff = detectionEffSA * detectionEffSB * scatterEnergyEff</span>
02331 <span class="comment">****************************************************************/</span>
02332 
02333 <span class="comment">/*;===============================================================================</span>
02334 <span class="comment">//+</span>
02335 <span class="comment">//       NAME</span>
02336 <span class="comment">//               defineScatterPoints </span>
02337 <span class="comment">//</span>
02338 <span class="comment">//       SYNOPSIS</span>
02339 <span class="comment">//               defineScatterPoints(params, scanner, endPoint, scatterPoint, </span>
02340 <span class="comment">//                  panelIntersection, axialAngleCosine, azimuthalAngleCosine, </span>
02341 <span class="comment">//                  errMsg)</span>
02342 <span class="comment">//</span>
02343 <span class="comment">//       INPUT</span>
02344 <span class="comment">//               params - structure containing all the various parameter values</span>
02345 <span class="comment">//               samplingFactor - a multiplicative factor that allows for more</span>
02346 <span class="comment">//                  coarse spatial sampling without changing the ultimate desired</span>
02347 <span class="comment">//                  sampling (params-&gt;modelBasedScatter.scatterPointAxialStep and</span>
02348 <span class="comment">//                  params-&gt;modelBasedScatter.scatterPointAzimuthalStep)</span>
02349 <span class="comment">//</span>
02350 <span class="comment">//       OUTPUT</span>
02351 <span class="comment">//               scatterPointList - structure containing the scatter point locations </span>
02352 <span class="comment">//               errMsg - informational message for error handler</span>
02353 <span class="comment">//</span>
02354 <span class="comment">//       DESCRIPTION</span>
02355 <span class="comment">//               Compute the spatial locations (x,y,z values) for a distribution</span>
02356 <span class="comment">//               of scatter points as determined by the scatter point parameters. </span>
02357 <span class="comment">//               These scatter points are used as representative of the entire</span>
02358 <span class="comment">//               activity distribution for the purpose of scatter computation.</span>
02359 <span class="comment">//</span>
02360 <span class="comment">//       HISTORY</span>
02361 <span class="comment">//               01/01/04 - cb - original code validated</span>
02362 <span class="comment">//-</span>
02363 <span class="comment">//===============================================================================</span>
02364 <span class="comment">*/</span>
02365 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::defineScatterPoints(<span class="keywordtype">float</span> samplingFactor) {
02366 
02367         <span class="comment">// Use a fixed seed value so that positions are always the same - helps debugging</span>
02368         <span class="keyword">const</span> <span class="keywordtype">int</span> seed = 12345;
02369   
02370         <span class="keywordtype">float</span> limitX = (params-&gt;geometry.nX * params-&gt;geometry.dX + params-&gt;geometry.offsetX) / 2.0;
02371         <span class="keywordtype">float</span> limitY = (params-&gt;geometry.nY * params-&gt;geometry.dY + params-&gt;geometry.offsetY) / 2.0;
02372         <span class="keywordtype">float</span> limitZ = (params-&gt;geometry.nZ * params-&gt;geometry.dZ + params-&gt;geometry.offsetZ) / 2.0;
02373 
02374         <span class="keywordtype">float</span> stepSize = samplingFactor * params-&gt;modelBasedScatter.pointSeparation;  
02375         <span class="keywordtype">float</span> offset   = stepSize * params-&gt;modelBasedScatter.pointOffset; 
02376 
02377         <span class="keywordtype">float</span> minX = -limitX; 
02378         <span class="keywordtype">float</span> minY = -limitY; 
02379         <span class="keywordtype">float</span> minZ = -limitZ; 
02380 
02381 <span class="comment">/* st</span>
02382 <span class="comment">        float maxX =  limitX + params-&gt;modelBasedScatter.pointSeparation;</span>
02383 <span class="comment">        float maxY =  limitY + params-&gt;modelBasedScatter.pointSeparation;</span>
02384 <span class="comment">        float maxZ =  limitZ + params-&gt;modelBasedScatter.pointSeparation;</span>
02385 <span class="comment">*/</span>
02386         
02387         <span class="keywordtype">float</span> maxX =  limitX;
02388         <span class="keywordtype">float</span> maxY =  limitY;
02389         <span class="keywordtype">float</span> maxZ =  limitZ;
02390         
02391         <span class="comment">//float xpts =((maxX-minX)/stepSize)+1;</span>
02392         <span class="comment">//float ypts =((maxY-minY)/stepSize)+1;</span>
02393         <span class="comment">//float zpts =((maxZ-minZ)/stepSize)+1;</span>
02394 
02395         srand(seed);    
02396         <span class="comment">//srand(static_cast&lt;unsigned&gt;(time(0)));</span>
02397         <span class="keywordflow">for</span> (<span class="keywordtype">float</span> x=minX; x &lt;= maxX; x+=stepSize) {
02398                 <span class="keywordflow">for</span> (<span class="keywordtype">float</span> y=minY; y &lt;= maxY; y+=stepSize) {
02399                         <span class="keywordflow">for</span> (<span class="keywordtype">float</span> z=minZ; z &lt;= maxZ; z+=stepSize) {
02400                                 coordIndex s;
02401 <span class="comment">/*******</span>
02402 <span class="comment">                                s.x = (x + offset*(((float)(rand()/RAND_MAX))-0.5));</span>
02403 <span class="comment">                                s.y = (y + offset*(((float)(rand()/RAND_MAX))-0.5));</span>
02404 <span class="comment">                                s.z = (z + offset*(((float)(rand()/RAND_MAX))-0.5));</span>
02405 <span class="comment">***********/</span>
02406                                 s.x = x + offset*((<span class="keywordtype">float</span>) rand()/(RAND_MAX*1.0));
02407                                 s.y = y + offset*((<span class="keywordtype">float</span>) rand()/(RAND_MAX*1.0));
02408                                 s.z = z + offset*((<span class="keywordtype">float</span>) rand()/(RAND_MAX*1.0));
02409                                 scatterPointList-&gt;add(s);
02410 
02411                         }
02412                 }
02413         }
02414 
02415         <span class="keywordflow">return</span> <span class="keyword">true</span>;
02416 }
02417 
02445 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::defineEndPoints() {
02446 
02447         <span class="comment">/*</span>
02448 <span class="comment">        ; Compute end point locations</span>
02449 <span class="comment">        */</span>
02450         <span class="keywordtype">int</span> zLength = round((<span class="keywordtype">float</span>)(scannerParams-&gt;bankLength / 2.0));
02451 
02452         endPointList.angleStep = params-&gt;modelBasedScatter.endPointAzimuthalStep;
02453         endPointList.sliceThickness = params-&gt;modelBasedScatter.endPointAxialStep; 
02454   
02455         endPointList.nAngles = round(360.0 / endPointList.angleStep) + 1;
02456         if ((endPointList.nAngles * endPointList.angleStep) &gt; 360.0) {
02457                 endPointList.nAngles -= 1;
02458         }
02459         endPointList.nSlices = round(2.0*zLength / endPointList.sliceThickness) + 1;
02460 
02461         <a class="code" href="classArray1D.html">Array1D&lt;float&gt;</a> zcoords(endPointList.nSlices);
02462         zcoords(0) = -zLength;
02463         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> slice=1; slice &lt;= endPointList.nSlices-1; slice++) {
02464                 zcoords(slice) = zcoords(slice-1) + endPointList.sliceThickness;
02465         }
02466   
02467         <span class="comment">// Create cylinder for scatter-space with radius equal to average radius of octagon</span>
02468 
02469         endPointList.radius = scannerParams-&gt;cylinderDiameter / 2.0;
02470 
02471         endPointList.angle.<a class="code" href="classArray1D.html#a8">init</a>(endPointList.nAngles,endPointList.nSlices);
02472         endPointList.x.init(endPointList.nAngles,endPointList.nSlices);
02473         endPointList.y.init(endPointList.nAngles,endPointList.nSlices);
02474         endPointList.z.init(endPointList.nAngles,endPointList.nSlices);
02475   
02476         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> slice=0; slice &lt;= endPointList.nSlices-1; slice++) {
02477                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> step=0; step &lt;= endPointList.nAngles-1; step++) {
02478                         <span class="comment">//Constant::PI  -- introduces some error because it is different from idl code - shanta</span>
02479                         endPointList.angle(step,slice) = (endPointList.angleStep * float(step) * Constant::PI) / 180.0 ;
02480                         endPointList.x(step,slice) = endPointList.radius * cos(endPointList.angle(step,slice));
02481                         endPointList.y(step,slice) = endPointList.radius * sin(endPointList.angle(step,slice));
02482                         endPointList.z(step,slice) = zcoords(slice);
02483                 }
02484         }
02485         <span class="keywordflow">return</span> <span class="keyword">true</span>;
02486 }
02487 
02514 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::convertCoordinatesToImageIndices (coordIndex &amp;coords, imgIndex &amp;index) {
02515 
02516         <span class="keywordtype">float</span> nX = params-&gt;geometry.nX;
02517         <span class="keywordtype">float</span> nY = params-&gt;geometry.nY;
02518         <span class="keywordtype">float</span> nZ = params-&gt;geometry.nZ;
02519   
02520         <span class="keywordtype">float</span> dX = params-&gt;geometry.dX;
02521         <span class="keywordtype">float</span> dY = params-&gt;geometry.dY;
02522         <span class="keywordtype">float</span> dZ = params-&gt;geometry.dZ;
02523   
02524         <span class="keywordtype">float</span> offsetX = params-&gt;geometry.offsetX;
02525         <span class="keywordtype">float</span> offsetY = params-&gt;geometry.offsetY;
02526         <span class="keywordtype">float</span> offsetZ = params-&gt;geometry.offsetZ;
02527   
02528         <span class="keywordtype">int</span> iX = round((coords.x - dX/2.0 - offsetX + 0.5*nX*dX) / dX);
02529         <span class="keywordtype">int</span> iY = round((coords.y - dY/2.0 - offsetY + 0.5*nY*dY) / dY);
02530         <span class="keywordtype">int</span> iZ = round((coords.z - dZ/2.0 - offsetZ + 0.5*nZ*dZ) / dZ);
02531   
02532         index.x = iX;
02533         index.y = iY;
02534         index.z = iZ;
02535         
02536         <span class="keywordflow">return</span> <span class="keyword">true</span>;
02537 }
02538 
02571 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::computeRaySum(<a class="code" href="classImage.html">Image</a> &amp;emissionImage,
02572                         <a class="code" href="classImage.html">Image</a> &amp;muImage, coordIndex &amp;endPoint, coordIndex &amp;scatterPoint,
02573                         <span class="keywordtype">float</span> &amp;emissionRaySum, <span class="keywordtype">float</span> &amp;muRaySum) {
02574 
02575         <span class="keywordtype">int</span> debug = params-&gt;modelBasedScatter.verbosity;
02576         <span class="comment">// Compute ray sum for a given scatter point and end point pair and an image volume</span>
02577   
02578         muRaySum = 0.0;
02579         emissionRaySum = 0.0;
02580         <span class="keywordtype">int</span> jxmax = params-&gt;geometry.nX-1;
02581         <span class="keywordtype">int</span> jymax = params-&gt;geometry.nY-1;
02582         <span class="keywordtype">int</span> jzmax = params-&gt;geometry.nZ-1;
02583 
02584         <span class="comment">// Get the image indices corresponding to the "detector" location</span>
02585 
02586         <span class="keywordtype">float</span> xd = endPoint.x;
02587         <span class="keywordtype">float</span> yd = endPoint.y;
02588         <span class="keywordtype">float</span> zd = endPoint.z;
02589         
02590         imgIndex endPointIndex;
02591         <span class="keywordflow">if</span> (!convertCoordinatesToImageIndices(endPoint, endPointIndex)) {
02592                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
02593         }
02594         <span class="keywordtype">float</span> jxd = endPointIndex.x;
02595         <span class="keywordtype">float</span> jyd = endPointIndex.y;
02596         <span class="keywordtype">float</span> jzd = endPointIndex.z;
02597 <span class="comment">//</span>
02598 <span class="comment">//      ; Get the image indices corresponding to the scatter point location</span>
02599 <span class="comment">//</span>
02600         <span class="keywordtype">float</span> xs = scatterPoint.x;
02601         <span class="keywordtype">float</span> ys = scatterPoint.y;
02602         <span class="keywordtype">float</span> zs = scatterPoint.z;
02603         
02604         imgIndex scatterPointIndex;
02605         <span class="keywordflow">if</span> (!convertCoordinatesToImageIndices(scatterPoint, scatterPointIndex)) {
02606                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
02607         }
02608 
02609         <span class="keywordtype">int</span> jxs = scatterPointIndex.x;
02610         <span class="keywordtype">int</span> jys = scatterPointIndex.y;
02611         <span class="keywordtype">int</span> jzs = scatterPointIndex.z;
02612 <span class="comment">//</span>
02613 <span class="comment">//      ; Compute the direction cosines (l,m,n) for the ray connecting the two locations</span>
02614 <span class="comment">//</span>
02615         <span class="keywordtype">float</span> d = sqrt( POW2(xd-xs) + POW2(yd-ys) + POW2(zd-zs) );
02616         <span class="keywordtype">float</span> l = (xd - xs) / d;
02617         <span class="keywordtype">float</span> m = (yd - ys) / d;
02618         <span class="keywordtype">float</span> n = (zd - zs) / d;
02619 <span class="comment">//</span>
02620 <span class="comment">//      ; Begin the ray sum </span>
02621 <span class="comment">//</span>
02622         <span class="keywordtype">float</span> delta = params-&gt;modelBasedScatter.raySumStepSize; <span class="comment">//distance to step in ray sum</span>
02623         <span class="keywordtype">float</span> i = 0.0;
02624         <span class="keywordtype">float</span> x = xs;
02625         <span class="keywordtype">float</span> y = ys;
02626         <span class="keywordtype">float</span> z = zs;
02627         <span class="keywordtype">int</span> jx = jxs;
02628         <span class="keywordtype">int</span> jy = jys;
02629         <span class="keywordtype">int</span> jz = jzs;
02630 
02631         <span class="keywordflow">while</span> ((jx &gt;= 0.0) &amp;&amp; (jx &lt;= jxmax) &amp;&amp;
02632          (jy &gt;= 0.0) &amp;&amp; (jy &lt;= jymax) &amp;&amp;
02633          (jz &gt;= 0.0) &amp;&amp; (jz &lt;= jzmax)) {
02634                 emissionRaySum += delta * emissionImage(jx,jy,jz);
02635                 muRaySum       += delta * muImage(jx,jy,jz);
02636                 i += 1.0;
02637                 x = xs + i*l*delta;
02638                 y = ys + i*m*delta;
02639                 z = zs + i*n*delta;
02640                 coordIndex point;
02641                 point.x = x; point.y = y ; point.z = z;
02642                 <span class="comment">//if (debug &gt;= 4 then oplot,(x,x), (y,y), psym=2, color=color24("yellow"), linestyle=1</span>
02643                 <span class="comment">//if (debug &gt;= 4 then wait, 0.005</span>
02644                 imgIndex index;
02645                 <span class="keywordflow">if</span> (!convertCoordinatesToImageIndices(point, index)) {
02646                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
02647                 } 
02648                 
02649                 jx = index.x;
02650                 jy = index.y;
02651                 jz = index.z;
02652                 
02653         }
02654         <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">//??????????</span>
02655 }
02656 
02657 <span class="comment">//===============================================================================</span>
02658 <span class="comment">//+</span>
02659 <span class="comment">//       NAME</span>
02660 <span class="comment">//               getPanelHit</span>
02661 <span class="comment">//</span>
02662 <span class="comment">//       SYNOPSIS</span>
02663 <span class="comment">//               getPanelHit(params, scanner, endPoint, scatterPoint, </span>
02664 <span class="comment">//                  panelIntersection, select)</span>
02665 <span class="comment">//</span>
02666 <span class="comment">//       INPUT</span>
02667 <span class="comment">//               params - structure containing all the various parameter values</span>
02668 <span class="comment">//               scanner - structure describing the PET scanner hardware</span>
02669 <span class="comment">//               endPoint - structure containing the "detector" location </span>
02670 <span class="comment">//               scatterPoint - structure containing the scatter point location</span>
02671 <span class="comment">//</span>
02672 <span class="comment">//       OUTPUT</span>
02673 <span class="comment">//               panelIntersection - structure containing the location of the</span>
02674 <span class="comment">//                  intersection of the line connecting the endPoint and </span>
02675 <span class="comment">//                  scatterPoint and the scanner detector panel</span>
02676 <span class="comment">//               select - integer index of the scanner panel containing the </span>
02677 <span class="comment">//                  intersection point</span>
02678 <span class="comment">//               errMsg - informational message for error handler</span>
02679 <span class="comment">//</span>
02680 <span class="comment">//       DESCRIPTION</span>
02681 <span class="comment">//               Determine which panel intercepts a photon travelling from </span>
02682 <span class="comment">//               scatterPoint in the direction of endPoint. Return the panel</span>
02683 <span class="comment">//               number and the intersection location.</span>
02684 <span class="comment">//</span>
02685 <span class="comment">//       HISTORY</span>
02686 <span class="comment">//               01/01/04 - cb - original code validated</span>
02687 <span class="comment">//-</span>
02688 <span class="comment">//===============================================================================</span>
02689 <span class="comment">//</span>
02690 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::getPanelHit(coordIndex &amp;endPoint, coordIndex &amp;scatterPoint, coordIndex &amp;panelIntersection, <span class="keywordtype">int</span> &amp;select) {
02691 
02692 <span class="comment">//      ;print, "getPanelHit - setup: ", clock()-time0, " sec" ; for debugging</span>
02693 <span class="comment">//      ;time0 = clock()                                       ; for debugging</span>
02694 
02695         coordIndex rotatedEndPoint;
02696         coordIndex rotatedScatterPoint;
02697         coordIndex matchList[8];
02698 
02699         rotatedEndPoint.x     = endPoint.x * cos(Constant::PI/4.0)     + endPoint.y * sin(Constant::PI/4.0);
02700         rotatedEndPoint.y     = endPoint.y * cos(Constant::PI/4.0)     - endPoint.x * sin(Constant::PI/4.0);
02701         rotatedEndPoint.z     = endPoint.z ;
02702         rotatedScatterPoint.x = scatterPoint.x * cos(Constant::PI/4.0) + scatterPoint.y * sin(Constant::PI/4.0);
02703         rotatedScatterPoint.y = scatterPoint.y * cos(Constant::PI/4.0) - scatterPoint.x * sin(Constant::PI/4.0);
02704         rotatedScatterPoint.z = scatterPoint.z; 
02705   
02706         <a class="code" href="classArray1D.html">Array1D&lt;int&gt;</a> intersectionFound(8);
02707         coordIndex intersection;
02708         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt;= 7; i+=2) { 
02709 <span class="comment">//      ;</span>
02710 <span class="comment">//              ; Test for vertical and horizontal panels (0,2,4,6)</span>
02711 <span class="comment">//      ;</span>
02712                 <span class="keywordflow">if</span> (getPlaneIntersection(scanner.bank[i],scatterPoint,endPoint,intersection)) {
02713                         cout &lt;&lt; <span class="stringliteral">"Intersection for bank:"</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" is i.x:"</span>&lt;&lt;intersection.x&lt;&lt;<span class="stringliteral">" i.y:"</span>&lt;&lt;intersection.y&lt;&lt;<span class="stringliteral">" i.z:"</span>&lt;&lt;intersection.z&lt;&lt;<span class="stringliteral">"\n"</span>;
02714                         intersectionFound(i) = (                                              
02715                         round(10*intersection.x) &gt;= round(10*((scanner.bank[i].x).min())) &amp;&amp;
02716                         round(10*intersection.x) &lt;= round(10*((scanner.bank[i].x).max())) &amp;&amp;
02717                         round(10*intersection.y) &gt;= round(10*((scanner.bank[i].y).min())) &amp;&amp; 
02718                         round(10*intersection.y) &lt;= round(10*((scanner.bank[i].y).max())) ) ? 1 : 0;
02719                         matchList[i] = (intersectionFound(i) == 1) ? intersection : matchList[i];
02720                 }
02721 <span class="comment">//</span>
02722 <span class="comment">//              ; Test for angled panels (1,3,5,7)</span>
02723 <span class="comment">//</span>
02724 <span class="comment">//Changing the scanner.bank from [i] tp [i+1] - shanta</span>
02725                 <span class="keywordflow">if</span> (getPlaneIntersection(scanner.bank[i+1],rotatedScatterPoint,rotatedEndPoint,intersection)) {
02726                         cout &lt;&lt; <span class="stringliteral">"Intersection for bank:"</span>&lt;&lt;i+1&lt;&lt;<span class="stringliteral">" is i.x:"</span>&lt;&lt;intersection.<a class="code" href="classArray1D.html#r1">x</a>&lt;&lt;<span class="stringliteral">" i.y:"</span>&lt;&lt;intersection.y&lt;&lt;<span class="stringliteral">" i.z:"</span>&lt;&lt;intersection.z&lt;&lt;<span class="stringliteral">"\n"</span>;
02727                         intersectionFound(i+1) = (                                            
02728                           round(10*intersection.x) &gt;= round(10*(scanner.bank[i+1].x).min()) &amp;&amp;
02729                           round(10*intersection.x) &lt;= round(10*(scanner.bank[i+1].x).max()) &amp;&amp;
02730                           round(10*intersection.y) &gt;= round(10*(scanner.bank[i+1].y).min()) &amp;&amp; 
02731                           round(10*intersection.y) &lt;= round(10*(scanner.bank[i+1].y).max()) ) ? 1 : 0;
02732                         matchList[i+1].<a class="code" href="classArray1D.html#r1">x</a> = (intersectionFound(i+1) == 1) ?
02733                           intersection.x * cos(-Constant::PI/4.0) + intersection.y * sin(-Constant::PI/4.0) : matchList[i+1].x;
02734                         matchList[i+1].y = (intersectionFound(i+1) == 1) ?
02735                           intersection.y * cos(-Constant::PI/4.0) - intersection.x * sin(-Constant::PI/4.0) : matchList[i+1].y;
02736                         matchList[i+1].z = (intersectionFound(i+1) == 1) ?
02737                         intersection.z : matchList[i+1].z;
02738                 }
02739         }
02740 
02741 <span class="comment">//print, "detectionEff - intersection found: ", clock()-time0, " sec" ; for debugging</span>
02742 <span class="comment">//time0 = clock()                                                     ; for debugging</span>
02743   
02744         <a class="code" href="classArray1D.html">Array1D&lt;int&gt;</a> match;
02745         where(intersectionFound,1, match);
02746         <span class="keywordflow">if</span> (match(0) == -1) {
02747                 cout&lt;&lt;<span class="stringliteral">"No intersection found: \n"</span>;
02748                 cout.flush();
02749                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
02750 
02751 <span class="comment">//iplot, (scatterpoint.x,endpoint.x), (scatterpoint.y,endpoint.y), (scatterpoint.z,endpoint.z), color=color24("red"), overplot=1</span>
02752 <span class="comment">//oplot, (scatterpoint.x,endPoint.x), (scatterpoint.y,endPoint.y), color=color24("yellow")</span>
02753         }
02754         select = match(0);
02755         <span class="keywordflow">if</span> (match(1) &gt;= 0) {
02756                 <span class="keywordtype">float</span> distance0 = (endPoint.x - POW2(matchList[match(0)].x)) +
02757                 POW2(endPoint.y - matchList[match(0)].y) + POW2(endPoint.z - matchList[match(0)].z);
02758                 <span class="keywordtype">float</span> distance1 = POW2(endPoint.x - matchList[match(1)].x) +
02759                 POW2(endPoint.y - matchList[match(1)].y) + POW2(endPoint.z - matchList[match(1)].z);
02760                 <span class="keywordflow">if</span> (distance0 &gt;= distance1) select = match(1);
02761         }
02762         panelIntersection = matchList[select];
02763 
02764 <span class="comment">//      ;print, "getPanelHit - done: ", clock()-time0, " sec"                ; for debugging</span>
02765         <span class="keywordflow">return</span> <span class="keyword">true</span>;
02766 }
02767 
02768 <span class="comment">//===============================================================================</span>
02769 <span class="comment">//+</span>
02770 <span class="comment">//       NAME</span>
02771 <span class="comment">//               getPlaneIntersection </span>
02772 <span class="comment">//</span>
02773 <span class="comment">//       SYNOPSIS</span>
02774 <span class="comment">//               getPlaneIntersection(plane, ray, intersection)</span>
02775 <span class="comment">//</span>
02776 <span class="comment">//       INPUT</span>
02777 <span class="comment">//               plane - structure containing 3 co-planar point locations</span>
02778 <span class="comment">//               ray - structure with 2 point locations that define the ray</span>
02779 <span class="comment">//</span>
02780 <span class="comment">//       OUTPUT</span>
02781 <span class="comment">//               intersection - structure containing the intersection location </span>
02782 <span class="comment">//               errMsg - informational message for error handler</span>
02783 <span class="comment">//</span>
02784 <span class="comment">//       DESCRIPTION</span>
02785 <span class="comment">//               Compute the location of the intersection of a ray and a plane.</span>
02786 <span class="comment">//</span>
02787 <span class="comment">//       HISTORY</span>
02788 <span class="comment">//               01/01/04 - cb - original code validated</span>
02789 <span class="comment">//-</span>
02790 <span class="comment">//===============================================================================</span>
02791 <span class="comment">//</span>
02792   <span class="keywordtype">bool</span> ModelBasedScatterCorrection::getPlaneIntersection( Bank &amp;plane, coordIndex &amp;ray0, coordIndex &amp;ray1, coordIndex &amp;intersection) {  <span class="comment">// COMPLETE (NEEDS OPTIMIZING FOR SPEED)</span>
02793 
02794 <span class="comment">//time0 = clock()                       ; for debugging</span>
02795         <span class="keywordtype">float</span> x1 = plane.x(0);
02796         <span class="keywordtype">float</span> y1 = plane.y(0);
02797         <span class="keywordtype">float</span> z1 = plane.z(0);
02798 
02799         <span class="keywordtype">float</span> x2 = plane.x(1);
02800         <span class="keywordtype">float</span> y2 = plane.y(1);
02801         <span class="keywordtype">float</span> z2 = plane.z(1);
02802 
02803         <span class="keywordtype">float</span> x3 = plane.x(2);
02804         <span class="keywordtype">float</span> y3 = plane.y(2);
02805         <span class="keywordtype">float</span> z3 = plane.z(2);
02806 
02807         <span class="keywordtype">float</span> x4 = ray0.x;
02808         <span class="keywordtype">float</span> y4 = ray0.y;
02809         <span class="keywordtype">float</span> z4 = ray0.z;
02810 
02811         <span class="keywordtype">float</span> x5 = ray1.x;
02812         <span class="keywordtype">float</span> y5 = ray1.y;
02813         <span class="keywordtype">float</span> z5 = ray1.z;
02814 
02815 <span class="comment">//;print, "check x1-5"</span>
02816 <span class="comment">//;stop</span>
02817 <span class="comment">//;print, "getIntersection - setup: ", clock()-time0, " sec"          ;;; for debugging</span>
02818 <span class="comment">//;time0 = clock()                                                 ;;; for debugging</span>
02819         <span class="keywordtype">float</span> arr[4][4] = {1., 1., 1., 1.,
02820                            x1, x2, x3, x4,
02821                            y1, y2, y3, y4,
02822                            z1, z2, z3, z4};
02823         Array2D&lt;float&gt; a2d(4,4);
02824         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;4;i++)
02825                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j &lt; 4;j++)
02826                         a2d(i,j) = arr[j][i];
02827         <span class="keywordtype">float</span> numerator   = determ(a2d,4);
02828         
02829 <span class="comment">//;print, "getIntersection - numerator: ", clock()-time0, " sec"          ;;; for debugging</span>
02830 <span class="comment">//;time0 = clock()                                                 ;;; for debugging</span>
02831         <span class="keywordtype">float</span> arr1[4][4] ={ 1., 1., 1., 0.,
02832                            x1, x2, x3, x5-x4,
02833                            y1, y2, y3, y5-y4,
02834                            z1, z2, z3, z5-z4};
02835         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;4;i++)
02836                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j &lt; 4;j++)
02837                         a2d(i,j) = arr1[j][i];
02838         <span class="keywordtype">float</span> denominator   = determ(a2d,4);
02839 <span class="comment">//print, "getIntersection - denominator: ", clock()-time0, " sec"         // ;;; for debugging</span>
02840 <span class="comment">//time0 = clock();                                               // ;;; for debugging</span>
02841 <span class="comment">//;  if (denominator == 0.0)) {</span>
02842 <span class="comment">//;    errMsg = "getIntersection: denominator = 0"</span>
02843 <span class="comment">//;    return, 1</span>
02844 <span class="comment">//;  }</span>
02845         <span class="keywordflow">if</span> ((denominator == 0.0)) {
02846                 cout&lt;&lt;<span class="stringliteral">"getIntersection: denominator = 0. No intersection.\n"</span>;
02847                 cout.flush();
02848                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
02849         }
02850         <span class="keywordtype">float</span> t = numerator / denominator;
02851         intersection.x = x4 + (x4-x5)*t;
02852         intersection.y = y4 + (y4-y5)*t;
02853         intersection.z = z4 + (z4-z5)*t;
02854 
02855         <span class="keywordflow">return</span> <span class="keyword">true</span>;
02856 }
02857         
02858 
02859 <span class="comment">//===============================================================================</span>
02860 <span class="comment">//+</span>
02861 <span class="comment">//       NAME</span>
02862 <span class="comment">//               getIncidenceAngles </span>
02863 <span class="comment">//</span>
02864 <span class="comment">//       SYNOPSIS</span>
02865 <span class="comment">//               getIncidenceAngles(params, scanner, sourcePoint, </span>
02866 <span class="comment">//                  panelIntersection, select, axialAngleCosine, </span>
02867 <span class="comment">//                  azimuthalAngleCosine, endPoint)</span>
02868 <span class="comment">//</span>
02869 <span class="comment">//       INPUT</span>
02870 <span class="comment">//               params - structure containing all the various parameter values</span>
02871 <span class="comment">//               scanner - structure describing the PET scanner hardware</span>
02872 <span class="comment">//               sourcePoint - structure containing the source point location</span>
02873 <span class="comment">//               panelIntersection - structure containing the location of the</span>
02874 <span class="comment">//                  intersection of the line connecting the endPoint and </span>
02875 <span class="comment">//                  sourcePoint and the scanner detector panel</span>
02876 <span class="comment">//               select - integer index of the scanner panel containing the </span>
02877 <span class="comment">//                  intersection point</span>
02878 <span class="comment">//</span>
02879 <span class="comment">//       OUTPUT</span>
02880 <span class="comment">//               axialAngleCosine - cosine of the axial incidence angle </span>
02881 <span class="comment">//               azimuthalAngleCosine - cosine of the azimuthal angle </span>
02882 <span class="comment">//               errMsg - informational message for error handler</span>
02883 <span class="comment">//</span>
02884 <span class="comment">//       DESCRIPTION</span>
02885 <span class="comment">//               Compute the axial and azimuthal incidence angles for a ray </span>
02886 <span class="comment">//               intersecting a panel from a direction determined by the </span>
02887 <span class="comment">//               endPoint and sourcePoint.</span>
02888 <span class="comment">//</span>
02889 <span class="comment">//       HISTORY</span>
02890 <span class="comment">//               01/01/04 - cb - original code </span>
02891 <span class="comment">//-</span>
02892 <span class="comment">//===============================================================================</span>
02893 <span class="comment">//</span>
02894   <span class="keywordtype">bool</span> ModelBasedScatterCorrection::getIncidenceAngles(coordIndex &amp;sourcePoint, coordIndex &amp;panelIntersection,
02895            <span class="keywordtype">int</span> select, <span class="keywordtype">float</span> &amp;axialAngleCosine, <span class="keywordtype">float</span> &amp;azimuthalAngleCosine, coordIndex &amp;endPoint) {
02896 
02897         coordIndex A;
02898         coordIndex B;
02899         coordIndex P;
02900 <span class="comment">//</span>
02901 <span class="comment">// Remove motion correction to get the orientation of the original LOR wrt panel</span>
02902 <span class="comment">//</span>
02903 <span class="comment">// HOW DO WE APPLY THE INVERSE TRANSFORM TO Q, R, and S???</span>
02904         BankVector u = scanner.bank[select].q;
02905         BankVector v = scanner.bank[select].r;
02906         BankVector w = scanner.bank[select].s;
02907 
02908         P.x = sourcePoint.x - panelIntersection.x;
02909         P.y = sourcePoint.y - panelIntersection.y;
02910         P.z = sourcePoint.z - panelIntersection.z;
02911   
02912         <span class="keywordtype">float</span> P_dot_v = (v.x * P.x) + (v.y * P.y) + (v.z * P.z);
02913         A.x = P.x - P_dot_v * v.x;
02914         A.y = P.y - P_dot_v * v.y;
02915         A.z = P.z - P_dot_v * v.z;
02916 
02917         <span class="keywordtype">float</span> P_dot_u = (u.x * P.x) + (u.y * P.y) + (u.z * P.z);
02918         B.x = P.x - P_dot_u * u.x;
02919         B.y = P.y - P_dot_u * u.y;
02920         B.z = P.z - P_dot_u * u.z;
02921 
02922         <span class="keywordtype">float</span> normA = sqrt( POW2(A.x) + POW2(A.y) + POW2(A.z) );
02923         axialAngleCosine = ( (w.x * A.x) + (w.y * A.y) + (w.z * A.z) ) / normA;
02924 
02925         <span class="keywordtype">float</span> normB = sqrt( POW2(B.x) + POW2(B.y) + POW2(B.z) );
02926         azimuthalAngleCosine = ( (w.x * B.x) + (w.y * B.y) + (w.z * B.z) ) / normB;
02927 
02928         <span class="keywordtype">float</span> x0 = panelIntersection.x;
02929         <span class="keywordtype">float</span> y0 = panelIntersection.y;
02930         <span class="comment">/*</span>
02931 <span class="comment">//  oplot, (x0,100.0*w.x+x0), (y0,100.0*w.y+y0), color=color24("blue")</span>
02932 <span class="comment">        if (1 == 2) {</span>
02933 <span class="comment">    oplot, (x0,100.0*u.x+x0), (y0,100.0*u.y+y0), color=color24("red")</span>
02934 <span class="comment">    oplot, (x0,100.0*v.x+x0), (y0,100.0*v.y+y0), color=color24("green")</span>
02935 <span class="comment">    stop</span>
02936 <span class="comment">    oplot, (x0,100.0*u.x+x0), (y0,100.0*u.y+y0), color=color24("orange")</span>
02937 <span class="comment">    oplot, (x0,100.0*v.x+x0), (y0,100.0*v.y+y0), color=color24("orange")</span>
02938 <span class="comment">    oplot, (x0,100.0*w.x+x0), (y0,100.0*w.y+y0), color=color24("yellow")</span>
02939 <span class="comment">    oplot, (x0,P.x+x0),       (y0,P.y+y0), color=color24("white")</span>
02940 <span class="comment">    oplot, (x0,A.x+x0),       (y0,A.y+y0), color=color24("red")</span>
02941 <span class="comment">    oplot, (x0,B.x+x0),       (y0,B.y+y0), color=color24("green")</span>
02942 <span class="comment">    stop</span>
02943 <span class="comment">    */</span>
02944         <span class="keywordflow">return</span> <span class="keyword">true</span>;
02945   }
02946  
02947 
02948 <span class="comment">//===============================================================================</span>
02949 <span class="comment">//+</span>
02950 <span class="comment">//       NAME</span>
02951 <span class="comment">//               getCylinderIntersection </span>
02952 <span class="comment">//</span>
02953 <span class="comment">//       SYNOPSIS</span>
02954 <span class="comment">//               getCylinderIntersection(radius, endPointA, endPointB, </span>
02955 <span class="comment">//               intersection)</span>
02956 <span class="comment">//</span>
02957 <span class="comment">//       INPUT</span>
02958 <span class="comment">//               radius - radius of circle (assumed to be centered at (0,0))</span>
02959 <span class="comment">//               endPointA - structure containing the location of end point A</span>
02960 <span class="comment">//               endPointB - structure containing the location of end point B</span>
02961 <span class="comment">//</span>
02962 <span class="comment">//       OUTPUT</span>
02963 <span class="comment">//               intersection - structure containing location of intersections</span>
02964 <span class="comment">//               errMsg - informational message for error handler</span>
02965 <span class="comment">//</span>
02966 <span class="comment">//       DESCRIPTION</span>
02967 <span class="comment">//               Determine whether a line defined by two end points intersects</span>
02968 <span class="comment">//               a circle located at the origin. Return a flag indicating whether</span>
02969 <span class="comment">//               an intersection exists. If it does, return locations.</span>
02970 <span class="comment">//</span>
02971 <span class="comment">//       HISTORY</span>
02972 <span class="comment">//               01/01/04 - cb - original code validated</span>
02973 <span class="comment">//-</span>
02974 <span class="comment">//===============================================================================</span>
02975 <span class="comment">//</span>
02976   <span class="keywordtype">bool</span> ModelBasedScatterCorrection::getCylinderIntersection( <span class="keywordtype">float</span> radius, coordIndex &amp;endPointA, 
02977                 coordIndex &amp;endPointB, coordIntersectionIndex &amp;intersection) { 
02978 
02979         <span class="keywordtype">float</span> x1 = endPointA.x;
02980         <span class="keywordtype">float</span> y1 = endPointA.y;
02981         <span class="keywordtype">float</span> z1 = endPointA.z;
02982 
02983         <span class="keywordtype">float</span> x2 = endPointB.x;
02984         <span class="keywordtype">float</span> y2 = endPointB.y;
02985         <span class="keywordtype">float</span> z2 = endPointB.z;
02986         
02987 
02988 <span class="comment">//      ; solution for circle-line intersection from mathworld.wolfram.com</span>
02989 
02990         <span class="keywordtype">float</span> dx = x2 - x1;
02991         <span class="keywordtype">float</span> dy = y2 - y1;
02992         <span class="keywordtype">float</span> dr2 = POW2(dx) + POW2(dy);
02993         <span class="comment">// 2006-02-24 - RC version</span>
02994         <span class="comment">// Parameterized equation for a line at t=0, at (x1,y1,z1), at t=1 at (x2,y2,z2)</span>
02995         <span class="comment">// x=x1 + (x2-x1)t = x1 + dx t</span>
02996         <span class="comment">// y=y1 + (y2-y1)t = y1 + dy t</span>
02997         <span class="comment">// z=z1 + (z2-z1)t</span>
02998         <span class="comment">// Solve for t values that intersect a circle of radius radius, i.e.,</span>
02999         <span class="comment">//plug first 2 equationsinto x^2+y^2=r^2. Solve for t</span>
03000         <span class="comment">// t^2(dx^2+dy^2) + 2*(x1*dx+y1*dy) + (x1^2+y1^2-r^2)=0</span>
03001         <span class="comment">/*</span>
03002 <span class="comment">        float det1=POW2(x1*dx+y1*dy)-(POW2(x1)+POW2(y1)-POW2(radius))*dr2;</span>
03003 <span class="comment">        if (det1 &lt; 0.0) {</span>
03004 <span class="comment">                float det = x1*y2 - x2*y1;</span>
03005 <span class="comment">                if (POW2(det) &lt;= dr2*POW2(radius)) {</span>
03006 <span class="comment">                  cout&lt;&lt;"CB says in, RC says out ("&lt;&lt;x1&lt;&lt;","&lt;&lt;y1&lt;&lt;","&lt;&lt;z1&lt;&lt;"),("&lt;&lt;</span>
03007 <span class="comment">                   x2&lt;&lt;","&lt;&lt;y2&lt;&lt;","&lt;&lt;z2&lt;&lt;")"&lt;&lt;endl;</span>
03008 <span class="comment">                }</span>
03009 <span class="comment">                return false;  // no intersection</span>
03010 <span class="comment">        }</span>
03011 <span class="comment">        // More RC code</span>
03012 <span class="comment">        float t1=(-(x1*dx+y1*dy)-sqrt(det1))/dr2;</span>
03013 <span class="comment">        float t2=(-(x1*dx+y1*dy)+sqrt(det1))/dr2;</span>
03014 <span class="comment">        float Nxi1 = x1 + t1 * (x2-x1);</span>
03015 <span class="comment">        float Nyi1 = y1 + t1 * (y2-y1);</span>
03016 <span class="comment">        float Nzi1 = z1 + t1 * (z2-z1);</span>
03017 <span class="comment">        float Nxi2 = x1 + t2 * (x2-x1);</span>
03018 <span class="comment">        float Nyi2 = y1 + t2 * (y2-y1);</span>
03019 <span class="comment">        float Nzi2 = z1 + t2 * (z2-z1);</span>
03020 <span class="comment">        //</span>
03021 <span class="comment">        */</span>
03022         <span class="keywordtype">float</span> det = x1*y2 - x2*y1;
03023 
03024 <span class="comment">//      ; determine if intersection exists - this does not check in z-direction - shanta</span>
03025 
03026         <span class="keywordflow">if</span> (POW2(det) &gt; dr2*POW2(radius)) {
03027                 <span class="comment">/*</span>
03028 <span class="comment">                cout&lt;&lt;"RC says in, CB says out ("&lt;&lt;x1&lt;&lt;","&lt;&lt;y1&lt;&lt;","&lt;&lt;z1&lt;&lt;"),("&lt;&lt;</span>
03029 <span class="comment">                 x2&lt;&lt;","&lt;&lt;y2&lt;&lt;","&lt;&lt;z2&lt;&lt;")";</span>
03030 <span class="comment">                */</span>
03031                 <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// no intersection</span>
03032         }
03033 
03034         <span class="comment">//checking to see y2-y1 = 0 . If 0 sign_dy becomes nan value - shanta</span>
03035         <span class="keywordtype">float</span> sign_dy = 1;
03036         <span class="keywordflow">if</span>((y2-y1) != 0) sign_dy = (y2-y1) / fabs(y2-y1);
03037 
03038         <span class="keywordtype">float</span> xi1 = ( det*dy + sign_dy*dx*sqrt(POW2(radius) * dr2 - POW2(det))) / dr2;
03039         <span class="keywordtype">float</span> yi1 = (-det*dx +  fabs(dy) * sqrt(POW2(radius) * dr2 - POW2(det))) / dr2;
03040 
03041         <span class="keywordtype">float</span> xi2 = ( det*dy - sign_dy*dx*sqrt(POW2(radius)* dr2 - POW2(det))) / dr2;
03042         <span class="keywordtype">float</span> yi2 = (-det*dx -  fabs(dy) * sqrt(POW2(radius) * dr2 - POW2(det))) / dr2;
03043 
03044 <span class="comment">//      ; given line-circle intersections, z is gotten from equation for line in 3D</span>
03045         <span class="keywordtype">float</span> zi1 = 0,zi2 = 0;
03046         <span class="comment">//if(x1 != x2) {</span>
03047         <span class="keywordflow">if</span>(abs(x1-x2) &gt; abs(y1-y2) ) {
03048                 zi1 = ((z2-z1)*(xi1-x1)/(x2-x1)) + z1;
03049                 zi2 = ((z2-z1)*(xi2-x1)/(x2-x1)) + z1;
03050         } <span class="keywordflow">else</span> {
03051                 zi1 = ((z2-z1)*(yi1-y1)/(y2-y1)) + z1;
03052                 zi2 = ((z2-z1)*(yi2-y1)/(y2-y1)) + z1;
03053         }
03054         <span class="comment">/*</span>
03055 <span class="comment">        // ERROR CHECKS - could swap which goes where</span>
03056 <span class="comment">        if ( (min(abs(Nxi1-xi1),abs(Nxi1-xi2)) &gt; 0.1)||</span>
03057 <span class="comment">             (min(abs(Nxi2-xi1),abs(Nxi2-xi2)) &gt; 0.1)||</span>
03058 <span class="comment">             (min(abs(Nyi1-yi1),abs(Nyi1-yi2)) &gt; 0.1)||</span>
03059 <span class="comment">             (min(abs(Nyi2-yi1),abs(Nyi2-yi2)) &gt; 0.1)||</span>
03060 <span class="comment">             (min(abs(Nzi1-zi1),abs(Nzi1-zi2)) &gt; 0.1)||</span>
03061 <span class="comment">             (min(abs(Nzi2-zi1),abs(Nzi2-zi2)) &gt; 0.1) )  {</span>
03062 <span class="comment">         cout&lt;&lt;"diff intersects  for ("&lt;&lt;x1&lt;&lt;","&lt;&lt;y1&lt;&lt;","&lt;&lt;z1&lt;&lt;</span>
03063 <span class="comment">                "),RC:("&lt;&lt;Nxi1&lt;&lt;","&lt;&lt;Nyi1&lt;&lt;","&lt;&lt;Nzi1&lt;&lt;"),CB:("&lt;&lt;xi1&lt;&lt;","&lt;&lt;yi1&lt;&lt;","&lt;&lt;zi1&lt;&lt;")"&lt;&lt;endl;</span>
03064 <span class="comment">         cout&lt;&lt;"diff intersects  for ("&lt;&lt;x2&lt;&lt;","&lt;&lt;y2&lt;&lt;","&lt;&lt;z2&lt;&lt;</span>
03065 <span class="comment">                "),RC:("&lt;&lt;Nxi2&lt;&lt;","&lt;&lt;Nyi2&lt;&lt;","&lt;&lt;Nzi2&lt;&lt;"),CB:("&lt;&lt;xi2&lt;&lt;","&lt;&lt;yi2&lt;&lt;","&lt;&lt;zi2&lt;&lt;")"&lt;&lt;endl;</span>
03066 <span class="comment">         cout&lt;&lt;endl;</span>
03067 <span class="comment">        }</span>
03068 <span class="comment">        */</span>
03069                  
03070         <span class="keywordtype">float</span> angle1 = atan2(yi1,xi1) * 180.0 / Constant::PI;
03071         <span class="keywordtype">float</span> angle2 = atan2(yi2,xi2) * 180.0 / Constant::PI;
03072 
03073         <span class="keywordflow">if</span> (angle1 &lt; 0.0) angle1 += 360.0;
03074         <span class="keywordflow">if</span> (angle2 &lt; 0.0) angle2 += 360.0;
03075 
03076 
03077         intersection.x[0] = xi1; intersection.x[1] = xi2;
03078         intersection.y[0] = yi1; intersection.y[1] = yi2;
03079         intersection.z[0] = zi1; intersection.z[1] = zi2;
03080         intersection.angle[0] = angle1; intersection.angle[1] = angle2; 
03081 
03082         <span class="keywordflow">return</span> <span class="keyword">true</span>;
03083 }
03084 
03085 <span class="keywordtype">int</span> ModelBasedScatterCorrection::maxOfNum(<span class="keywordtype">int</span> num1, <span class="keywordtype">int</span> num2) {
03086         <span class="keywordflow">return</span> (num2 &gt; num1?num2:num1);
03087 }
03088 
03089 <span class="keywordtype">int</span> ModelBasedScatterCorrection::minOfNum(<span class="keywordtype">int</span> num1, <span class="keywordtype">int</span> num2) {
03090         <span class="keywordflow">return</span> (num2 &lt; num1?num2:num1);
03091 }
03092 
03093 <span class="keywordtype">float</span> ModelBasedScatterCorrection::meanPartial(<a class="code" href="classImage.html">Image</a> &amp;arr, <span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> x2, <span class="keywordtype">int</span> y1, <span class="keywordtype">int</span> y2, <span class="keywordtype">int</span> z1, <span class="keywordtype">int</span> z2) {
03094         <span class="keywordtype">int</span> count=0;
03095         <span class="keywordtype">float</span> sum=0.0;
03096 
03097         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=x1; i &lt;= x2; i++) {
03098                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=y1; j &lt;= y2 ; j++) {
03099                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=z1; k &lt;= z2 ; k++) {
03100                                 sum += arr(i,j,k);
03101                                 ++count;
03102                         }
03103                 }
03104         }
03105         <span class="keywordflow">return</span> (sum / (count * 1.0));
03106 }
03107 
03108 <span class="keywordtype">float</span> ModelBasedScatterCorrection::determ(Array2D&lt;float&gt; &amp;a, <span class="keywordtype">int</span> dim) {
03109         Array2D&lt;float&gt; tmp(a);
03110         
03111         <span class="keywordtype">float</span> det = 1.0;
03112 
03113         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0 ; i &lt; dim-1 ; i++) {
03114                 <span class="keywordflow">if</span>(tmp(i,i) == 0) {
03115                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=i+1; j &lt; dim; j++) {
03116                                 <span class="keywordflow">if</span>(tmp(j,i) != 0) {
03117                                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0 ; k &lt; dim ; k++) {
03118                                                 <span class="keywordtype">float</span> temp = tmp(i,k);
03119                                                 tmp(i,k) = tmp(j,k);
03120                                                 tmp(j,k) = temp;
03121                                         }
03122                                         det = -det;
03123                                         <span class="keywordflow">break</span>;
03124                                 }
03125                         }
03126                 }
03127                 <span class="keywordflow">if</span>(tmp(i,i) == 0) {
03128                         <span class="keywordflow">return</span> 0.0;
03129                 }
03130                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j= i+1; j &lt; dim ;j++) {
03131                         <span class="keywordflow">if</span>(tmp(j,i) != 0) {
03132                                 <span class="keywordtype">float</span> factor = (tmp(j,i) *1.0) / tmp(i,i);
03133                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=i ; k &lt; dim ; k++) {
03134                                         tmp(j,k) -= factor*tmp(i,k);
03135                                 }
03136                         }
03137                 }
03138         }
03139         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0 ; i &lt; dim ; i++) {
03140                 det *= tmp(i,i);
03141         }
03142         <span class="keywordflow">return</span> det;
03143 }       
03144 
03145 <span class="keywordtype">int</span> ModelBasedScatterCorrection::round(<span class="keywordtype">float</span> num) {
03146 
03147         <span class="keywordflow">return</span> ((num - floor(num)) &gt;= 0.5)?ceil(num):floor(num);
03148 }                               
03149 
03150 <span class="comment">//Similar to IDL where method</span>
03151 <span class="keywordtype">bool</span> ModelBasedScatterCorrection::where(<a class="code" href="classArray1D.html">Array1D&lt;int&gt;</a> &amp;arr, <span class="keywordtype">int</span> element, <a class="code" href="classArray1D.html">Array1D&lt;int&gt;</a> &amp;matches) {
03152         matches.<a class="code" href="classArray1D.html#a8">init</a>(arr.<a class="code" href="classArray1D.html#o0">dim1</a>);
03153         matches = -1;
03154         <span class="keywordtype">int</span> j=0;
03155         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0 ; i&lt; arr.<a class="code" href="classArray1D.html#o0">dim1</a> ; i++) {
03156                 <span class="keywordflow">if</span>(arr(i) == element) {
03157                         matches(j) = i;
03158                         j++;
03159                 }
03160                 
03161         }
03162         <span class="keywordflow">return</span> <span class="keyword">true</span>;
03163 }       
03164 
03165 
03166 <span class="keywordtype">void</span> ModelBasedScatterCorrection::validateEndPoints() {
03167         cout &lt;&lt; <span class="stringliteral">"Endpoints.angleStep:"</span>&lt;&lt;endPointList.angleStep&lt;&lt;<span class="stringliteral">"\n"</span>;
03168         cout &lt;&lt; <span class="stringliteral">"Endpoints.sliceThickness:"</span>&lt;&lt;endPointList.sliceThickness&lt;&lt;<span class="stringliteral">"\n"</span>;
03169         cout &lt;&lt; <span class="stringliteral">"Endpoints.radius:"</span>&lt;&lt;endPointList.radius&lt;&lt;<span class="stringliteral">"\n"</span>;
03170         cout &lt;&lt; <span class="stringliteral">"Endpoints.nAngles:"</span>&lt;&lt;endPointList.nAngles&lt;&lt;<span class="stringliteral">"\n"</span>;
03171         cout &lt;&lt; <span class="stringliteral">"Endpoints.nSlices:"</span>&lt;&lt;endPointList.nSlices&lt;&lt;<span class="stringliteral">"\n"</span>;
03172         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0 ; i &lt; endPointList.nAngles; i++) {
03173           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0 ; j &lt; endPointList.nSlices; j++) {
03174                 cout &lt;&lt; <span class="stringliteral">"Endpoints.angle("</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">"):"</span>&lt;&lt;endPointList.angle(i,j)&lt;&lt;<span class="stringliteral">"\t\t"</span>;
03175                 cout &lt;&lt; <span class="stringliteral">"Endpoints.x("</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">"):"</span>&lt;&lt;endPointList.<a class="code" href="classArray1D.html#r1">x</a>(i,j)&lt;&lt;<span class="stringliteral">"\t\t"</span>;
03176                 cout &lt;&lt; <span class="stringliteral">"Endpoints.y("</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">"):"</span>&lt;&lt;endPointList.y(i,j)&lt;&lt;<span class="stringliteral">"\t\t"</span>;
03177                 cout &lt;&lt; <span class="stringliteral">"Endpoints.z("</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">","</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">"):"</span>&lt;&lt;endPointList.z(i,j)&lt;&lt;<span class="stringliteral">"\n"</span>;
03178           }
03179         }
03180 }
03181 <span class="keywordtype">void</span> ModelBasedScatterCorrection::validateScatterPoints() {
03182         coordIndex curScatterPoint;
03183         <span class="keywordtype">bool</span> valid = scatterPointList-&gt;getFirst(curScatterPoint);
03184         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> scatpt = 0;
03185         scatpt &lt; scatterPointList-&gt;count &amp;&amp; valid; scatpt++) {
03186                 cout &lt;&lt; <span class="stringliteral">"ScatterPoint["</span>&lt;&lt;scatpt&lt;&lt;<span class="stringliteral">"] = x:"</span>&lt;&lt;curScatterPoint.x&lt;&lt;<span class="stringliteral">" y:"</span>&lt;&lt;curScatterPoint.y
03187                 &lt;&lt;<span class="stringliteral">" z:"</span>&lt;&lt;curScatterPoint.z&lt;&lt;<span class="stringliteral">"\n"</span>;
03188                 valid = scatterPointList-&gt;getNext(curScatterPoint);
03189         }
03190 }
03191 
03192 <span class="comment">//To test computeRaySum set params-&gt;modelBasedScatter.Attenthreshold=0</span>
03193 <span class="keywordtype">void</span> ModelBasedScatterCorrection::validateComputeRaySum(<a class="code" href="classImage.html">Image</a> &amp;emissionImage, <a class="code" href="classImage.html">Image</a> &amp;muImage) {
03194         coordIndex curScatterPoint;
03195         <span class="keywordtype">bool</span> valid = scatterPointList-&gt;getFirst(curScatterPoint);
03196         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> scatpt = 0;
03197         scatpt &lt; scatterPointList-&gt;count &amp;&amp; valid; scatpt++) {
03198                 <span class="keywordtype">int</span> iSlice = round(endPointList.nSlices / 2.0);
03199                 for (<span class="keywordtype">int</span> iAngle = 0 ; iAngle &lt;= endPointList.nAngles-1; iAngle++) {
03200                         coordIndex endPoint;
03201                         endPoint.x = endPointList.x(iAngle,iSlice);
03202                         endPoint.y = endPointList.y(iAngle,iSlice);
03203                         endPoint.z = endPointList.z(iAngle,iSlice);
03204                         <span class="keywordtype">float</span> xx1=curScatterPoint.x;
03205                         <span class="keywordtype">float</span> yy1=curScatterPoint.y;
03206                         <span class="keywordtype">float</span> xx2=endPoint.x;                       
03207                         <span class="keywordtype">float</span> yy2=endPoint.y;                     
03208                         <span class="keywordtype">float</span> emissionSum = 0;
03209                         <span class="keywordtype">float</span> muSum = 0;
03210                         <span class="keywordflow">if</span> (computeRaySum(emissionImage, muImage,
03211                                 endPoint, curScatterPoint, emissionSum, muSum)) {
03212                                 <span class="keywordflow">if</span> (emissionSum+muSum &gt; 0.0) { 
03213                                         cout&lt;&lt; <span class="stringliteral">";  "</span>&lt;&lt;curScatterPoint.x&lt;&lt;<span class="stringliteral">"   "</span>&lt;&lt; curScatterPoint.y&lt;&lt;<span class="stringliteral">"   "</span>&lt;&lt; curScatterPoint.z&lt;&lt;<span class="stringliteral">"   "</span>&lt;&lt;
03214                                              endPoint.x&lt;&lt;<span class="stringliteral">"   "</span>&lt;&lt; endPoint.y&lt;&lt;<span class="stringliteral">"   "</span>&lt;&lt; endPoint.z&lt;&lt;<span class="stringliteral">"   "</span>&lt;&lt; emissionSum&lt;&lt;<span class="stringliteral">"   "</span>&lt;&lt; muSum&lt;&lt;<span class="stringliteral">"\n"</span>;
03215                                 }
03216                         }
03217                 }               
03218                 valid = scatterPointList-&gt;getNext(curScatterPoint);
03219         }
03220 }
03221 
03222 
03223 <span class="keywordtype">float</span> ModelBasedScatterCorrection::probDetect(<span class="keywordtype">float</span> photonEnergy) {
03224         Params *params = Params::getInstance();
03225         <span class="keywordtype">float</span> lld  = params-&gt;modelBasedScatter.reconLLD;
03226         <span class="keywordtype">float</span> fwhm = params-&gt;modelBasedScatter.energyResolution * sqrt(511.0*photonEnergy);
03227         <span class="keywordtype">float</span> background = params-&gt;modelBasedScatter.energyBackground;
03228 
03229         <span class="comment">//   erf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt</span>
03230         <span class="comment">//   erfc(x) = 2/sqrt(pi)* integral from x to infinity of exp(-t*t) dt</span>
03231         <span class="comment">// erf(x)+erfc(x) = 1</span>
03232         <span class="comment">//</span>
03233         <span class="comment">// Assume the energy measured has a Gaussian distribution with mean</span>
03234         <span class="comment">// photonEnergy and FWHM  fwhm.</span>
03235         <span class="comment">// Then, the probability of detection (i.e., measured as above lld) is</span>
03236         <span class="comment">// the integral from lld to infinity (technically the uld, but </span>
03237         <span class="comment">//   that is probably irrelevant) of a Gaussian with mean photonEnergy (pe)</span>
03238         <span class="comment">// and FWHM of fhwm (or sigma=f/2.3548   2.3548 = sqrt(8 ln2))</span>
03239 
03240         <span class="keywordtype">float</span> sig=fwhm / 2.3548;
03241 
03242         <span class="comment">// integral from lld to inf of 1/(sqrt(2pi)sig)exp(-((x-pe)^2)/(2sig^2))dx</span>
03243         <span class="comment">//  do change of variables y = (x-pe)/(sqrt(2)sig)</span>
03244         <span class="comment">// = integral from l to inf of 1/sqrt(pi)exp(-y^2))dy</span>
03245         <span class="comment">// = 0.5[integral from l to inf of 2/sqrt(pi)exp(-y^2))dy]</span>
03246 
03247         <span class="keywordtype">float</span> l = (lld - photonEnergy) / (sqrt(2.)*sig) ; 
03248 
03249         <span class="comment">// if l &gt; 0, then the probability is 0.5 * erfc(l)</span>
03250         <span class="comment">// if l &lt; 0 then = 0.5 * [integral l to 0 + integral from 0 to infinity]</span>
03251         <span class="comment">//               = 0.5 * [integral from 0 to -l (symmetric) + 1.0]</span>
03252         <span class="keywordflow">if</span> (l &gt; 0.0) {
03253 <span class="comment">//              return 0.5*erfc(l);</span>
03254                 <span class="keywordflow">return</span> 0.5*((1. - background)*erfc(l)) + background;
03255         } <span class="keywordflow">else</span> {
03256 <span class="comment">//              return 0.5*(erf(-l) + 1.);</span>
03257                 <span class="keywordflow">return</span> 0.5*((1. - background)*(erf(-l) + 1.)) + background;
03258         }
03259 }
03260 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Dec 13 14:13:47 2007 for reconHRRT by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
